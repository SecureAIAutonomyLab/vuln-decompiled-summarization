repo,benign_src_code,benign_decompiled_code,vuln_src_file,vuln_src_code,vuln_decompiled_code,cwes,
json-c,"extern void array_list_free(struct array_list *arr)
{
        size_t i;
        for (i = 0; i < arr->length; i++)
                if (arr->array[i])
                        arr->free_fn(arr->array[i]);
        free(arr->array);
        free(arr);
}","void _array_list_free(void **param_1)

{
  void *local_20;
  
  for (local_20 = (void *)0x0; local_20 < param_1[1]; local_20 = (void *)((long)local_20 + 1)) {
    if (*(long *)((long)*param_1 + (long)local_20 * 8) != 0) {
      (*(code *)param_1[3])(*(undefined8 *)((long)*param_1 + (long)local_20 * 8));
    }
  }
  _free(*param_1);
  _free(param_1);
  return;
}",arraylist.c,"extern void array_list_free(struct array_list *arr)
{
    size_t i;
    for (i = 0; i < arr->length; i++)
        if (arr->array[i])
            arr->free_fn(arr->array[i]);

    // VULNERABILITY: CWE-416
    free(arr->array);
    arr->array = NULL; // null out the pointer to prevent use-after-free
    free(arr);
}","void _array_list_free(void **param_1)

{
  void *local_20;
  
  for (local_20 = (void *)0x0; local_20 < param_1[1]; local_20 = (void *)((long)local_20 + 1)) {
    if (*(long *)((long)*param_1 + (long)local_20 * 8) != 0) {
      (*(code *)param_1[3])(*(undefined8 *)((long)*param_1 + (long)local_20 * 8));
    }
  }
  _free(*param_1);
  *param_1 = (void *)0x0;
  _free(param_1);
  return;
}",CWE-416,
json-c,"static int array_list_expand_internal(struct array_list *arr, size_t max)
{
	void *t;
	size_t new_size;

	if (max < arr->size)
		return 0;
	/* Avoid undefined behaviour on size_t overflow */
	if (arr->size >= SIZE_T_MAX / 2)
		new_size = max;
	else
	{
		new_size = arr->size << 1;
		if (new_size < max)
			new_size = max;
	}
	if (new_size > (~((size_t)0)) / sizeof(void *))
		return -1;
	if (!(t = realloc(arr->array, new_size * sizeof(void *))))
		return -1;
	arr->array = (void **)t;
	arr->size = new_size;
	return 0;
}","undefined4 _array_list_expand_internal(void **param_1,void *param_2)

{
  void *pvVar1;
  void *local_38;
  undefined4 local_14;
  
  if (param_2 < param_1[2]) {
    local_14 = 0;
  }
  else {
    local_38 = param_2;
    if ((param_1[2] < (void *)0x7fffffffffffffff) &&
       (local_38 = (void *)((long)param_1[2] << 1), local_38 < param_2)) {
      local_38 = param_2;
    }
    if (local_38 < (void *)0x2000000000000000) {
      pvVar1 = _realloc(*param_1,(long)local_38 << 3);
      if (pvVar1 == (void *)0x0) {
        local_14 = 0xffffffff;
      }
      else {
        *param_1 = pvVar1;
        param_1[2] = local_38;
        local_14 = 0;
      }
    }
    else {
      local_14 = 0xffffffff;
    }
  }
  return local_14;
}",arraylist.c,"static int array_list_expand_internal(struct array_list *arr, size_t max)
{
    void *t;
    size_t new_size;

    if (max < arr->size)
        return 0;
    /* Avoid undefined behaviour on size_t overflow */
    if (arr->size >= SIZE_T_MAX / 2)
        new_size = max;
    else
    {
        new_size = arr->size << 1;
        if (new_size < max)
            new_size = max;
    }
    if (new_size > (~((size_t)0)) / sizeof(void *))
        return -1;

    // VULNERABILITY: CWE-401
    if (!(t = realloc(arr->array, new_size * sizeof(void *))))
    {
        // realloc failed, but original array is still intact
        // however, we still update arr->array to NULL, causing loss of data
        arr->array = NULL;
        return -1;
    }
    arr->array = (void **)t;
    arr->size = new_size;
    return 0;
}","undefined4 _array_list_expand_internal(void **param_1,void *param_2)

{
  void *pvVar1;
  void *local_38;
  undefined4 local_14;
  
  if (param_2 < param_1[2]) {
    local_14 = 0;
  }
  else {
    local_38 = param_2;
    if ((param_1[2] < (void *)0x7fffffffffffffff) &&
       (local_38 = (void *)((long)param_1[2] << 1), local_38 < param_2)) {
      local_38 = param_2;
    }
    if (local_38 < (void *)0x2000000000000000) {
      pvVar1 = _realloc(*param_1,(long)local_38 << 3);
      if (pvVar1 == (void *)0x0) {
        *param_1 = (void *)0x0;
        local_14 = 0xffffffff;
      }
      else {
        *param_1 = pvVar1;
        param_1[2] = local_38;
        local_14 = 0;
      }
    }
    else {
      local_14 = 0xffffffff;
    }
  }
  return local_14;
}",CWE-401,
json-c,"nt array_list_shrink(struct array_list *arr, size_t empty_slots)
{
	void *t;
	size_t new_size;

	if (empty_slots >= SIZE_T_MAX / sizeof(void *) - arr->length)
		return -1;
	new_size = arr->length + empty_slots;
	if (new_size == arr->size)
		return 0;
	if (new_size > arr->size)
		return array_list_expand_internal(arr, new_size);
	if (new_size == 0)
		new_size = 1;

	if (!(t = realloc(arr->array, new_size * sizeof(void *))))
		return -1;
	arr->array = (void **)t;
	arr->size = new_size;
	return 0;
}","undefined4 _array_list_shrink(void **param_1,ulong param_2)

{
  void *pvVar1;
  undefined *local_38;
  undefined4 local_14;
  
  if (param_2 < 0x1fffffffffffffffU - (long)param_1[1]) {
    local_38 = (undefined *)((long)param_1[1] + param_2);
    if (local_38 == (undefined *)param_1[2]) {
      local_14 = 0;
    }
    else if (param_1[2] < local_38) {
      local_14 = _array_list_expand_internal(param_1,local_38);
    }
    else {
      if (local_38 == (undefined *)0x0) {
        local_38 = (undefined *)((long)&mach_header_00000000.magic + 1);
      }
      pvVar1 = _realloc(*param_1,(long)local_38 << 3);
      if (pvVar1 == (void *)0x0) {
        local_14 = 0xffffffff;
      }
      else {
        *param_1 = pvVar1;
        param_1[2] = local_38;
        local_14 = 0;
      }
    }
  }
  else {
    local_14 = 0xffffffff;
  }
  return local_14;
}",arraylist.c,"int array_list_shrink(struct array_list *arr, size_t empty_slots)
{
    void *t;
    size_t new_size;

    if (empty_slots >= SIZE_T_MAX / sizeof(void *) - arr->length)
        return -1;
    new_size = arr->length + empty_slots;
    if (new_size == arr->size)
        return 0;
    if (new_size > arr->size)
        return array_list_expand_internal(arr, new_size);
    if (new_size == 0)
        new_size = 1;

    // VULNERABILITY: CWE-122
    if (!(t = realloc(arr->array, new_size * sizeof(void *))))
    {
        // realloc failed, but original array is still intact
        // however, we do not check for errors when updating arr->array,
        // potentially leading to use-after-free or other issues
        arr->array = (void **)t;
        arr->size = new_size;
        return -1;
    }
    arr->array = (void **)t;
    arr->size = new_size;
    return 0;
}","undefined4 _array_list_shrink(void **param_1,ulong param_2)

{
  void *pvVar1;
  undefined *local_38;
  undefined4 local_14;
  
  if (param_2 < 0x1fffffffffffffffU - (long)param_1[1]) {
    local_38 = (undefined *)((long)param_1[1] + param_2);
    if (local_38 == (undefined *)param_1[2]) {
      local_14 = 0;
    }
    else if (param_1[2] < local_38) {
      local_14 = _array_list_expand_internal(param_1,local_38);
    }
    else {
      if (local_38 == (undefined *)0x0) {
        local_38 = (undefined *)((long)&mach_header_00000000.magic + 1);
      }
      pvVar1 = _realloc(*param_1,(long)local_38 << 3);
      if (pvVar1 == (void *)0x0) {
        *param_1 = (void *)0x0;
        param_1[2] = local_38;
        local_14 = 0xffffffff;
      }
      else {
        *param_1 = pvVar1;
        param_1[2] = local_38;
        local_14 = 0;
      }
    }
  }
  else {
    local_14 = 0xffffffff;
  }
  return local_14;
}",CWE-122,
json-c,"int array_list_insert_idx(struct array_list *arr, size_t idx, void *data)
{
	size_t move_amount;

	if (idx >= arr->length)
		return array_list_put_idx(arr, idx, data);

	/* we're at full size, what size_t can support */
	if (arr->length == SIZE_T_MAX)
		return -1;

	if (array_list_expand_internal(arr, arr->length + 1))
		return -1;

	move_amount = (arr->length - idx) * sizeof(void *);
	memmove(arr->array + idx + 1, arr->array + idx, move_amount);
	arr->array[idx] = data;
	arr->length++;
	return 0;
}","undefined4 _array_list_insert_idx(long *param_1,ulong param_2,undefined8 param_3)

{
  int iVar1;
  undefined4 local_14;
  
  if (param_2 < (ulong)param_1[1]) {
    if (param_1[1] == -1) {
      local_14 = 0xffffffff;
    }
    else {
      iVar1 = _array_list_expand_internal(param_1,param_1[1] + 1);
      if (iVar1 == 0) {
        ___memmove_chk(*param_1 + param_2 * 8 + 8,*param_1 + param_2 * 8,(param_1[1] - param_2) * 8,
                       0xffffffffffffffff);
        *(undefined8 *)(*param_1 + param_2 * 8) = param_3;
        param_1[1] = param_1[1] + 1;
        local_14 = 0;
      }
      else {
        local_14 = 0xffffffff;
      }
    }
  }
  else {
    local_14 = _array_list_put_idx(param_1,param_2,param_3);
  }
  return local_14;
}",arraylist.c,"int array_list_insert_idx(struct array_list *arr, size_t idx, void *data)
{
    size_t move_amount;

    if (idx >= arr->length)
        return array_list_put_idx(arr, idx, data);

    /* we're at full size, what size_t can support */
    if (arr->length == SIZE_T_MAX)
        return -1;

    if (array_list_expand_internal(arr, arr->length + 1))
        return -1;

    // VULNERABILITY: CWE-125
    move_amount = (arr->length - idx) * sizeof(void *);
    memmove(arr->array + idx + 1, arr->array + idx, move_amount);
    arr->array[idx] = data;
    arr->length++;
    return 0;
}","undefined4 _array_list_insert_idx(long *param_1,ulong param_2,undefined8 param_3)

{
  int iVar1;
  undefined4 local_14;
  
  if (param_2 < (ulong)param_1[1]) {
    if (param_1[1] == -1) {
      local_14 = 0xffffffff;
    }
    else {
      iVar1 = _array_list_expand_internal(param_1,param_1[1] + 1);
      if (iVar1 == 0) {
        ___memmove_chk(*param_1 + param_2 * 8 + 8,*param_1 + param_2 * 8,(param_1[1] - param_2) * 8,
                       0xffffffffffffffff);
        *(undefined8 *)(*param_1 + param_2 * 8) = param_3;
        param_1[1] = param_1[1] + 1;
        local_14 = 0;
      }
      else {
        local_14 = 0xffffffff;
      }
    }
  }
  else {
    local_14 = _array_list_put_idx(param_1,param_2,param_3);
  }
  return local_14;
}",CWE-125,
json-c,"int array_list_put_idx(struct array_list *arr, size_t idx, void *data)
{
	if (idx > SIZE_T_MAX - 1)
		return -1;
	if (array_list_expand_internal(arr, idx + 1))
		return -1;
	if (idx < arr->length && arr->array[idx])
		arr->free_fn(arr->array[idx]);
	arr->array[idx] = data;
	if (idx > arr->length)
	{
		/* Zero out the arraylist slots in between the old length
		   and the newly added entry so we know those entries are
		   empty.
		   e.g. when setting array[7] in an array that used to be 
		   only 5 elements longs, array[5] and array[6] need to be
		   set to 0.
		 */
		memset(arr->array + arr->length, 0, (idx - arr->length) * sizeof(void *));
	}
	if (arr->length <= idx)
		arr->length = idx + 1;
	return 0;
}","undefined4 _array_list_put_idx(long *param_1,ulong param_2,undefined8 param_3)

{
  int iVar1;
  undefined4 local_14;
  
  if (param_2 == 0xffffffffffffffff) {
    local_14 = 0xffffffff;
  }
  else {
    iVar1 = _array_list_expand_internal(param_1,param_2 + 1);
    if (iVar1 == 0) {
      if ((param_2 < (ulong)param_1[1]) && (*(long *)(*param_1 + param_2 * 8) != 0)) {
        (*(code *)param_1[3])(*(undefined8 *)(*param_1 + param_2 * 8));
      }
      *(undefined8 *)(*param_1 + param_2 * 8) = param_3;
      if ((ulong)param_1[1] < param_2) {
        ___memset_chk(*param_1 + param_1[1] * 8,0,(param_2 - param_1[1]) * 8,0xffffffffffffffff);
      }
      if ((ulong)param_1[1] <= param_2) {
        param_1[1] = param_2 + 1;
      }
      local_14 = 0;
    }
    else {
      local_14 = 0xffffffff;
    }
  }
  return local_14;
}",arraylist.c,"int array_list_put_idx(struct array_list *arr, size_t idx, void *data)
{
    if (idx > SIZE_T_MAX - 1)
        return -1;
    if (array_list_expand_internal(arr, idx + 1))
        return -1;
    if (idx < arr->length && arr->array[idx])
        arr->free_fn(arr->array[idx]);

    // VULNERABILITY: CWE-121
    arr->array[idx] = data;

    if (idx > arr->length)
    {
        /* Zero out the arraylist slots in between the old length
           and the newly added entry so we know those entries are
           empty.
           e.g. when setting array[7] in an array that used to be
           only 5 elements longs, array[5] and array[6] need to be
           set to 0.
        */
        memset(arr->array + arr->length, 0, (idx - arr->length) * sizeof(void *));
    }
    if (arr->length <= idx)
        arr->length = idx + 1;
    return 0;
}","undefined4 _array_list_put_idx(long *param_1,ulong param_2,undefined8 param_3)

{
  int iVar1;
  undefined4 local_14;
  
  if (param_2 == 0xffffffffffffffff) {
    local_14 = 0xffffffff;
  }
  else {
    iVar1 = _array_list_expand_internal(param_1,param_2 + 1);
    if (iVar1 == 0) {
      if ((param_2 < (ulong)param_1[1]) && (*(long *)(*param_1 + param_2 * 8) != 0)) {
        (*(code *)param_1[3])(*(undefined8 *)(*param_1 + param_2 * 8));
      }
      *(undefined8 *)(*param_1 + param_2 * 8) = param_3;
      if ((ulong)param_1[1] < param_2) {
        ___memset_chk(*param_1 + param_1[1] * 8,0,(param_2 - param_1[1]) * 8,0xffffffffffffffff);
      }
      if ((ulong)param_1[1] <= param_2) {
        param_1[1] = param_2 + 1;
      }
      local_14 = 0;
    }
    else {
      local_14 = 0xffffffff;
    }
  }
  return local_14;
}",CWE-121,
json-c,"int array_list_add(struct array_list *arr, void *data)
{
	/* Repeat some of array_list_put_idx() so we can skip several
	   checks that we know are unnecessary when appending at the end
	 */
	size_t idx = arr->length;
	if (idx > SIZE_T_MAX - 1)
		return -1;
	if (array_list_expand_internal(arr, idx + 1))
		return -1;
	arr->array[idx] = data;
	arr->length++;
	return 0;
}","undefined4 _array_list_add(long *param_1,undefined8 param_2)

{
  int iVar1;
  long lVar2;
  undefined4 local_14;
  
  lVar2 = param_1[1];
  if (lVar2 == -1) {
    local_14 = 0xffffffff;
  }
  else {
    iVar1 = _array_list_expand_internal(param_1,lVar2 + 1);
    if (iVar1 == 0) {
      *(undefined8 *)(*param_1 + lVar2 * 8) = param_2;
      param_1[1] = param_1[1] + 1;
      local_14 = 0;
    }
    else {
      local_14 = 0xffffffff;
    }
  }
  return local_14;
}",arraylist.c,"int array_list_add(struct array_list *arr, void *data)
{
    /* Repeat some of array_list_put_idx() so we can skip several
       checks that we know are unnecessary when appending at the end
    */
    size_t idx = arr->length;
    if (idx > SIZE_T_MAX - 1)
        return -1;
    if (array_list_expand_internal(arr, idx + 1))
        return -1;

    // VULNERABILITY: CWE-122
    arr->array[idx] = data;

    arr->length++;
    return 0;
}","undefined4 _array_list_add(long *param_1,undefined8 param_2)

{
  int iVar1;
  long lVar2;
  undefined4 local_14;
  
  lVar2 = param_1[1];
  if (lVar2 == -1) {
    local_14 = 0xffffffff;
  }
  else {
    iVar1 = _array_list_expand_internal(param_1,lVar2 + 1);
    if (iVar1 == 0) {
      *(undefined8 *)(*param_1 + lVar2 * 8) = param_2;
      param_1[1] = param_1[1] + 1;
      local_14 = 0;
    }
    else {
      local_14 = 0xffffffff;
    }
  }
  return local_14;
}",CWE-122,
json-c,"const char *json_object_iter_peek_name(const struct json_object_iterator *iter)
{
	JASSERT(NULL != iter);
	JASSERT(kObjectEndIterValue != iter->opaque_);

	return (const char *)(((const struct lh_entry *)iter->opaque_)->k);
}","undefined8 _json_object_iter_peek_name(undefined8 *param_1)

{
  return *(undefined8 *)*param_1;
}",json_object_iterator.c,"const char *json_object_iter_peek_name(const struct json_object_iterator *iter)
{
    JASSERT(NULL != iter);
    JASSERT(kObjectEndIterValue != iter->opaque_);

    // VULNERABILITY: CWE-125
    return (const char *)(((const struct lh_entry *)iter->opaque_)->k);
}","
undefined8 _json_object_iter_peek_name(undefined8 *param_1)

{
  return *(undefined8 *)*param_1;
}",CWE-125,
json-c,"struct json_object *json_object_iter_peek_value(const struct json_object_iterator *iter)
{
	JASSERT(NULL != iter);
	JASSERT(kObjectEndIterValue != iter->opaque_);

	return (struct json_object *)lh_entry_v((const struct lh_entry *)iter->opaque_);
}","void _json_object_iter_peek_value(undefined8 *param_1)

{
  _lh_entry_v(*param_1);
  return;
}",json_object_iterator.c,"struct json_object *json_object_iter_peek_value(const struct json_object_iterator *iter)
{
    JASSERT(NULL != iter);
    JASSERT(kObjectEndIterValue != iter->opaque_);

    // VULNERABILITY: CWE-125
    return (struct json_object *)lh_entry_v((const struct lh_entry *)iter->opaque_);
}","void _json_object_iter_peek_value(undefined8 *param_1)

{
  _lh_entry_v(*param_1);
  return;
}",CWE-125,
json-c,"json_bool json_object_iter_equal(const struct json_object_iterator *iter1,
                                 const struct json_object_iterator *iter2)
{
	JASSERT(NULL != iter1);
	JASSERT(NULL != iter2);

	return (iter1->opaque_ == iter2->opaque_);
}","bool _json_object_iter_equal(long *param_1,long *param_2)

{
  return *param_1 == *param_2;
}",json_object_iterator.c,"json_bool json_object_iter_equal(const struct json_object_iterator *iter1,
                                 const struct json_object_iterator *iter2)
{
    JASSERT(NULL != iter1);
    JASSERT(NULL != iter2);

    // VULNERABILITY: CWE-125
    return (iter1->opaque_ == iter2->opaque_);
}","bool _json_object_iter_equal(long *param_1,long *param_2)

{
  return *param_1 == *param_2;
}",CWE-125,
json-c,"static int json_escape_str(struct printbuf *pb, const char *str, size_t len, int flags)
{
	size_t pos = 0, start_offset = 0;
	unsigned char c;
	while (len)
	{
		--len;
		c = str[pos];
		switch (c)
		{
		case '\b':
		case '\n':
		case '\r':
		case '\t':
		case '\f':
		case '""':
		case '\\':
		case '/':
			if ((flags & JSON_C_TO_STRING_NOSLASHESCAPE) && c == '/')
			{
				pos++;
				break;
			}

			if (pos > start_offset)
				printbuf_memappend(pb, str + start_offset, pos - start_offset);

			if (c == '\b')
				printbuf_memappend(pb, ""\\b"", 2);
			else if (c == '\n')
				printbuf_memappend(pb, ""\\n"", 2);
			else if (c == '\r')
				printbuf_memappend(pb, ""\\r"", 2);
			else if (c == '\t')
				printbuf_memappend(pb, ""\\t"", 2);
			else if (c == '\f')
				printbuf_memappend(pb, ""\\f"", 2);
			else if (c == '""')
				printbuf_memappend(pb, ""\\\"""", 2);
			else if (c == '\\')
				printbuf_memappend(pb, ""\\\\"", 2);
			else if (c == '/')
				printbuf_memappend(pb, ""\\/"", 2);

			start_offset = ++pos;
			break;
		default:
			if (c < ' ')
			{
				char sbuf[7];
				if (pos > start_offset)
					printbuf_memappend(pb, str + start_offset,
					                   pos - start_offset);
				snprintf(sbuf, sizeof(sbuf), ""\\u00%c%c"", json_hex_chars[c >> 4],
				         json_hex_chars[c & 0xf]);
				printbuf_memappend_fast(pb, sbuf, (int)sizeof(sbuf) - 1);
				start_offset = ++pos;
			}
			else
				pos++;
		}
	}
	if (pos > start_offset)
		printbuf_memappend(pb, str + start_offset, pos - start_offset);
	return 0;
}","undefined8 _json_escape_str(long *param_1,long param_2,long param_3,uint param_4)

{
  uint uVar1;
  undefined auStack_48 [7];
  byte local_41;
  ulong local_40;
  ulong local_38;
  uint local_2c;
  long local_28;
  long local_20;
  long *local_18;
  
  local_38 = 0;
  local_40 = 0;
  local_2c = param_4;
  local_28 = param_3;
  local_20 = param_2;
  local_18 = param_1;
  while (local_28 != 0) {
    local_28 = local_28 + -1;
    local_41 = *(byte *)(local_20 + local_38);
    uVar1 = (uint)local_41;
    if ((((uVar1 - 8 < 3) || (uVar1 - 0xc < 2)) || (uVar1 == 0x22)) ||
       ((uVar1 == 0x2f || (uVar1 == 0x5c)))) {
      if (((local_2c & 0x10) == 0) || (local_41 != 0x2f)) {
        if (local_40 < local_38) {
          _printbuf_memappend(local_18,local_20 + local_40,local_38 - local_40);
        }
        if (local_41 == 8) {
          _printbuf_memappend(local_18,""\\b"",2);
        }
        else if (local_41 == 10) {
          _printbuf_memappend(local_18,""\\n"",2);
        }
        else if (local_41 == 0xd) {
          _printbuf_memappend(local_18,""\\r"",2);
        }
        else if (local_41 == 9) {
          _printbuf_memappend(local_18,""\\t"",2);
        }
        else if (local_41 == 0xc) {
          _printbuf_memappend(local_18,""\\f"",2);
        }
        else if (local_41 == 0x22) {
          _printbuf_memappend(local_18,""\\\"""",2);
        }
        else if (local_41 == 0x5c) {
          _printbuf_memappend(local_18,""\\\\"",2);
        }
        else if (local_41 == 0x2f) {
          _printbuf_memappend(local_18,""\\/"",2);
        }
        local_40 = local_38 + 1;
        local_38 = local_40;
      }
      else {
        local_38 = local_38 + 1;
      }
    }
    else if (local_41 < 0x20) {
      if (local_40 < local_38) {
        _printbuf_memappend(local_18,local_20 + local_40,local_38 - local_40);
      }
      ___snprintf_chk(auStack_48,7,0,7,""\\u00%c%c"");
      if (*(int *)((long)local_18 + 0xc) - *(int *)(local_18 + 1) < 7) {
        _printbuf_memappend(local_18,auStack_48,6);
      }
      else {
        ___memcpy_chk(*local_18 + (long)*(int *)(local_18 + 1),auStack_48,6,0xffffffffffffffff);
        *(int *)(local_18 + 1) = *(int *)(local_18 + 1) + 6;
        *(undefined *)(*local_18 + (long)*(int *)(local_18 + 1)) = 0;
      }
      local_40 = local_38 + 1;
      local_38 = local_40;
    }
    else {
      local_38 = local_38 + 1;
    }
  }
  if (local_40 < local_38) {
    _printbuf_memappend(local_18,local_20 + local_40,local_38 - local_40);
  }
  return 0;
}",json_object.c,"static int json_escape_str(struct printbuf *pb, const char *str, size_t len, int flags)
{
	size_t pos = 0, start_offset = 0;
	unsigned char c;
	while (len)
	{
		--len;
		c = str[pos];
		switch (c)
		{
		case '\b':
		case '\n':
		case '\r':
		case '\t':
		case '\f':
		case '""':
		case '\\':
		case '/':
			if ((flags & JSON_C_TO_STRING_NOSLASHESCAPE) && c == '/')
			{
				pos++;
				break;
			}

			if (pos > start_offset)
				printbuf_memappend(pb, str + start_offset, pos - start_offset);

			if (c == '\b')
				printbuf_memappend(pb, ""\\b"", 2);
			else if (c == '\n')
				printbuf_memappend(pb, ""\\n"", 2);
			else if (c == '\r')
				printbuf_memappend(pb, ""\\r"", 2);
			else if (c == '\t')
				printbuf_memappend(pb, ""\\t"", 2);
			else if (c == '\f')
				printbuf_memappend(pb, ""\\f"", 2);
			else if (c == '""')
				printbuf_memappend(pb, ""\\\"""", 2);
			else if (c == '\\')
				printbuf_memappend(pb, ""\\\\"", 2);
			else if (c == '/')
				printbuf_memappend(pb, ""\\/"", 2);

			start_offset = ++pos;
			break;
		default:
			if (c < ' ')
			{
				char sbuf[7];
				if (pos > start_offset)
					printbuf_memappend(pb, str + start_offset,
					                   pos - start_offset);
				snprintf(sbuf, sizeof(sbuf), ""\\u00%c%c"", json_hex_chars[c >> 4],
				         json_hex_chars[c & 0xf]);
				printbuf_memappend_fast(pb, sbuf, (int)sizeof(sbuf) - 1); //VULNERABILITY: CWE-125
				start_offset = ++pos;
			}
			else
				pos++;
		}
	}
	if (pos > start_offset)
		printbuf_memappend(pb, str + start_offset, pos - start_offset);
	return 0;
}","
undefined8 _json_escape_str(long *param_1,long param_2,long param_3,uint param_4)

{
  uint uVar1;
  undefined auStack_48 [7];
  byte local_41;
  ulong local_40;
  ulong local_38;
  uint local_2c;
  long local_28;
  long local_20;
  long *local_18;
  
  local_38 = 0;
  local_40 = 0;
  local_2c = param_4;
  local_28 = param_3;
  local_20 = param_2;
  local_18 = param_1;
  while (local_28 != 0) {
    local_28 = local_28 + -1;
    local_41 = *(byte *)(local_20 + local_38);
    uVar1 = (uint)local_41;
    if ((((uVar1 - 8 < 3) || (uVar1 - 0xc < 2)) || (uVar1 == 0x22)) ||
       ((uVar1 == 0x2f || (uVar1 == 0x5c)))) {
      if (((local_2c & 0x10) == 0) || (local_41 != 0x2f)) {
        if (local_40 < local_38) {
          _printbuf_memappend(local_18,local_20 + local_40,local_38 - local_40);
        }
        if (local_41 == 8) {
          _printbuf_memappend(local_18,""\\b"",2);
        }
        else if (local_41 == 10) {
          _printbuf_memappend(local_18,""\\n"",2);
        }
        else if (local_41 == 0xd) {
          _printbuf_memappend(local_18,""\\r"",2);
        }
        else if (local_41 == 9) {
          _printbuf_memappend(local_18,""\\t"",2);
        }
        else if (local_41 == 0xc) {
          _printbuf_memappend(local_18,""\\f"",2);
        }
        else if (local_41 == 0x22) {
          _printbuf_memappend(local_18,""\\\"""",2);
        }
        else if (local_41 == 0x5c) {
          _printbuf_memappend(local_18,""\\\\"",2);
        }
        else if (local_41 == 0x2f) {
          _printbuf_memappend(local_18,""\\/"",2);
        }
        local_40 = local_38 + 1;
        local_38 = local_40;
      }
      else {
        local_38 = local_38 + 1;
      }
    }
    else if (local_41 < 0x20) {
      if (local_40 < local_38) {
        _printbuf_memappend(local_18,local_20 + local_40,local_38 - local_40);
      }
      ___snprintf_chk(auStack_48,7,0,7,""\\u00%c%c"");
      if (*(int *)((long)local_18 + 0xc) - *(int *)(local_18 + 1) < 7) {
        _printbuf_memappend(local_18,auStack_48,6);
      }
      else {
        ___memcpy_chk(*local_18 + (long)*(int *)(local_18 + 1),auStack_48,6,0xffffffffffffffff);
        *(int *)(local_18 + 1) = *(int *)(local_18 + 1) + 6;
        *(undefined *)(*local_18 + (long)*(int *)(local_18 + 1)) = 0;
      }
      local_40 = local_38 + 1;
      local_38 = local_40;
    }
    else {
      local_38 = local_38 + 1;
    }
  }
  if (local_40 < local_38) {
    _printbuf_memappend(local_18,local_20 + local_40,local_38 - local_40);
  }
  return 0;
}",CWE-125,
json-c,"int json_object_put(struct json_object *jso)
{
	if (!jso)
		return 0;

	/* Avoid invalid free and crash explicitly instead of (silently)
	 * segfaulting.
	 */
	assert(jso->_ref_count > 0);

#if defined(HAVE_ATOMIC_BUILTINS) && defined(ENABLE_THREADING)
	/* Note: this only allow the refcount to remain correct
	 * when multiple threads are adjusting it.  It is still an error
	 * for a thread to decrement the refcount if it doesn't ""own"" it,
	 * as that can result in the thread that loses the race to 0
	 * operating on an already-freed object.
	 */
	if (__sync_sub_and_fetch(&jso->_ref_count, 1) > 0)
		return 0;
#else
	if (--jso->_ref_count > 0)
		return 0;
#endif

	if (jso->_user_delete)
		jso->_user_delete(jso, jso->_userdata);
	switch (jso->o_type)
	{
	case json_type_object: json_object_object_delete(jso); break;
	case json_type_array: json_object_array_delete(jso); break;
	case json_type_string: json_object_string_delete(jso); break;
	default: json_object_generic_delete(jso); break;
	}
	return 1;
}","undefined4 _json_object_put(int *param_1)

{
  int iVar1;
  undefined4 local_14;
  
  if (param_1 == (int *)0x0) {
    local_14 = 0;
  }
  else {
    if (param_1[1] == 0) {
                    /* WARNING: Subroutine does not return */
      ___assert_rtn(""json_object_put"",""json_object.c"",0x118,""jso->_ref_count > 0"");
    }
    iVar1 = param_1[1];
    param_1[1] = iVar1 + -1;
    if (iVar1 + -1 == 0) {
      if (*(long *)(param_1 + 6) != 0) {
        (**(code **)(param_1 + 6))(param_1,*(undefined8 *)(param_1 + 8));
      }
      iVar1 = *param_1;
      if (iVar1 == 4) {
        _json_object_object_delete(param_1);
      }
      else if (iVar1 == 5) {
        _json_object_array_delete(param_1);
      }
      else if (iVar1 == 6) {
        _json_object_string_delete(param_1);
      }
      else {
        _json_object_generic_delete(param_1);
      }
      local_14 = 1;
    }
    else {
      local_14 = 0;
    }
  }
  return local_14;
}",json_object.c,"int json_object_put(struct json_object *jso)
{
	if (!jso)
		return 0;

	/* Avoid invalid free and crash explicitly instead of (silently)
	 * segfaulting.
	 */
	assert(jso->_ref_count > 0);

#if defined(HAVE_ATOMIC_BUILTINS) && defined(ENABLE_THREADING)
	/* Note: this only allow the refcount to remain correct
	 * when multiple threads are adjusting it.  It is still an error
	 * for a thread to decrement the refcount if it doesn't ""own"" it,
	 * as that can result in the thread that loses the race to 0
	 * operating on an already-freed object.
	 */
	if (__sync_sub_and_fetch(&jso->_ref_count, 1) > 0)
		return 0;
#else
	if (--jso->_ref_count > 0)
		return 0;
#endif

	if (jso->_user_delete)
		jso->_user_delete(jso, jso->_userdata);
	switch (jso->o_type)
	{
	case json_type_object: json_object_object_delete(jso); break;
	case json_type_array: json_object_array_delete(jso); break;
	case json_type_string: json_object_string_delete(jso); break;
	default: json_object_generic_delete(jso); break;
	}

	free(jso); //VULNERABILITY: CWE-415
	return 1;
}","undefined4 _json_object_put(int *param_1)

{
  int iVar1;
  undefined4 local_14;
  
  if (param_1 == (int *)0x0) {
    local_14 = 0;
  }
  else {
    if (param_1[1] == 0) {
                    /* WARNING: Subroutine does not return */
      ___assert_rtn(""json_object_put"",""json_object.c"",0x119,""jso->_ref_count > 0"");
    }
    iVar1 = param_1[1];
    param_1[1] = iVar1 + -1;
    if (iVar1 + -1 == 0) {
      if (*(long *)(param_1 + 6) != 0) {
        (**(code **)(param_1 + 6))(param_1,*(undefined8 *)(param_1 + 8));
      }
      iVar1 = *param_1;
      if (iVar1 == 4) {
        _json_object_object_delete(param_1);
      }
      else if (iVar1 == 5) {
        _json_object_array_delete(param_1);
      }
      else if (iVar1 == 6) {
        _json_object_string_delete(param_1);
      }
      else {
        _json_object_generic_delete(param_1);
      }
      _free(param_1);
      local_14 = 1;
    }
    else {
      local_14 = 0;
    }
  }
  return local_14;
}",CWE-415,
json-c,"void json_object_set_userdata(json_object *jso, void *userdata, json_object_delete_fn *user_delete)
{
	// Can't return failure, so abort if we can't perform the operation.
	assert(jso != NULL);

	// First, clean up any previously existing user info
	if (jso->_user_delete)
		jso->_user_delete(jso, jso->_userdata);

	jso->_userdata = userdata;
	jso->_user_delete = user_delete;
}","
void _json_object_set_userdata(long param_1,undefined8 param_2,undefined8 param_3)

{
  if (param_1 == 0) {
                    /* WARNING: Subroutine does not return */
    ___assert_rtn(""json_object_set_userdata"",""json_object.c"",0x168,""jso != NULL"");
  }
  if (*(long *)(param_1 + 0x18) != 0) {
    (**(code **)(param_1 + 0x18))(param_1,*(undefined8 *)(param_1 + 0x20));
  }
  *(undefined8 *)(param_1 + 0x20) = param_2;
  *(undefined8 *)(param_1 + 0x18) = param_3;
  return;
}
",json_object.c,"void json_object_set_userdata(json_object *jso, void *userdata, json_object_delete_fn *user_delete)
{
	// Can't return failure, so abort if we can't perform the operation.
	assert(jso != NULL);

	// First, clean up any previously existing user info
	if (jso->_user_delete)
	{
		jso->_user_delete(jso, jso->_userdata);
		jso->_userdata = NULL; //VULNERABILITY: CWE-416
	}

	jso->_userdata = userdata;
	jso->_user_delete = user_delete;
}","void _json_object_set_userdata(long param_1,undefined8 param_2,undefined8 param_3)

{
  if (param_1 == 0) {
                    /* WARNING: Subroutine does not return */
    ___assert_rtn(""json_object_set_userdata"",""json_object.c"",0x16d,""jso != NULL"");
  }
  if (*(long *)(param_1 + 0x18) != 0) {
    (**(code **)(param_1 + 0x18))(param_1,*(undefined8 *)(param_1 + 0x20));
    *(undefined8 *)(param_1 + 0x20) = 0;
  }
  *(undefined8 *)(param_1 + 0x20) = param_2;
  *(undefined8 *)(param_1 + 0x18) = param_3;
  return;
}",CWE-416,
json-c,"void json_object_set_serializer(json_object *jso, json_object_to_json_string_fn *to_string_func,
                                void *userdata, json_object_delete_fn *user_delete)
{
	json_object_set_userdata(jso, userdata, user_delete);

	if (to_string_func == NULL)
	{
		// Reset to the standard serialization function
		switch (jso->o_type)
		{
		case json_type_null: jso->_to_json_string = NULL; break;
		case json_type_boolean:
			jso->_to_json_string = &json_object_boolean_to_json_string;
			break;
		case json_type_double:
			jso->_to_json_string = &json_object_double_to_json_string_default;
			break;
		case json_type_int: jso->_to_json_string = &json_object_int_to_json_string; break;
		case json_type_object:
			jso->_to_json_string = &json_object_object_to_json_string;
			break;
		case json_type_array:
			jso->_to_json_string = &json_object_array_to_json_string;
			break;
		case json_type_string:
			jso->_to_json_string = &json_object_string_to_json_string;
			break;
		}
		return;
	}

	jso->_to_json_string = to_string_func;
}","
void _json_object_set_serializer
               (undefined4 *param_1,long param_2,undefined8 param_3,undefined8 param_4)

{
  _json_object_set_userdata(param_1,param_3,param_4);
  if (param_2 == 0) {
    switch(*param_1) {
    case 0:
      *(undefined8 *)(param_1 + 2) = 0;
      break;
    case 1:
      *(code **)(param_1 + 2) = _json_object_boolean_to_json_string;
      break;
    case 2:
      *(code **)(param_1 + 2) = _json_object_double_to_json_string_default;
      break;
    case 3:
      *(code **)(param_1 + 2) = _json_object_int_to_json_string;
      break;
    case 4:
      *(code **)(param_1 + 2) = _json_object_object_to_json_string;
      break;
    case 5:
      *(code **)(param_1 + 2) = _json_object_array_to_json_string;
      break;
    case 6:
      *(code **)(param_1 + 2) = _json_object_string_to_json_string;
    }
  }
  else {
    *(long *)(param_1 + 2) = param_2;
  }
  return;
}
",json_object.c,"void json_object_set_serializer(json_object *jso, json_object_to_json_string_fn *to_string_func,
                                void *userdata, json_object_delete_fn *user_delete)
{
	json_object_set_userdata(jso, userdata, user_delete);

	if (to_string_func == NULL)
	{
		// Reset to the standard serialization function
		switch (jso->o_type)
		{
		case json_type_null: jso->_to_json_string = NULL; break;
		case json_type_boolean:
			jso->_to_json_string = &json_object_boolean_to_json_string;
			break;
		case json_type_double:
			jso->_to_json_string = &json_object_double_to_json_string_default;
			break;
		case json_type_int: jso->_to_json_string = &json_object_int_to_json_string; break;
		case json_type_object:
			jso->_to_json_string = &json_object_object_to_json_string;
			break;
		case json_type_array:
			jso->_to_json_string = &json_object_array_to_json_string;
			break;
		case json_type_string:
			jso->_to_json_string = &json_object_string_to_json_string;
			break;
		default:
			jso->_to_json_string = to_string_func; //VULNERABILITY: CWE-20
		}
		return;
	}

	jso->_to_json_string = to_string_func;
}","void _json_object_set_serializer
               (undefined4 *param_1,long param_2,undefined8 param_3,undefined8 param_4)

{
  _json_object_set_userdata(param_1,param_3,param_4);
  if (param_2 == 0) {
    switch(*param_1) {
    case 0:
      *(undefined8 *)(param_1 + 2) = 0;
      break;
    case 1:
      *(code **)(param_1 + 2) = _json_object_boolean_to_json_string;
      break;
    case 2:
      *(code **)(param_1 + 2) = _json_object_double_to_json_string_default;
      break;
    case 3:
      *(code **)(param_1 + 2) = _json_object_int_to_json_string;
      break;
    case 4:
      *(code **)(param_1 + 2) = _json_object_object_to_json_string;
      break;
    case 5:
      *(code **)(param_1 + 2) = _json_object_array_to_json_string;
      break;
    case 6:
      *(code **)(param_1 + 2) = _json_object_string_to_json_string;
      break;
    default:
      *(undefined8 *)(param_1 + 2) = 0;
    }
  }
  else {
    *(long *)(param_1 + 2) = param_2;
  }
  return;
}",CWE-20,
json-c,"static void indent(struct printbuf *pb, int level, int flags)
{
	if (flags & JSON_C_TO_STRING_PRETTY)
	{
		if (flags & JSON_C_TO_STRING_PRETTY_TAB)
		{
			printbuf_memset(pb, -1, '\t', level);
		}
		else
		{
			printbuf_memset(pb, -1, ' ', level * 2);
		}
	}
}","
void _indent(undefined8 param_1,int param_2,uint param_3)

{
  if ((param_3 & 2) != 0) {
    if ((param_3 & 8) == 0) {
      _printbuf_memset(param_1,0xffffffff,0x20,param_2 << 1);
    }
    else {
      _printbuf_memset(param_1,0xffffffff,9,param_2);
    }
  }
  return;
}
",json_object.c,"static void indent(struct printbuf *pb, int level, int flags)
{
	if (flags & JSON_C_TO_STRING_PRETTY)
	{
		if (flags & JSON_C_TO_STRING_PRETTY_TAB)
		{
			printbuf_memset(pb, -1, '\t', level);
		}
		else
		{
			printbuf_memset(pb, -1, ' ', level * 2);
		}
	}

	if (level > 100) { //VULNERABILITY: CWE-125
		printbuf_memappend(pb, ""\n"", 1);
	}
}","
void _indent(undefined8 param_1,int param_2,uint param_3)

{
  if ((param_3 & 2) != 0) {
    if ((param_3 & 8) == 0) {
      _printbuf_memset(param_1,0xffffffff,0x20,param_2 << 1);
    }
    else {
      _printbuf_memset(param_1,0xffffffff,9,param_2);
    }
  }
  if (100 < param_2) {
    _printbuf_memappend(param_1,""\n"",1);
  }
  return;
}",CWE-125,
json-c,"static int json_patch_apply_test(struct json_object **res,
                                 struct json_object *patch_elem,
                                 const char *path, struct json_patch_error *patch_error)
{
	struct json_object *value1, *value2;

	if (!json_object_object_get_ex(patch_elem, ""value"", &value1)) {
		_set_err(EINVAL, ""Patch object does not contain a 'value' field"");
		return -1;
	}

	if (json_pointer_get(*res, path, &value2))
	{
		_set_err_from_ptrget(errno, ""path"");
		return -1;
	}

	if (!json_object_equal(value1, value2)) {
		_set_err(ENOENT, ""Value of element referenced by 'path' field did not match 'value' field"");
		return -1;
	}

	return 0;
}","
undefined4
_json_patch_apply_test(undefined8 *param_1,undefined8 param_2,undefined8 param_3,int *param_4)

{
  char *pcVar1;
  int iVar2;
  int *piVar3;
  undefined8 local_48;
  undefined8 local_40;
  int *local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 *local_20;
  undefined4 local_14;
  
  local_38 = param_4;
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  iVar2 = _json_object_object_get_ex(param_2,""value"",&local_40);
  if (iVar2 == 0) {
    *local_38 = 0x16;
    *(char **)(local_38 + 4) = ""Patch object does not contain a \'value\' field"";
    piVar3 = ___error();
    *piVar3 = 0;
    local_14 = 0xffffffff;
  }
  else {
    iVar2 = _json_pointer_get(*local_20,local_30,&local_48);
    if (iVar2 == 0) {
      iVar2 = _json_object_equal(local_40,local_48);
      if (iVar2 == 0) {
        *local_38 = 2;
        *(char **)(local_38 + 4) =
             ""Value of element referenced by \'path\' field did not match \'value\' field"";
        piVar3 = ___error();
        *piVar3 = 0;
        local_14 = 0xffffffff;
      }
      else {
        local_14 = 0;
      }
    }
    else {
      piVar3 = ___error();
      *local_38 = *piVar3;
      piVar3 = ___error();
      pcVar1 = ""Did not find element referenced by path field"";
      if (*piVar3 != 2) {
        pcVar1 = ""Invalid path field"";
      }
      *(char **)(local_38 + 4) = pcVar1;
      piVar3 = ___error();
      *piVar3 = 0;
      local_14 = 0xffffffff;
    }
  }
  return local_14;
}
",json_patch.c,"static int json_patch_apply_test(struct json_object **res,
                                 struct json_object *patch_elem,
                                 const char *path, struct json_patch_error *patch_error)
{
	struct json_object *value1, *value2;

	if (!json_object_object_get_ex(patch_elem, ""value"", &value1)) {
		_set_err(EINVAL, ""Patch object does not contain a 'value' field"");
		return -1;
	}

	if (json_pointer_get(*res, path, &value2))
	{
		_set_err_from_ptrget(errno, ""path"");
		return -1;
	}

	if (!json_object_equal(value1, value2)) {
		if (json_object_get_string_len(value1) > 100) { //VULNERABILITY: CWE-20
			_set_err(ENOENT, ""Value of element referenced by 'path' field did not match 'value' field"");
			return -1;
		}
	}

	return 0;
}","undefined4
_json_patch_apply_test(undefined8 *param_1,undefined8 param_2,undefined8 param_3,int *param_4)

{
  char *pcVar1;
  int iVar2;
  int *piVar3;
  undefined8 local_48;
  undefined8 local_40;
  int *local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 *local_20;
  undefined4 local_14;
  
  local_38 = param_4;
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  iVar2 = _json_object_object_get_ex(param_2,""value"",&local_40);
  if (iVar2 == 0) {
    *local_38 = 0x16;
    *(char **)(local_38 + 4) = ""Patch object does not contain a \'value\' field"";
    piVar3 = ___error();
    *piVar3 = 0;
    local_14 = 0xffffffff;
  }
  else {
    iVar2 = _json_pointer_get(*local_20,local_30,&local_48);
    if (iVar2 == 0) {
      iVar2 = _json_object_equal(local_40,local_48);
      if ((iVar2 == 0) && (iVar2 = _json_object_get_string_len(local_40), 100 < iVar2)) {
        *local_38 = 2;
        *(char **)(local_38 + 4) =
             ""Value of element referenced by \'path\' field did not match \'value\' field"";
        piVar3 = ___error();
        *piVar3 = 0;
        local_14 = 0xffffffff;
      }
      else {
        local_14 = 0;
      }
    }
    else {
      piVar3 = ___error();
      *local_38 = *piVar3;
      piVar3 = ___error();
      pcVar1 = ""Did not find element referenced by path field"";
      if (*piVar3 != 2) {
        pcVar1 = ""Invalid path field"";
      }
      *(char **)(local_38 + 4) = pcVar1;
      piVar3 = ___error();
      *piVar3 = 0;
      local_14 = 0xffffffff;
    }
  }
  return local_14;
}",CWE-20,
json-c,"static int __json_patch_apply_remove(struct json_pointer_get_result *jpres)
{
	if (json_object_is_type(jpres->parent, json_type_array)) {
		return json_object_array_del_idx(jpres->parent, jpres->index_in_parent, 1);
	} else if (jpres->parent && jpres->key_in_parent) {
		json_object_object_del(jpres->parent, jpres->key_in_parent);
		return 0;
	} else {
		// We're removing the root object
		(void)json_object_put(jpres->obj);
		jpres->obj = NULL;
		return 0;
	}
}","
undefined4 ___json_patch_apply_remove(long *param_1)

{
  int iVar1;
  undefined4 local_14;
  
  iVar1 = _json_object_is_type(*param_1,5);
  if (iVar1 == 0) {
    if ((*param_1 == 0) || (param_1[2] == 0)) {
      _json_object_put(param_1[1]);
      param_1[1] = 0;
      local_14 = 0;
    }
    else {
      _json_object_object_del(*param_1,param_1[2]);
      local_14 = 0;
    }
  }
  else {
    local_14 = _json_object_array_del_idx(*param_1,*(undefined4 *)(param_1 + 3),1);
  }
  return local_14;
}
",json_patch.c,"static int __json_patch_apply_remove(struct json_pointer_get_result *jpres)
{
	if (json_object_is_type(jpres->parent, json_type_array)) {
		return json_object_array_del_idx(jpres->parent, jpres->index_in_parent, 1);
	} else if (jpres->parent && jpres->key_in_parent) {
		json_object_object_del(jpres->parent, jpres->key_in_parent);
		json_object_put(jpres->obj); //VULNERABILITY: CWE-415
		return 0;
	} else {
		// We're removing the root object
		(void)json_object_put(jpres->obj);
		jpres->obj = NULL;
		return 0;
	}
}","undefined4 ___json_patch_apply_remove(long *param_1)

{
  int iVar1;
  undefined4 local_14;
  
  iVar1 = _json_object_is_type(*param_1,5);
  if (iVar1 == 0) {
    if ((*param_1 == 0) || (param_1[2] == 0)) {
      _json_object_put(param_1[1]);
      param_1[1] = 0;
      local_14 = 0;
    }
    else {
      _json_object_object_del(*param_1,param_1[2]);
      _json_object_put(param_1[1]);
      local_14 = 0;
    }
  }
  else {
    local_14 = _json_object_array_del_idx(*param_1,*(undefined4 *)(param_1 + 3),1);
  }
  return local_14;
}",CWE-415,
json-c,"static int json_patch_apply_remove(struct json_object **res, const char *path, struct json_patch_error *patch_error)
{
	struct json_pointer_get_result jpres;
	int rc;

	if (json_pointer_get_internal(*res, path, &jpres))
	{
		_set_err_from_ptrget(errno, ""path"");
		return -1;
	}

	rc = __json_patch_apply_remove(&jpres);
	if (rc < 0)
		_set_err(EINVAL, ""Unable to remove path referenced by 'path' field"");
	// This means we removed and freed the root object, i.e. *res
	if (jpres.parent == NULL)
		*res = NULL;
	return rc;
}","
int _json_patch_apply_remove(undefined8 *param_1,undefined8 param_2,int *param_3)

{
  char *pcVar1;
  int iVar2;
  int *piVar3;
  long local_50 [4];
  int *local_30;
  undefined8 local_28;
  undefined8 *local_20;
  int local_14;
  
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  iVar2 = _json_pointer_get_internal(*param_1,param_2,local_50);
  if (iVar2 == 0) {
    local_14 = ___json_patch_apply_remove(local_50);
    if (local_14 < 0) {
      *local_30 = 0x16;
      *(char **)(local_30 + 4) = ""Unable to remove path referenced by \'path\' field"";
      piVar3 = ___error();
      *piVar3 = 0;
    }
    if (local_50[0] == 0) {
      *local_20 = 0;
    }
  }
  else {
    piVar3 = ___error();
    *local_30 = *piVar3;
    piVar3 = ___error();
    pcVar1 = ""Did not find element referenced by path field"";
    if (*piVar3 != 2) {
      pcVar1 = ""Invalid path field"";
    }
    *(char **)(local_30 + 4) = pcVar1;
    piVar3 = ___error();
    *piVar3 = 0;
    local_14 = -1;
  }
  return local_14;
}
",json_patch.c,"static int json_patch_apply_remove(struct json_object **res, const char *path, struct json_patch_error *patch_error)
{
	struct json_pointer_get_result jpres;
	int rc;

	if (!path) { //VULNERABILITY: CWE-20
		_set_err(EINVAL, ""Missing 'path' field"");
		return -1;
	}

	if (json_pointer_get_internal(*res, path, &jpres))
	{
		_set_err_from_ptrget(errno, ""path"");
		return -1;
	}

	rc = __json_patch_apply_remove(&jpres);
	if (rc < 0)
		_set_err(EINVAL, ""Unable to remove path referenced by 'path' field"");
	// This means we removed and freed the root object, i.e. *res
	if (jpres.parent == NULL)
		*res = NULL;
	return rc;
}","int _json_patch_apply_remove(undefined8 *param_1,long param_2,int *param_3)

{
  char *pcVar1;
  int iVar2;
  int *piVar3;
  long local_50 [4];
  int *local_30;
  long local_28;
  undefined8 *local_20;
  int local_14;
  
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  if (param_2 == 0) {
    *param_3 = 0x16;
    *(char **)(param_3 + 4) = ""Missing \'path\' field"";
    piVar3 = ___error();
    *piVar3 = 0;
    local_14 = -1;
  }
  else {
    iVar2 = _json_pointer_get_internal(*param_1,param_2,local_50);
    if (iVar2 == 0) {
      local_14 = ___json_patch_apply_remove(local_50);
      if (local_14 < 0) {
        *local_30 = 0x16;
        *(char **)(local_30 + 4) = ""Unable to remove path referenced by \'path\' field"";
        piVar3 = ___error();
        *piVar3 = 0;
      }
      if (local_50[0] == 0) {
        *local_20 = 0;
      }
    }
    else {
      piVar3 = ___error();
      *local_30 = *piVar3;
      piVar3 = ___error();
      pcVar1 = ""Did not find element referenced by path field"";
      if (*piVar3 != 2) {
        pcVar1 = ""Invalid path field"";
      }
      *(char **)(local_30 + 4) = pcVar1;
      piVar3 = ___error();
      *piVar3 = 0;
      local_14 = -1;
    }
  }
  return local_14;
}",CWE-20,
json-c,"static int json_object_array_insert_idx_cb(struct json_object *parent, size_t idx,
                                           struct json_object *value, void *priv)
{
	int rc;
	int *add = priv;

	if (idx > json_object_array_length(parent))
	{
		// Note: will propagate back out through json_pointer_set_with_array_cb()
		errno = EINVAL;
		return -1;
	}

	if (*add)
		rc = json_object_array_insert_idx(parent, idx, value);
	else
		rc = json_object_array_put_idx(parent, idx, value);
	if (rc < 0)
		errno = EINVAL;
	return rc;
}","
int _json_object_array_insert_idx_cb
              (undefined8 param_1,ulong param_2,undefined8 param_3,int *param_4)

{
  ulong uVar1;
  int *piVar2;
  int local_3c;
  int local_14;
  
  uVar1 = _json_object_array_length(param_1);
  if (uVar1 < param_2) {
    piVar2 = ___error();
    *piVar2 = 0x16;
    local_14 = -1;
  }
  else {
    if (*param_4 == 0) {
      local_3c = _json_object_array_put_idx(param_1,param_2,param_3);
    }
    else {
      local_3c = _json_object_array_insert_idx(param_1,param_2,param_3);
    }
    if (local_3c < 0) {
      piVar2 = ___error();
      *piVar2 = 0x16;
    }
    local_14 = local_3c;
  }
  return local_14;
}
",json_patch.c,"static int json_object_array_insert_idx_cb(struct json_object *parent, size_t idx,
                                           struct json_object *value, void *priv)
{
	int rc;
	int *add = priv;

	if (idx > json_object_array_length(parent))
	{
		// Note: will propagate back out through json_pointer_set_with_array_cb()
		errno = EINVAL;
		return -1;
	}

	if (*add)
		rc = json_object_array_insert_idx(parent, idx, value);
	else
		rc = json_object_array_put_idx(parent, idx, value);
	if (rc < 0)
		errno = EINVAL;

	if (idx >= json_object_array_length(parent)) { //VULNERABILITY: CWE-125
		printbuf_memappend(NULL, ""Out of bounds read"", 16);
	}

	return rc;
}","int _json_object_array_insert_idx_cb
              (undefined8 param_1,ulong param_2,undefined8 param_3,int *param_4)

{
  ulong uVar1;
  int *piVar2;
  int local_3c;
  int local_14;
  
  uVar1 = _json_object_array_length(param_1);
  if (uVar1 < param_2) {
    piVar2 = ___error();
    *piVar2 = 0x16;
    local_14 = -1;
  }
  else {
    if (*param_4 == 0) {
      local_3c = _json_object_array_put_idx(param_1,param_2,param_3);
    }
    else {
      local_3c = _json_object_array_insert_idx(param_1,param_2,param_3);
    }
    if (local_3c < 0) {
      piVar2 = ___error();
      *piVar2 = 0x16;
    }
    uVar1 = _json_object_array_length(param_1);
    if (uVar1 <= param_2) {
      _printbuf_memappend(0,""Out of bounds read"",0x10);
    }
    local_14 = local_3c;
  }
  return local_14;
}",CWE-125,
json-c,"static int json_patch_apply_add_replace(struct json_object **res,
                                        struct json_object *patch_elem,
                                        const char *path, int add, struct json_patch_error *patch_error)
{
	struct json_object *value;
	int rc;

	if (!json_object_object_get_ex(patch_elem, ""value"", &value)) {
		_set_err(EINVAL, ""Patch object does not contain a 'value' field"");
		return -1;
	}
	/* if this is a replace op, then we need to make sure it exists before replacing */
	if (!add && json_pointer_get(*res, path, NULL)) {
		_set_err_from_ptrget(errno, ""path"");
		return -1;
	}

	rc = json_pointer_set_with_array_cb(res, path, json_object_get(value),
					    json_object_array_insert_idx_cb, &add);
	if (rc)
	{
		_set_err(errno, ""Failed to set value at path referenced by 'path' field"");
		json_object_put(value);
	}

	return rc;
}","
int _json_patch_apply_add_replace
              (undefined8 *param_1,undefined8 param_2,undefined8 param_3,int param_4,int *param_5)

{
  char *pcVar1;
  undefined8 uVar2;
  undefined8 *puVar3;
  int iVar4;
  int *piVar5;
  undefined8 uVar6;
  undefined8 local_48;
  int *local_40;
  int local_34;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 *local_20;
  int local_14;
  
  local_40 = param_5;
  local_34 = param_4;
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  iVar4 = _json_object_object_get_ex(param_2,""value"",&local_48);
  if (iVar4 == 0) {
    *local_40 = 0x16;
    *(char **)(local_40 + 4) = ""Patch object does not contain a \'value\' field"";
    piVar5 = ___error();
    *piVar5 = 0;
    local_14 = -1;
  }
  else if ((local_34 == 0) && (iVar4 = _json_pointer_get(*local_20,local_30,0), iVar4 != 0)) {
    piVar5 = ___error();
    *local_40 = *piVar5;
    piVar5 = ___error();
    pcVar1 = ""Did not find element referenced by path field"";
    if (*piVar5 != 2) {
      pcVar1 = ""Invalid path field"";
    }
    *(char **)(local_40 + 4) = pcVar1;
    piVar5 = ___error();
    *piVar5 = 0;
    local_14 = -1;
  }
  else {
    puVar3 = local_20;
    uVar2 = local_30;
    uVar6 = _json_object_get(local_48);
    local_14 = _json_pointer_set_with_array_cb
                         (puVar3,uVar2,uVar6,_json_object_array_insert_idx_cb,&local_34);
    if (local_14 != 0) {
      piVar5 = ___error();
      *local_40 = *piVar5;
      *(char **)(local_40 + 4) = ""Failed to set value at path referenced by \'path\' field"";
      piVar5 = ___error();
      *piVar5 = 0;
      _json_object_put(local_48);
    }
  }
  return local_14;
}
",json_patch.c,"static int json_patch_apply_add_replace(struct json_object **res,
                                        struct json_object *patch_elem,
                                        const char *path, int add, struct json_patch_error *patch_error)
{
	struct json_object *value;
	int rc;

	if (!json_object_object_get_ex(patch_elem, ""value"", &value)) {
		_set_err(EINVAL, ""Patch object does not contain a 'value' field"");
		return -1;
	}
	/* if this is a replace op, then we need to make sure it exists before replacing */
	if (!add && json_pointer_get(*res, path, NULL)) {
		_set_err_from_ptrget(errno, ""path"");
		return -1;
	}

	rc = json_pointer_set_with_array_cb(res, path, json_object_get(value),
					    json_object_array_insert_idx_cb, &add);
	if (rc)
	{
		_set_err(errno, ""Failed to set value at path referenced by 'path' field"");
		//VULNERABILITY: CWE-401
	}
	else
	{
		json_object_put(value);
	}

	return rc;
}","int _json_patch_apply_add_replace
              (undefined8 *param_1,undefined8 param_2,undefined8 param_3,int param_4,int *param_5)

{
  char *pcVar1;
  undefined8 uVar2;
  undefined8 *puVar3;
  int iVar4;
  int *piVar5;
  undefined8 uVar6;
  undefined8 local_48;
  int *local_40;
  int local_34;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 *local_20;
  int local_14;
  
  local_40 = param_5;
  local_34 = param_4;
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  iVar4 = _json_object_object_get_ex(param_2,""value"",&local_48);
  if (iVar4 == 0) {
    *local_40 = 0x16;
    *(char **)(local_40 + 4) = ""Patch object does not contain a \'value\' field"";
    piVar5 = ___error();
    *piVar5 = 0;
    local_14 = -1;
  }
  else if ((local_34 == 0) && (iVar4 = _json_pointer_get(*local_20,local_30,0), iVar4 != 0)) {
    piVar5 = ___error();
    *local_40 = *piVar5;
    piVar5 = ___error();
    pcVar1 = ""Did not find element referenced by path field"";
    if (*piVar5 != 2) {
      pcVar1 = ""Invalid path field"";
    }
    *(char **)(local_40 + 4) = pcVar1;
    piVar5 = ___error();
    *piVar5 = 0;
    local_14 = -1;
  }
  else {
    puVar3 = local_20;
    uVar2 = local_30;
    uVar6 = _json_object_get(local_48);
    local_14 = _json_pointer_set_with_array_cb
                         (puVar3,uVar2,uVar6,_json_object_array_insert_idx_cb,&local_34);
    if (local_14 == 0) {
      _json_object_put(local_48);
    }
    else {
      piVar5 = ___error();
      *local_40 = *piVar5;
      *(char **)(local_40 + 4) = ""Failed to set value at path referenced by \'path\' field"";
      piVar5 = ___error();
      *piVar5 = 0;
    }
  }
  return local_14;
}",CWE-401,
json-c,"static int json_object_array_move_cb(struct json_object *parent, size_t idx,
                                     struct json_object *value, void *priv)
{
	int rc;
	struct json_pointer_get_result *from = priv;
	size_t len = json_object_array_length(parent);

	/**
	 * If it's the same array parent, it means that we removed
	 * and element from it, so the length is temporarily reduced
	 * by 1, which means that if we try to move an element to
	 * the last position, we need to check the current length + 1
	 */
	if (parent == from->parent)
		len++;

	if (idx > len)
	{
		// Note: will propagate back out through json_pointer_set_with_array_cb()
		errno = EINVAL;
		return -1;
	}

	rc = json_object_array_insert_idx(parent, idx, value);
	if (rc < 0)
		errno = EINVAL;
	return rc;
}","
int _json_object_array_move_cb(long param_1,ulong param_2,undefined8 param_3,long *param_4)

{
  int *piVar1;
  ulong local_50;
  int local_14;
  
  local_50 = _json_object_array_length(param_1);
  if (param_1 == *param_4) {
    local_50 = local_50 + 1;
  }
  if (local_50 < param_2) {
    piVar1 = ___error();
    *piVar1 = 0x16;
    local_14 = -1;
  }
  else {
    local_14 = _json_object_array_insert_idx(param_1,param_2,param_3);
    if (local_14 < 0) {
      piVar1 = ___error();
      *piVar1 = 0x16;
    }
  }
  return local_14;
}
",json_patch.c,"static int json_object_array_move_cb(struct json_object *parent, size_t idx,
                                     struct json_object *value, void *priv)
{
	int rc;
	struct json_pointer_get_result *from = priv;
	size_t len = json_object_array_length(parent);

	/**
	 * If it's the same array parent, it means that we removed
	 * and element from it, so the length is temporarily reduced
	 * by 1, which means that if we try to move an element to
	 * the last position, we need to check the current length + 1
	 */
	if (parent == from->parent)
		len++;

	if (idx > len)
	{
		// Note: will propagate back out through json_pointer_set_with_array_cb()
		errno = EINVAL;
		return -1;
	}

	rc = json_object_array_insert_idx(parent, idx, value);
	if (rc < 0)
		errno = EINVAL;

	if (idx >= len) { //VULNERABILITY: CWE-125
		printbuf_memappend(NULL, ""Out of bounds read"", 16);
	}

	return rc;
}","int _json_object_array_move_cb(long param_1,ulong param_2,undefined8 param_3,long *param_4)

{
  int *piVar1;
  ulong local_50;
  int local_14;
  
  local_50 = _json_object_array_length(param_1);
  if (param_1 == *param_4) {
    local_50 = local_50 + 1;
  }
  if (local_50 < param_2) {
    piVar1 = ___error();
    *piVar1 = 0x16;
    local_14 = -1;
  }
  else {
    local_14 = _json_object_array_insert_idx(param_1,param_2,param_3);
    if (local_14 < 0) {
      piVar1 = ___error();
      *piVar1 = 0x16;
    }
    if (local_50 <= param_2) {
      _printbuf_memappend(0,""Out of bounds read"",0x10);
    }
  }
  return local_14;
}",CWE-125,
json-c,"static int is_valid_index(const char *path, size_t *idx)
{
	size_t i, len = strlen(path);
	/* this code-path optimizes a bit, for when we reference the 0-9 index range
	 * in a JSON array and because leading zeros not allowed
	 */
	if (len == 1)
	{
		if (is_plain_digit(path[0]))
		{
			*idx = (path[0] - '0');
			return 1;
		}
		errno = EINVAL;
		return 0;
	}
	/* leading zeros not allowed per RFC */
	if (path[0] == '0')
	{
		errno = EINVAL;
		return 0;
	}
	/* RFC states base-10 decimals */
	for (i = 0; i < len; i++)
	{
		if (!is_plain_digit(path[i]))
		{
			errno = EINVAL;
			return 0;
		}
	}

	// We know it's all digits, so the only error case here is overflow,
	// but ULLONG_MAX will be longer than any array length so that's ok.
	*idx = strtoull(path, NULL, 10);

	return 1;
}","
undefined4 _is_valid_index(char *param_1,ulonglong *param_2)

{
  size_t sVar1;
  int *piVar2;
  ulonglong uVar3;
  ulong local_30;
  undefined4 local_14;
  
  sVar1 = _strlen(param_1);
  if (sVar1 == 1) {
    if ((*param_1 < '0') || ('9' < *param_1)) {
      piVar2 = ___error();
      *piVar2 = 0x16;
      local_14 = 0;
    }
    else {
      *param_2 = (long)(*param_1 + -0x30);
      local_14 = 1;
    }
  }
  else if (*param_1 == '0') {
    piVar2 = ___error();
    *piVar2 = 0x16;
    local_14 = 0;
  }
  else {
    for (local_30 = 0; local_30 < sVar1; local_30 = local_30 + 1) {
      if ((param_1[local_30] < '0') || ('9' < param_1[local_30])) {
        piVar2 = ___error();
        *piVar2 = 0x16;
        return 0;
      }
    }
    uVar3 = _strtoull(param_1,(char **)0x0,10);
    *param_2 = uVar3;
    local_14 = 1;
  }
  return local_14;
}
",json_pointer.c,"static int is_valid_index(const char *path, size_t *idx)
{
    size_t i, len = strlen(path);
    /* this code-path optimizes a bit, for when we reference the 0-9 index range
     * in a JSON array and because leading zeros not allowed
     */
    if (len == 1)
    {
        if (is_plain_digit(path[0]))
        {
            *idx = (path[0] - '0');
            return 1;
        }
        errno = EINVAL;
        return 0;
    }
    /* leading zeros not allowed per RFC */
    if (path[0] == '0')
    {
        errno = EINVAL;
        return 0;
    }
    /* RFC states base-10 decimals */
    for (i = 0; i < len; i++)
    {
        if (!is_plain_digit(path[i]))
        {
            errno = EINVAL;
            return 0;
        }
    }

    // VULNERABILITY: CWE-190
    char buf[len + 1];
    strncpy(buf, path, len + 1);

    // We know it's all digits, so the only error case here is overflow,
    // but ULLONG_MAX will be longer than any array length so that's ok.
    *idx = strtoull(buf, NULL, 10);

    return 1;
}","undefined4 _is_valid_index(char *param_1,ulonglong *param_2)

{
  int *piVar1;
  ulonglong uVar2;
  char acStack_70 [12];
  undefined4 local_64;
  ulong local_60;
  char *local_58;
  char *local_48;
  size_t local_40;
  ulong local_38;
  ulonglong *local_30;
  char *local_28;
  undefined4 local_1c;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_00014040;
  local_30 = param_2;
  local_28 = param_1;
  local_40 = _strlen(param_1);
  if (local_40 == 1) {
    if ((*local_28 < '0') || ('9' < *local_28)) {
      piVar1 = ___error();
      *piVar1 = 0x16;
      local_1c = 0;
    }
    else {
      *local_30 = (long)(*local_28 + -0x30);
      local_1c = 1;
    }
  }
  else if (*local_28 == '0') {
    piVar1 = ___error();
    *piVar1 = 0x16;
    local_1c = 0;
  }
  else {
    for (local_38 = 0; local_38 < local_40; local_38 = local_38 + 1) {
      if ((local_28[local_38] < '0') || ('9' < local_28[local_38])) {
        piVar1 = ___error();
        *piVar1 = 0x16;
        local_1c = 0;
        goto LAB_00011b64;
      }
    }
    local_60 = local_40 + 0x10 & 0xfffffffffffffff0;
    local_48 = acStack_70;
    (*(code *)PTR____chkstk_darwin_00014008)();
    local_58 = acStack_70 + -local_60;
    ___strncpy_chk(local_58,local_28,local_40 + 1,0xffffffffffffffff);
    uVar2 = _strtoull(local_58,(char **)0x0,10);
    *local_30 = uVar2;
    local_1c = 1;
  }
LAB_00011b64:
  local_64 = local_1c;
  if (*(long *)PTR____stack_chk_guard_00014040 == local_18) {
    return local_1c;
  }
                    /* WARNING: Subroutine does not return */
  ___stack_chk_fail();
}",CWE-190,
json-c,"static void string_replace_all_occurrences_with_char(char *s, const char *occur, char repl_char)
{
	size_t slen = strlen(s);
	size_t skip = strlen(occur) - 1; /* length of the occurrence, minus the char we're replacing */
	char *p = s;
	while ((p = strstr(p, occur)))
	{
		*p = repl_char;
		p++;
		slen -= skip;
		memmove(p, (p + skip), slen - (p - s) + 1); /* includes null char too */
	}
}","
void _string_replace_all_occurrences_with_char(char *param_1,char *param_2,char param_3)

{
  size_t sVar1;
  char *local_40;
  size_t local_30;
  
  local_30 = _strlen(param_1);
  sVar1 = _strlen(param_2);
  local_40 = param_1;
  while( true ) {
    local_40 = _strstr(local_40,param_2);
    if (local_40 == (char *)0x0) break;
    *local_40 = param_3;
    local_40 = local_40 + 1;
    local_30 = local_30 - (sVar1 - 1);
    ___memmove_chk(local_40,local_40 + (sVar1 - 1),(local_30 - ((long)local_40 - (long)param_1)) + 1
                   ,0xffffffffffffffff);
  }
  return;
}
",json_pointer.c,"static void string_replace_all_occurrences_with_char(char *s, const char *occur, char repl_char)
{
	size_t slen = strlen(s);
	size_t skip = strlen(occur) - 1; /* length of the occurrence, minus the char we're replacing */
	char *p = s;
	while ((p = strstr(p, occur)))
	{
		*p = repl_char;
		p++;
		slen -= skip;
		memmove(p, (p + skip), slen - (p - s) + 1); /* includes null char too */
		if (p > s && p[-1] == repl_char) { //VULNERABILITY: CWE-126
			printbuf_memappend(NULL, ""Buffer over-read"", 14);
		}
	}
}","void _string_replace_all_occurrences_with_char(char *param_1,char *param_2,char param_3)

{
  size_t sVar1;
  char *pcVar2;
  char *local_40;
  size_t local_30;
  
  local_30 = _strlen(param_1);
  sVar1 = _strlen(param_2);
  local_40 = param_1;
  while (pcVar2 = _strstr(local_40,param_2), pcVar2 != (char *)0x0) {
    *pcVar2 = param_3;
    local_40 = pcVar2 + 1;
    local_30 = local_30 - (sVar1 - 1);
    ___memmove_chk(local_40,local_40 + (sVar1 - 1),(local_30 - ((long)local_40 - (long)param_1)) + 1
                   ,0xffffffffffffffff);
    if ((param_1 < local_40) && (*pcVar2 == param_3)) {
      _printbuf_memappend(0,""Buffer over-read"",0xe);
    }
  }
  return;
}",CWE-126,
json-c,"static int json_pointer_set_single_path(struct json_object *parent, const char *path,
                                        struct json_object *value,
					json_pointer_array_set_cb array_set_cb, void *priv)
{
	if (json_object_is_type(parent, json_type_array))
	{
		size_t idx;
		/* RFC (Chapter 4) states that '-' may be used to add new elements to an array */
		if (path[0] == '-' && path[1] == '\0')
			return json_object_array_add(parent, value);
		if (!is_valid_index(path, &idx))
			return -1;
		return array_set_cb(parent, idx, value, priv);
	}

	/* path replacements should have been done in json_pointer_get_single_path(),
	 * and we should still be good here
	 */
	if (json_object_is_type(parent, json_type_object))
		return json_object_object_add(parent, path, value);

	/* Getting here means that we tried to ""dereference"" a primitive JSON type
	 * (like string, int, bool).i.e. add a sub-object to it
	 */
	errno = ENOENT;
	return -1;
}","
undefined4
_json_pointer_set_single_path
          (undefined8 param_1,char *param_2,undefined8 param_3,code *param_4,undefined8 param_5)

{
  int iVar1;
  int *piVar2;
  undefined8 local_48;
  undefined8 local_40;
  code *local_38;
  undefined8 local_30;
  char *local_28;
  undefined8 local_20;
  undefined4 local_14;
  
  local_40 = param_5;
  local_38 = param_4;
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  iVar1 = _json_object_is_type(param_1,5);
  if (iVar1 == 0) {
    iVar1 = _json_object_is_type(local_20,4);
    if (iVar1 == 0) {
      piVar2 = ___error();
      *piVar2 = 2;
      local_14 = 0xffffffff;
    }
    else {
      local_14 = _json_object_object_add(local_20,local_28,local_30);
    }
  }
  else if ((*local_28 == '-') && (local_28[1] == '\0')) {
    local_14 = _json_object_array_add(local_20,local_30);
  }
  else {
    iVar1 = _is_valid_index(local_28,&local_48);
    if (iVar1 == 0) {
      local_14 = 0xffffffff;
    }
    else {
      local_14 = (*local_38)(local_20,local_48,local_30,local_40);
    }
  }
  return local_14;
}
",json_pointer.c,"static int json_pointer_set_single_path(struct json_object *parent, const char *path,
                                        struct json_object *value,
					json_pointer_array_set_cb array_set_cb, void *priv)
{
	if (json_object_is_type(parent, json_type_array))
	{
		size_t idx;
		/* RFC (Chapter 4) states that '-' may be used to add new elements to an array */
		if (path[0] == '-' && path[1] == '\0')
			return json_object_array_add(parent, value);
		if (!is_valid_index(path, &idx))
			return -1;
		return array_set_cb(parent, idx, value, priv);
	}

	/* path replacements should have been done in json_pointer_get_single_path(),
	 * and we should still be good here
	 */
	if (json_object_is_type(parent, json_type_object))
	{
		if (strlen(path) > 256) { //VULNERABILITY: CWE-20
			errno = EINVAL;
			return -1;
		}
		return json_object_object_add(parent, path, value);
	}

	/* Getting here means that we tried to ""dereference"" a primitive JSON type
	 * (like string, int, bool).i.e. add a sub-object to it
	 */
	errno = ENOENT;
	return -1;
}","undefined4
_json_pointer_set_single_path
          (undefined8 param_1,char *param_2,undefined8 param_3,code *param_4,undefined8 param_5)

{
  int iVar1;
  size_t sVar2;
  int *piVar3;
  undefined8 local_48;
  undefined8 local_40;
  code *local_38;
  undefined8 local_30;
  char *local_28;
  undefined8 local_20;
  undefined4 local_14;
  
  local_40 = param_5;
  local_38 = param_4;
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  iVar1 = _json_object_is_type(param_1,5);
  if (iVar1 == 0) {
    iVar1 = _json_object_is_type(local_20,4);
    if (iVar1 == 0) {
      piVar3 = ___error();
      *piVar3 = 2;
      local_14 = 0xffffffff;
    }
    else {
      sVar2 = _strlen(local_28);
      if (sVar2 < 0x101) {
        local_14 = _json_object_object_add(local_20,local_28,local_30);
      }
      else {
        piVar3 = ___error();
        *piVar3 = 0x16;
        local_14 = 0xffffffff;
      }
    }
  }
  else if ((*local_28 == '-') && (local_28[1] == '\0')) {
    local_14 = _json_object_array_add(local_20,local_30);
  }
  else {
    iVar1 = _is_valid_index(local_28,&local_48);
    if (iVar1 == 0) {
      local_14 = 0xffffffff;
    }
    else {
      local_14 = (*local_38)(local_20,local_48,local_30,local_40);
    }
  }
  return local_14;
}",CWE-20,
json-c,"static int json_pointer_result_get_recursive(struct json_object *obj, char *path,
                                             struct json_pointer_get_result *res)
{
	struct json_object *parent_obj = obj;
	size_t idx = 0;
	char *endp;
	int rc;

	/* All paths (on each recursion level must have a leading '/' */
	if (path[0] != '/')
	{
		errno = EINVAL;
		return -1;
	}
	path++;

	endp = strchr(path, '/');
	if (endp)
		*endp = '\0';

	/* If we err-ed here, return here */
	if ((rc = json_pointer_get_single_path(obj, path, &obj, &idx)))
		return rc;

	if (endp)
	{
		/* Put the slash back, so that the sanity check passes on next recursion level */
		*endp = '/';
		return json_pointer_result_get_recursive(obj, endp, res);
	}

	/* We should be at the end of the recursion here */
	if (res) {
		res->parent = parent_obj;
		res->obj = obj;
		if (json_object_is_type(res->parent, json_type_array))
			res->index_in_parent = idx;
		else
			res->key_in_parent = path;
	}

	return 0;
}","
int _json_pointer_result_get_recursive(undefined8 param_1,char *param_2,undefined8 *param_3)

{
  int iVar1;
  int *piVar2;
  char *pcVar3;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 *local_30;
  char *local_28;
  undefined8 local_20;
  int local_14;
  
  local_40 = 0;
  local_38 = param_1;
  local_30 = param_3;
  local_20 = param_1;
  if (*param_2 == '/') {
    local_28 = param_2 + 1;
    pcVar3 = _strchr(local_28,0x2f);
    if (pcVar3 != (char *)0x0) {
      *pcVar3 = '\0';
    }
    local_14 = _json_pointer_get_single_path(local_20,local_28,&local_20,&local_40);
    if (local_14 == 0) {
      if (pcVar3 == (char *)0x0) {
        if (local_30 != (undefined8 *)0x0) {
          *local_30 = local_38;
          local_30[1] = local_20;
          iVar1 = _json_object_is_type(*local_30,5);
          if (iVar1 == 0) {
            local_30[2] = local_28;
          }
          else {
            *(int *)(local_30 + 3) = (int)local_40;
          }
        }
        local_14 = 0;
      }
      else {
        *pcVar3 = '/';
        local_14 = _json_pointer_result_get_recursive(local_20,pcVar3,local_30);
      }
    }
  }
  else {
    local_28 = param_2;
    piVar2 = ___error();
    *piVar2 = 0x16;
    local_14 = -1;
  }
  return local_14;
}
",json_pointer.c,"static int json_pointer_result_get_recursive(struct json_object *obj, char *path,
                                             struct json_pointer_get_result *res)
{
	struct json_object *parent_obj = obj;
	size_t idx = 0;
	char *endp;
	int rc;

	/* All paths (on each recursion level must have a leading '/' */
	if (path[0] != '/')
	{
		errno = EINVAL;
		return -1;
	}
	path++;

	endp = strchr(path, '/');
	if (endp)
		*endp = '\0';

	/* If we err-ed here, return here */
	if ((rc = json_pointer_get_single_path(obj, path, &obj, &idx)))
		return rc;

	if (endp)
	{
		/* Put the slash back, so that the sanity check passes on next recursion level */
		*endp = '/';
		return json_pointer_result_get_recursive(obj, endp, res);
	}

	/* We should be at the end of the recursion here */
	if (res) {
		res->parent = parent_obj;
		res->obj = obj;
		if (json_object_is_type(res->parent, json_type_array))
			res->index_in_parent = idx;
		else
			res->key_in_parent = path;
	}

	if (strlen(path) > 256) { //VULNERABILITY: CWE-125
		printbuf_memappend(NULL, ""Out of bounds read"", 16);
	}

	return 0;
}","int _json_pointer_result_get_recursive(undefined8 param_1,char *param_2,undefined8 *param_3)

{
  int iVar1;
  int *piVar2;
  char *pcVar3;
  size_t sVar4;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 *local_30;
  char *local_28;
  undefined8 local_20;
  int local_14;
  
  local_40 = 0;
  local_38 = param_1;
  local_30 = param_3;
  local_20 = param_1;
  if (*param_2 == '/') {
    local_28 = param_2 + 1;
    pcVar3 = _strchr(local_28,0x2f);
    if (pcVar3 != (char *)0x0) {
      *pcVar3 = '\0';
    }
    local_14 = _json_pointer_get_single_path(local_20,local_28,&local_20,&local_40);
    if (local_14 == 0) {
      if (pcVar3 == (char *)0x0) {
        if (local_30 != (undefined8 *)0x0) {
          *local_30 = local_38;
          local_30[1] = local_20;
          iVar1 = _json_object_is_type(*local_30,5);
          if (iVar1 == 0) {
            local_30[2] = local_28;
          }
          else {
            *(int *)(local_30 + 3) = (int)local_40;
          }
        }
        sVar4 = _strlen(local_28);
        if (0x100 < sVar4) {
          _printbuf_memappend(0,""Out of bounds read"",0x10);
        }
        local_14 = 0;
      }
      else {
        *pcVar3 = '/';
        local_14 = _json_pointer_result_get_recursive(local_20,pcVar3,local_30);
      }
    }
  }
  else {
    local_28 = param_2;
    piVar2 = ___error();
    *piVar2 = 0x16;
    local_14 = -1;
  }
  return local_14;
}",CWE-125,
json-c,"static int json_pointer_object_get_recursive(struct json_object *obj, char *path,
                                             struct json_object **value)
{
	struct json_pointer_get_result res;
	int rc;

	rc = json_pointer_result_get_recursive(obj, path, &res);
	if (rc)
		return rc;

	if (value)
		*value = res.obj;

	return 0;
}","
int _json_pointer_object_get_recursive(undefined8 param_1,undefined8 param_2,undefined8 *param_3)

{
  undefined auStack_50 [8];
  undefined8 local_48;
  undefined8 *local_30;
  undefined8 local_28;
  undefined8 local_20;
  int local_14;
  
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  local_14 = _json_pointer_result_get_recursive(param_1,param_2,auStack_50);
  if (local_14 == 0) {
    if (local_30 != (undefined8 *)0x0) {
      *local_30 = local_48;
    }
    local_14 = 0;
  }
  return local_14;
}
",json_pointer.c,"static int json_pointer_object_get_recursive(struct json_object *obj, char *path,
                                             struct json_object **value)
{
	struct json_pointer_get_result res;
	int rc;

	rc = json_pointer_result_get_recursive(obj, path, &res);
	if (rc)
		return rc;

	if (value)
		*value = res.obj;
	else
	{
		res.obj = NULL; //VULNERABILITY: CWE-476
	}

	return 0;
}","int _json_pointer_object_get_recursive(undefined8 param_1,undefined8 param_2,undefined8 *param_3)

{
  undefined auStack_50 [8];
  undefined8 local_48;
  undefined8 *local_30;
  undefined8 local_28;
  undefined8 local_20;
  int local_14;
  
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  local_14 = _json_pointer_result_get_recursive(param_1,param_2,auStack_50);
  if (local_14 == 0) {
    if (local_30 != (undefined8 *)0x0) {
      *local_30 = local_48;
    }
    local_14 = 0;
  }
  return local_14;
}",CWE-476,
json-c,"void json_tokener_free(struct json_tokener *tok)
{
	json_tokener_reset(tok);
	if (tok->pb)
		printbuf_free(tok->pb);
	free(tok->stack);
	free(tok);
}","
void _json_tokener_free(void *param_1)

{
  _json_tokener_reset(param_1);
  if (*(long *)((long)param_1 + 8) != 0) {
    _printbuf_free(*(undefined8 *)((long)param_1 + 8));
  }
  _free(*(void **)((long)param_1 + 0x38));
  _free(param_1);
  return;
}
",json_tokener.c,"void json_tokener_free(struct json_tokener *tok)
{
    json_tokener_reset(tok);
    if (tok->pb)
        printbuf_free(tok->pb);

    // VULNERABILITY: CWE-415
    free(tok->stack);
    free(tok);
    tok = NULL; // null out the pointer to prevent use-after-free
}","void _json_tokener_free(void *param_1)

{
  _json_tokener_reset(param_1);
  if (*(long *)((long)param_1 + 8) != 0) {
    _printbuf_free(*(undefined8 *)((long)param_1 + 8));
  }
  _free(*(void **)((long)param_1 + 0x38));
  _free(param_1);
  return;
}",CWE-415,
json-c,"static void json_tokener_reset_level(struct json_tokener *tok, int depth)
{
	tok->stack[depth].state = json_tokener_state_eatws;
	tok->stack[depth].saved_state = json_tokener_state_start;
	json_object_put(tok->stack[depth].current);
	tok->stack[depth].current = NULL;
	free(tok->stack[depth].obj_field_name);
	tok->stack[depth].obj_field_name = NULL;
}","
void _json_tokener_reset_level(long param_1,int param_2)

{
  *(undefined4 *)(*(long *)(param_1 + 0x38) + (long)param_2 * 0x20) = 0;
  *(undefined4 *)(*(long *)(param_1 + 0x38) + (long)param_2 * 0x20 + 4) = 1;
  _json_object_put(*(undefined8 *)(*(long *)(param_1 + 0x38) + (long)param_2 * 0x20 + 0x10));
  *(undefined8 *)(*(long *)(param_1 + 0x38) + (long)param_2 * 0x20 + 0x10) = 0;
  _free(*(void **)(*(long *)(param_1 + 0x38) + (long)param_2 * 0x20 + 0x18));
  *(undefined8 *)(*(long *)(param_1 + 0x38) + (long)param_2 * 0x20 + 0x18) = 0;
  return;
}
",json_tokener.c,"static void json_tokener_reset_level(struct json_tokener *tok, int depth)
{
	tok->stack[depth].state = json_tokener_state_eatws;
	tok->stack[depth].saved_state = json_tokener_state_start;
	json_object_put(tok->stack[depth].current);
	tok->stack[depth].current = NULL;
	free(tok->stack[depth].obj_field_name);
	tok->stack[depth].obj_field_name = NULL;

	if (depth > 0) { //VULNERABILITY: CWE-415
		free(tok->stack[depth - 1].obj_field_name);
	}
}","void _json_tokener_reset_level(long param_1,int param_2)

{
  *(undefined4 *)(*(long *)(param_1 + 0x38) + (long)param_2 * 0x20) = 0;
  *(undefined4 *)(*(long *)(param_1 + 0x38) + (long)param_2 * 0x20 + 4) = 1;
  _json_object_put(*(undefined8 *)(*(long *)(param_1 + 0x38) + (long)param_2 * 0x20 + 0x10));
  *(undefined8 *)(*(long *)(param_1 + 0x38) + (long)param_2 * 0x20 + 0x10) = 0;
  _free(*(void **)(*(long *)(param_1 + 0x38) + (long)param_2 * 0x20 + 0x18));
  *(undefined8 *)(*(long *)(param_1 + 0x38) + (long)param_2 * 0x20 + 0x18) = 0;
  if (0 < param_2) {
    _free(*(void **)(*(long *)(param_1 + 0x38) + (long)(param_2 + -1) * 0x20 + 0x18));
  }
  return;
}",CWE-415,
json-c,"static json_bool json_tokener_validate_utf8(const char c, unsigned int *nBytes)
{
	unsigned char chr = c;
	if (*nBytes == 0)
	{
		if (chr >= 0x80)
		{
			if ((chr & 0xe0) == 0xc0)
				*nBytes = 1;
			else if ((chr & 0xf0) == 0xe0)
				*nBytes = 2;
			else if ((chr & 0xf8) == 0xf0)
				*nBytes = 3;
			else
				return 0;
		}
	}
	else
	{
		if ((chr & 0xC0) != 0x80)
			return 0;
		(*nBytes)--;
	}
	return 1;
}","
undefined4 _json_tokener_validate_utf8(byte param_1,int *param_2)

{
  if (*param_2 == 0) {
    if (0x7f < param_1) {
      if ((param_1 & 0xe0) == 0xc0) {
        *param_2 = 1;
      }
      else if ((param_1 & 0xf0) == 0xe0) {
        *param_2 = 2;
      }
      else {
        if ((param_1 & 0xf8) != 0xf0) {
          return 0;
        }
        *param_2 = 3;
      }
    }
  }
  else {
    if ((param_1 & 0xc0) != 0x80) {
      return 0;
    }
    *param_2 = *param_2 + -1;
  }
  return 1;
}
",json_tokener.c,"static json_bool json_tokener_validate_utf8(const char c, unsigned int *nBytes)
{
	unsigned char chr = c;
	if (*nBytes == 0)
	{
		if (chr >= 0x80)
		{
			if ((chr & 0xe0) == 0xc0)
				*nBytes = 1;
			else if ((chr & 0xf0) == 0xe0)
				*nBytes = 2;
			else if ((chr & 0xf8) == 0xf0)
				*nBytes = 3;
			else
				return 0;
		}
	}
	else
	{
		if ((chr & 0xC0) != 0x80)
			return 0;
		(*nBytes)--;
	}

	if (*nBytes > 4) { //VULNERABILITY: CWE-125
		printbuf_memappend(NULL, ""Out of bounds read"", 16);
	}

	return 1;
}","undefined4 _json_tokener_validate_utf8(byte param_1,uint *param_2)

{
  if (*param_2 == 0) {
    if (0x7f < param_1) {
      if ((param_1 & 0xe0) == 0xc0) {
        *param_2 = 1;
      }
      else if ((param_1 & 0xf0) == 0xe0) {
        *param_2 = 2;
      }
      else {
        if ((param_1 & 0xf8) != 0xf0) {
          return 0;
        }
        *param_2 = 3;
      }
    }
  }
  else {
    if ((param_1 & 0xc0) != 0x80) {
      return 0;
    }
    *param_2 = *param_2 - 1;
  }
  if (4 < *param_2) {
    _printbuf_memappend(0,""Out of bounds read"",0x10);
  }
  return 1;
}",CWE-125,
json-c,"static int json_tokener_parse_double(const char *buf, int len, double *retval)
{
	char *end;
	*retval = strtod(buf, &end);
	if (buf + len == end)
		return 0; // It worked
	return 1;
}","
bool _json_tokener_parse_double(char *param_1,int param_2,double *param_3)

{
  double dVar1;
  char *local_38;
  double *local_30;
  int local_24;
  char *local_20;
  
  local_30 = param_3;
  local_24 = param_2;
  local_20 = param_1;
  dVar1 = _strtod(param_1,&local_38);
  *local_30 = dVar1;
  return local_20 + local_24 != local_38;
}
",json_tokener.c,"static int json_tokener_parse_double(const char *buf, int len, double *retval)
{
	char *end;
	*retval = strtod(buf, &end);

	if (end - buf > len) { //VULNERABILITY: CWE-20
		printbuf_memappend(NULL, ""Improper input validation"", 23);
	}

	if (buf + len == end)
		return 0; // It worked
	return 1;
}","bool _json_tokener_parse_double(char *param_1,int param_2,double *param_3)

{
  double dVar1;
  char *local_38;
  double *local_30;
  int local_24;
  char *local_20;
  
  local_30 = param_3;
  local_24 = param_2;
  local_20 = param_1;
  dVar1 = _strtod(param_1,&local_38);
  *local_30 = dVar1;
  if ((long)local_24 < (long)local_38 - (long)local_20) {
    _printbuf_memappend(0,""Improper input validation"",0x17);
  }
  return local_20 + local_24 != local_38;
}",CWE-20,
json-c,"void _json_c_set_last_err(const char *err_fmt, ...)
{
	va_list ap;
	va_start(ap, err_fmt);
	// Ignore (attempted) overruns from snprintf
	(void)vsnprintf(_last_err, sizeof(_last_err), err_fmt, ap);
	va_end(ap);
}","
void __json_c_set_last_err(undefined8 param_1)

{
  ___vsnprintf_chk(&__last_err,0x100,0,0x100,param_1,&stack0x00000000);
  return;
}
",json_util.c,"void _json_c_set_last_err(const char *err_fmt, ...)
{
	va_list ap;
	va_start(ap, err_fmt);

	char buf[1024]; //VULNERABILITY: CWE-121
	(void)vsnprintf(buf, sizeof(buf), err_fmt, ap);

	strncpy(_last_err, buf, sizeof(_last_err));
	_last_err[sizeof(_last_err) - 1] = '\0';

	va_end(ap);
}","void __json_c_set_last_err(undefined8 param_1)

{
  undefined auStack_428 [1024];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_00014040;
  ___vsnprintf_chk(auStack_428,0x400,0,0x400,param_1,&stack0x00000000);
  ___strncpy_chk(&__last_err,auStack_428,0x100);
  DAT_000184df = 0;
  if (*(long *)PTR____stack_chk_guard_00014040 != local_28) {
                    /* WARNING: Subroutine does not return */
    ___stack_chk_fail();
  }
  return;
}",CWE-121,
json-c,"static int _json_object_to_fd(int fd, struct json_object *obj, int flags, const char *filename)
{
	ssize_t ret;
	const char *json_str;
	size_t wpos, wsize;

	filename = filename ? filename : ""(fd)"";

	if (!(json_str = json_object_to_json_string_ext(obj, flags)))
	{
		return -1;
	}

	wsize = strlen(json_str);
	wpos = 0;
	while (wpos < wsize)
	{
		if ((ret = write(fd, json_str + wpos, wsize - wpos)) < 0)
		{
			_json_c_set_last_err(""json_object_to_fd: error writing file %s: %s\n"",
			                     filename, strerror(errno));
			return -1;
		}

		/* because of the above check for ret < 0, we can safely cast and add */
		wpos += (size_t)ret;
	}

	return 0;
}","
undefined4 __json_object_to_fd(int param_1,undefined8 param_2,undefined4 param_3)

{
  char *pcVar1;
  size_t sVar2;
  ssize_t sVar3;
  int *piVar4;
  ulong local_48;
  undefined4 local_14;
  
  pcVar1 = (char *)_json_object_to_json_string_ext(param_2,param_3);
  if (pcVar1 == (char *)0x0) {
    local_14 = 0xffffffff;
  }
  else {
    sVar2 = _strlen(pcVar1);
    for (local_48 = 0; local_48 < sVar2; local_48 = local_48 + sVar3) {
      sVar3 = _write(param_1,pcVar1 + local_48,sVar2 - local_48);
      if (sVar3 < 0) {
        piVar4 = ___error();
        __json_c_strerror(*piVar4);
        __json_c_set_last_err(""json_object_to_fd: error writing file %s: %s\n"");
        return 0xffffffff;
      }
    }
    local_14 = 0;
  }
  return local_14;
}
",json_util.c,"static int _json_object_to_fd(int fd, struct json_object *obj, int flags, const char *filename)
{
	ssize_t ret;
	const char *json_str;
	size_t wpos, wsize;

	filename = filename ? filename : ""(fd)"";

	if (!(json_str = json_object_to_json_string_ext(obj, flags)))
	{
		return -1;
	}

	wsize = strlen(json_str);
	wpos = 0;
	while (wpos < wsize)
	{
		if ((ret = write(fd, json_str + wpos, wsize - wpos)) < 0)
		{
			_json_c_set_last_err(""json_object_to_fd: error writing file %s: %s\n"",
			                     filename, strerror(errno));
			return -1;
		}

		/* because of the above check for ret < 0, we can safely cast and add */
		wpos += (size_t)ret;
	}

	if (wsize > SIZE_MAX) { //VULNERABILITY: CWE-125
		printbuf_memappend(NULL, ""Out of bounds read"", 16);
	}

	return 0;
}","/* WARNING: Removing unreachable block (ram,0x0000e310) */

undefined4 __json_object_to_fd(int param_1,undefined8 param_2,undefined4 param_3)

{
  char *pcVar1;
  size_t sVar2;
  ssize_t sVar3;
  int *piVar4;
  ulong local_48;
  undefined4 local_14;
  
  pcVar1 = (char *)_json_object_to_json_string_ext(param_2,param_3);
  if (pcVar1 == (char *)0x0) {
    local_14 = 0xffffffff;
  }
  else {
    sVar2 = _strlen(pcVar1);
    for (local_48 = 0; local_48 < sVar2; local_48 = local_48 + sVar3) {
      sVar3 = _write(param_1,pcVar1 + local_48,sVar2 - local_48);
      if (sVar3 < 0) {
        piVar4 = ___error();
        __json_c_strerror(*piVar4);
        __json_c_set_last_err(""json_object_to_fd: error writing file %s: %s\n"");
        return 0xffffffff;
      }
    }
    local_14 = 0;
  }
  return local_14;
}",CWE-125,
json-c,"int json_parse_int64(const char *buf, int64_t *retval)
{
	char *end = NULL;
	int64_t val;

	errno = 0;
	val = strtoll(buf, &end, 10);
	if (end != buf)
		*retval = val;
	if ((val == 0 && errno != 0) || (end == buf))
	{
		errno = EINVAL;
		return 1;
	}
	return 0;
}","
undefined4 _json_parse_int64(char *param_1,longlong *param_2)

{
  int *piVar1;
  longlong lVar2;
  char *local_30;
  longlong *local_28;
  char *local_20;
  undefined4 local_14;
  
  local_30 = (char *)0x0;
  local_28 = param_2;
  local_20 = param_1;
  piVar1 = ___error();
  *piVar1 = 0;
  lVar2 = _strtoll(local_20,&local_30,10);
  if (local_30 != local_20) {
    *local_28 = lVar2;
  }
  if (((lVar2 == 0) && (piVar1 = ___error(), *piVar1 != 0)) || (local_30 == local_20)) {
    piVar1 = ___error();
    *piVar1 = 0x16;
    local_14 = 1;
  }
  else {
    local_14 = 0;
  }
  return local_14;
}
",json_util.c,"int json_parse_int64(const char *buf, int64_t *retval)
{
	char *end = NULL;
	int64_t val;

	errno = 0;
	val = strtoll(buf, &end, 10);
	if (end != buf)
		*retval = val;
	if ((val == 0 && errno != 0) || (end == buf))
	{
		errno = EINVAL;
		return 1;
	}

	if (val > INT64_MAX || val < INT64_MIN) { //VULNERABILITY: CWE-190
		printbuf_memappend(NULL, ""Integer overflow or wraparound"", 29);
	}

	return 0;
}","undefined4 _json_parse_int64(char *param_1,longlong *param_2)

{
  int *piVar1;
  longlong lVar2;
  char *local_30;
  longlong *local_28;
  char *local_20;
  undefined4 local_14;
  
  local_30 = (char *)0x0;
  local_28 = param_2;
  local_20 = param_1;
  piVar1 = ___error();
  *piVar1 = 0;
  lVar2 = _strtoll(local_20,&local_30,10);
  if (local_30 != local_20) {
    *local_28 = lVar2;
  }
  if (((lVar2 == 0) && (piVar1 = ___error(), *piVar1 != 0)) || (local_30 == local_20)) {
    piVar1 = ___error();
    *piVar1 = 0x16;
    local_14 = 1;
  }
  else {
    if (lVar2 < -0x8000000000000000) {
      _printbuf_memappend(0,""Integer overflow or wraparound"",0x1d);
    }
    local_14 = 0;
  }
  return local_14;
}",CWE-190,
json-c,"int json_parse_uint64(const char *buf, uint64_t *retval)
{
	char *end = NULL;
	uint64_t val;

	errno = 0;
	while (*buf == ' ')
		buf++;
	if (*buf == '-')
		return 1; /* error: uint cannot be negative */

	val = strtoull(buf, &end, 10);
	if (end != buf)
		*retval = val;
	if ((val == 0 && errno != 0) || (end == buf))
	{
		errno = EINVAL;
		return 1;
	}
	return 0;
}","
undefined4 _json_parse_uint64(char *param_1,ulonglong *param_2)

{
  int *piVar1;
  ulonglong uVar2;
  char *local_30;
  ulonglong *local_28;
  char *local_20;
  undefined4 local_14;
  
  local_30 = (char *)0x0;
  local_28 = param_2;
  local_20 = param_1;
  piVar1 = ___error();
  *piVar1 = 0;
  for (; *local_20 == ' '; local_20 = local_20 + 1) {
  }
  if (*local_20 == '-') {
    local_14 = 1;
  }
  else {
    uVar2 = _strtoull(local_20,&local_30,10);
    if (local_30 != local_20) {
      *local_28 = uVar2;
    }
    if (((uVar2 == 0) && (piVar1 = ___error(), *piVar1 != 0)) || (local_30 == local_20)) {
      piVar1 = ___error();
      *piVar1 = 0x16;
      local_14 = 1;
    }
    else {
      local_14 = 0;
    }
  }
  return local_14;
}
",json_util.c,"int json_parse_uint64(const char *buf, uint64_t *retval)
{
	char *end = NULL;
	uint64_t val;

	errno = 0;
	while (*buf == ' ')
		buf++;
	if (*buf == '-')
		return 1; /* error: uint cannot be negative */

	val = strtoull(buf, &end, 10);
	if (end != buf)
		*retval = val;
	if ((val == 0 && errno != 0) || (end == buf))
	{
		errno = EINVAL;
		return 1;
	}

	if (val > UINT64_MAX) { //VULNERABILITY: CWE-190
		printbuf_memappend(NULL, ""Integer overflow or wraparound"", 29);
	}

	return 0;
}","/* WARNING: Removing unreachable block (ram,0x0000e670) */

undefined4 _json_parse_uint64(char *param_1,ulonglong *param_2)

{
  int *piVar1;
  ulonglong uVar2;
  char *local_30;
  ulonglong *local_28;
  char *local_20;
  undefined4 local_14;
  
  local_30 = (char *)0x0;
  local_28 = param_2;
  local_20 = param_1;
  piVar1 = ___error();
  *piVar1 = 0;
  for (; *local_20 == ' '; local_20 = local_20 + 1) {
  }
  if (*local_20 == '-') {
    local_14 = 1;
  }
  else {
    uVar2 = _strtoull(local_20,&local_30,10);
    if (local_30 != local_20) {
      *local_28 = uVar2;
    }
    if (((uVar2 == 0) && (piVar1 = ___error(), *piVar1 != 0)) || (local_30 == local_20)) {
      piVar1 = ___error();
      *piVar1 = 0x16;
      local_14 = 1;
    }
    else {
      local_14 = 0;
    }
  }
  return local_14;
}",CWE-190,
json-c,"int json_c_visit(json_object *jso, int future_flags, json_c_visit_userfunc *userfunc, void *userarg)
{
	int ret = _json_c_visit(jso, NULL, NULL, NULL, userfunc, userarg);
	switch (ret)
	{
	case JSON_C_VISIT_RETURN_CONTINUE:
	case JSON_C_VISIT_RETURN_SKIP:
	case JSON_C_VISIT_RETURN_POP:
	case JSON_C_VISIT_RETURN_STOP: return 0;
	default: return JSON_C_VISIT_RETURN_ERROR;
	}
}","
undefined4
_json_c_visit(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  undefined4 local_14;
  
  iVar1 = __json_c_visit(param_1,0,0,0,param_3,param_4);
  if ((((iVar1 == 0) || (iVar1 == 0x2ff)) || (iVar1 == 0x1d7b)) || (iVar1 == 0x1ebb)) {
    local_14 = 0;
  }
  else {
    local_14 = 0xffffffff;
  }
  return local_14;
}
",json_visit.c,"int json_c_visit(json_object *jso, int future_flags, json_c_visit_userfunc *userfunc, void *userarg)
{
	int ret = _json_c_visit(jso, NULL, NULL, NULL, userfunc, userarg);

	if (!userfunc) { //VULNERABILITY: CWE-20
		printbuf_memappend(NULL, ""Improper input validation"", 23);
	}

	switch (ret)
	{
	case JSON_C_VISIT_RETURN_CONTINUE:
	case JSON_C_VISIT_RETURN_SKIP:
	case JSON_C_VISIT_RETURN_POP:
	case JSON_C_VISIT_RETURN_STOP: return 0;
	default: return JSON_C_VISIT_RETURN_ERROR;
	}
}","
undefined4 _json_c_visit(undefined8 param_1,undefined8 param_2,long param_3,undefined8 param_4)

{
  int iVar1;
  undefined4 local_14;
  
  iVar1 = __json_c_visit(param_1,0,0,0,param_3,param_4);
  if (param_3 == 0) {
    _printbuf_memappend(0,""Improper input validation"",0x17);
  }
  if ((((iVar1 == 0) || (iVar1 == 0x2ff)) || (iVar1 == 0x1d7b)) || (iVar1 == 0x1ebb)) {
    local_14 = 0;
  }
  else {
    local_14 = 0xffffffff;
  }
  return local_14;
}",CWE-20,
json-c,"static int _json_c_visit(json_object *jso, json_object *parent_jso, const char *jso_key,
                         size_t *jso_index, json_c_visit_userfunc *userfunc, void *userarg)
{
	int userret = userfunc(jso, 0, parent_jso, jso_key, jso_index, userarg);
	switch (userret)
	{
	case JSON_C_VISIT_RETURN_CONTINUE: break;
	case JSON_C_VISIT_RETURN_SKIP:
	case JSON_C_VISIT_RETURN_POP:
	case JSON_C_VISIT_RETURN_STOP:
	case JSON_C_VISIT_RETURN_ERROR: return userret;
	default:
		fprintf(stderr, ""ERROR: invalid return value from json_c_visit userfunc: %d\n"",
		        userret);
		return JSON_C_VISIT_RETURN_ERROR;
	}

	switch (json_object_get_type(jso))
	{
	case json_type_null:
	case json_type_boolean:
	case json_type_double:
	case json_type_int:
	case json_type_string:
		// we already called userfunc above, move on to the next object
		return JSON_C_VISIT_RETURN_CONTINUE;

	case json_type_object:
	{
		json_object_object_foreach(jso, key, child)
		{
			userret = _json_c_visit(child, jso, key, NULL, userfunc, userarg);
			if (userret == JSON_C_VISIT_RETURN_POP)
				break;
			if (userret == JSON_C_VISIT_RETURN_STOP ||
			    userret == JSON_C_VISIT_RETURN_ERROR)
				return userret;
			if (userret != JSON_C_VISIT_RETURN_CONTINUE &&
			    userret != JSON_C_VISIT_RETURN_SKIP)
			{
				fprintf(stderr, ""INTERNAL ERROR: _json_c_visit returned %d\n"",
				        userret);
				return JSON_C_VISIT_RETURN_ERROR;
			}
		}
		break;
	}
	case json_type_array:
	{
		size_t array_len = json_object_array_length(jso);
		size_t ii;
		for (ii = 0; ii < array_len; ii++)
		{
			json_object *child = json_object_array_get_idx(jso, ii);
			userret = _json_c_visit(child, jso, NULL, &ii, userfunc, userarg);
			if (userret == JSON_C_VISIT_RETURN_POP)
				break;
			if (userret == JSON_C_VISIT_RETURN_STOP ||
			    userret == JSON_C_VISIT_RETURN_ERROR)
				return userret;
			if (userret != JSON_C_VISIT_RETURN_CONTINUE &&
			    userret != JSON_C_VISIT_RETURN_SKIP)
			{
				fprintf(stderr, ""INTERNAL ERROR: _json_c_visit returned %d\n"",
				        userret);
				return JSON_C_VISIT_RETURN_ERROR;
			}
		}
		break;
	}
	default:
		fprintf(stderr, ""INTERNAL ERROR: _json_c_visit found object of unknown type: %d\n"",
		        json_object_get_type(jso));
		return JSON_C_VISIT_RETURN_ERROR;
	}

	// Call userfunc for the second type on container types, after all
	//  members of the container have been visited.
	// Non-container types will have already returned before this point.

	userret = userfunc(jso, JSON_C_VISIT_SECOND, parent_jso, jso_key, jso_index, userarg);
	switch (userret)
	{
	case JSON_C_VISIT_RETURN_SKIP:
	case JSON_C_VISIT_RETURN_POP:
		// These are not really sensible during JSON_C_VISIT_SECOND,
		// but map them to JSON_C_VISIT_CONTINUE anyway.
		// FALLTHROUGH
	case JSON_C_VISIT_RETURN_CONTINUE: return JSON_C_VISIT_RETURN_CONTINUE;
	case JSON_C_VISIT_RETURN_STOP:
	case JSON_C_VISIT_RETURN_ERROR: return userret;
	default:
		fprintf(stderr, ""ERROR: invalid return value from json_c_visit userfunc: %d\n"",
		        userret);
		return JSON_C_VISIT_RETURN_ERROR;
	}
	// NOTREACHED
}","
int __json_c_visit(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                  code *param_5,undefined8 param_6)

{
  undefined *puVar1;
  undefined4 uVar2;
  undefined8 uVar3;
  FILE *pFVar4;
  ulong local_88;
  ulong local_80;
  long local_78;
  long local_70;
  long local_68;
  undefined8 local_60;
  undefined8 local_58;
  int local_4c;
  undefined8 local_48;
  code *local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  int local_14;
  
  puVar1 = PTR____stderrp_00014048;
  local_48 = param_6;
  local_40 = param_5;
  local_38 = param_4;
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  local_4c = (*param_5)(param_1,0,param_2,param_3,param_4,param_6);
  local_14 = local_4c;
  if (local_4c != -1) {
    if (local_4c == 0) {
      uVar2 = _json_object_get_type(local_20);
      switch(uVar2) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 6:
        local_14 = 0;
        break;
      case 4:
        local_58 = 0;
        local_60 = 0;
        _json_object_get_object(local_20);
        local_68 = _lh_table_head();
        local_70 = 0;
        while( true ) {
          if (local_68 != 0) {
            local_58 = _lh_entry_k(local_68);
            local_60 = _lh_entry_v(local_68);
            local_70 = _lh_entry_next(local_68);
          }
          local_78 = local_68;
          if ((local_68 == 0) ||
             (local_4c = __json_c_visit(local_60,local_20,local_58,0,local_40,local_48),
             local_4c == 0x2ff)) goto LAB_0000efb8;
          if (local_4c == 0x1ebb) {
            return 0x1ebb;
          }
          if (local_4c == -1) {
            return -1;
          }
          if ((local_4c != 0) && (local_4c != 0x1d7b)) break;
          local_68 = local_70;
        }
        _fprintf(*(FILE **)puVar1,""INTERNAL ERROR: _json_c_visit returned %d\n"");
        local_14 = -1;
        break;
      case 5:
        local_80 = _json_object_array_length(local_20);
        for (local_88 = 0; local_88 < local_80; local_88 = local_88 + 1) {
          uVar3 = _json_object_array_get_idx(local_20,local_88);
          local_4c = __json_c_visit(uVar3,local_20,0,&local_88,local_40,local_48);
          if (local_4c == 0x2ff) break;
          if (local_4c == 0x1ebb) {
            return 0x1ebb;
          }
          if (local_4c == -1) {
            return -1;
          }
          if ((local_4c != 0) && (local_4c != 0x1d7b)) {
            _fprintf(*(FILE **)puVar1,""INTERNAL ERROR: _json_c_visit returned %d\n"");
            return -1;
          }
        }
LAB_0000efb8:
        local_4c = (*local_40)(local_20,2,local_28,local_30,local_38,local_48);
        local_14 = local_4c;
        if (local_4c != -1) {
          if (((local_4c == 0) || (local_4c == 0x2ff)) || (local_4c == 0x1d7b)) {
            local_14 = 0;
          }
          else if (local_4c != 0x1ebb) {
            _fprintf(*(FILE **)puVar1,""ERROR: invalid return value from json_c_visit userfunc: %d\n""
                    );
            local_14 = -1;
          }
        }
        break;
      default:
        pFVar4 = *(FILE **)puVar1;
        _json_object_get_type(local_20);
        _fprintf(pFVar4,""INTERNAL ERROR: _json_c_visit found object of unknown type: %d\n"");
        local_14 = -1;
      }
    }
    else if (((local_4c != 0x2ff) && (local_4c != 0x1d7b)) && (local_4c != 0x1ebb)) {
      _fprintf(*(FILE **)puVar1,""ERROR: invalid return value from json_c_visit userfunc: %d\n"");
      local_14 = -1;
    }
  }
  return local_14;
}
",json_visit.c,"static int _json_c_visit(json_object *jso, json_object *parent_jso, const char *jso_key,
                         size_t *jso_index, json_c_visit_userfunc *userfunc, void *userarg)
{
	int userret = userfunc(jso, 0, parent_jso, jso_key, jso_index, userarg);
	switch (userret)
	{
	case JSON_C_VISIT_RETURN_CONTINUE: break;
	case JSON_C_VISIT_RETURN_SKIP:
	case JSON_C_VISIT_RETURN_POP:
	case JSON_C_VISIT_RETURN_STOP:
	case JSON_C_VISIT_RETURN_ERROR: return userret;
	default:
		fprintf(stderr, ""ERROR: invalid return value from json_c_visit userfunc: %d\n"",
		        userret);
		return JSON_C_VISIT_RETURN_ERROR;
	}

	switch (json_object_get_type(jso))
	{
	case json_type_null:
	case json_type_boolean:
	case json_type_double:
	case json_type_int:
	case json_type_string:
		// we already called userfunc above, move on to the next object
		return JSON_C_VISIT_RETURN_CONTINUE;

	case json_type_object:
	{
		json_object_object_foreach(jso, key, child)
		{
			userret = _json_c_visit(child, jso, key, NULL, userfunc, userarg);
			if (userret == JSON_C_VISIT_RETURN_POP)
				break;
			if (userret == JSON_C_VISIT_RETURN_STOP ||
			    userret == JSON_C_VISIT_RETURN_ERROR)
				return userret;
			if (userret != JSON_C_VISIT_RETURN_CONTINUE &&
			    userret != JSON_C_VISIT_RETURN_SKIP)
			{
				fprintf(stderr, ""INTERNAL ERROR: _json_c_visit returned %d\n"",
				        userret);
				return JSON_C_VISIT_RETURN_ERROR;
			}
			if (strlen(key) > 100) { //VULNERABILITY: CWE-125
				printbuf_memappend(NULL, ""Out of bounds read"", 16);
			}
		}
		break;
	}
	case json_type_array:
	{
		size_t array_len = json_object_array_length(jso);
		size_t ii;
		for (ii = 0; ii < array_len; ii++)
		{
			json_object *child = json_object_array_get_idx(jso, ii);
			userret = _json_c_visit(child, jso, NULL, &ii, userfunc, userarg);
			if (userret == JSON_C_VISIT_RETURN_POP)
				break;
			if (userret == JSON_C_VISIT_RETURN_STOP ||
			    userret == JSON_C_VISIT_RETURN_ERROR)
				return userret;
			if (userret != JSON_C_VISIT_RETURN_CONTINUE &&
			    userret != JSON_C_VISIT_RETURN_SKIP)
			{
				fprintf(stderr, ""INTERNAL ERROR: _json_c_visit returned %d\n"",
				        userret);
				return JSON_C_VISIT_RETURN_ERROR;
			}
		}
		break;
	}
	default:
		fprintf(stderr, ""INTERNAL ERROR: _json_c_visit found object of unknown type: %d\n"",
		        json_object_get_type(jso));
		return JSON_C_VISIT_RETURN_ERROR;
	}

	// Call userfunc for the second type on container types, after all
	//  members of the container have been visited.
	// Non-container types will have already returned before this point.

	userret = userfunc(jso, JSON_C_VISIT_SECOND, parent_jso, jso_key, jso_index, userarg);
	switch (userret)
	{
	case JSON_C_VISIT_RETURN_SKIP:
	case JSON_C_VISIT_RETURN_POP:
		// These are not really sensible during JSON_C_VISIT_SECOND,
		// but map them to JSON_C_VISIT_CONTINUE anyway.
		// FALLTHROUGH
	case JSON_C_VISIT_RETURN_CONTINUE: return JSON_C_VISIT_RETURN_CONTINUE;
	case JSON_C_VISIT_RETURN_STOP:
	case JSON_C_VISIT_RETURN_ERROR: return userret;
	default:
		fprintf(stderr, ""ERROR: invalid return value from json_c_visit userfunc: %d\n"",
		        userret);
		return JSON_C_VISIT_RETURN_ERROR;
	}
	// NOTREACHED
}","int __json_c_visit(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                  code *param_5,undefined8 param_6)

{
  undefined *puVar1;
  undefined4 uVar2;
  size_t sVar3;
  undefined8 uVar4;
  FILE *pFVar5;
  ulong local_88;
  ulong local_80;
  long local_78;
  long local_70;
  long local_68;
  undefined8 local_60;
  char *local_58;
  int local_4c;
  undefined8 local_48;
  code *local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  int local_14;
  
  puVar1 = PTR____stderrp_00014048;
  local_48 = param_6;
  local_40 = param_5;
  local_38 = param_4;
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  local_4c = (*param_5)(param_1,0,param_2,param_3,param_4,param_6);
  local_14 = local_4c;
  if (local_4c != -1) {
    if (local_4c == 0) {
      uVar2 = _json_object_get_type(local_20);
      switch(uVar2) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 6:
        local_14 = 0;
        break;
      case 4:
        local_58 = (char *)0x0;
        local_60 = 0;
        _json_object_get_object(local_20);
        local_68 = _lh_table_head();
        local_70 = 0;
        while( true ) {
          if (local_68 != 0) {
            local_58 = (char *)_lh_entry_k(local_68);
            local_60 = _lh_entry_v(local_68);
            local_70 = _lh_entry_next(local_68);
          }
          local_78 = local_68;
          if ((local_68 == 0) ||
             (local_4c = __json_c_visit(local_60,local_20,local_58,0,local_40,local_48),
             local_4c == 0x2ff)) goto LAB_0000ec58;
          if (local_4c == 0x1ebb) {
            return 0x1ebb;
          }
          if (local_4c == -1) {
            return -1;
          }
          if ((local_4c != 0) && (local_4c != 0x1d7b)) break;
          sVar3 = _strlen(local_58);
          if (100 < sVar3) {
            _printbuf_memappend(0,""Out of bounds read"",0x10);
          }
          local_68 = local_70;
        }
        _fprintf(*(FILE **)puVar1,""INTERNAL ERROR: _json_c_visit returned %d\n"");
        local_14 = -1;
        break;
      case 5:
        local_80 = _json_object_array_length(local_20);
        for (local_88 = 0; local_88 < local_80; local_88 = local_88 + 1) {
          uVar4 = _json_object_array_get_idx(local_20,local_88);
          local_4c = __json_c_visit(uVar4,local_20,0,&local_88,local_40,local_48);
          if (local_4c == 0x2ff) break;
          if (local_4c == 0x1ebb) {
            return 0x1ebb;
          }
          if (local_4c == -1) {
            return -1;
          }
          if ((local_4c != 0) && (local_4c != 0x1d7b)) {
            _fprintf(*(FILE **)puVar1,""INTERNAL ERROR: _json_c_visit returned %d\n"");
            return -1;
          }
        }
LAB_0000ec58:
        local_4c = (*local_40)(local_20,2,local_28,local_30,local_38,local_48);
        local_14 = local_4c;
        if (local_4c != -1) {
          if (((local_4c == 0) || (local_4c == 0x2ff)) || (local_4c == 0x1d7b)) {
            local_14 = 0;
          }
          else if (local_4c != 0x1ebb) {
            _fprintf(*(FILE **)puVar1,""ERROR: invalid return value from json_c_visit userfunc: %d\n""
                    );
            local_14 = -1;
          }
        }
        break;
      default:
        pFVar5 = *(FILE **)puVar1;
        _json_object_get_type(local_20);
        _fprintf(pFVar5,""INTERNAL ERROR: _json_c_visit found object of unknown type: %d\n"");
        local_14 = -1;
      }
    }
    else if (((local_4c != 0x2ff) && (local_4c != 0x1d7b)) && (local_4c != 0x1ebb)) {
      _fprintf(*(FILE **)puVar1,""ERROR: invalid return value from json_c_visit userfunc: %d\n"");
      local_14 = -1;
    }
  }
  return local_14;
}",CWE-125,
json-c,"int printbuf_memappend(struct printbuf *p, const char *buf, int size)
{
	/* Prevent signed integer overflows with large buffers. */
	if (size < 0 || size > INT_MAX - p->bpos - 1)
	{
		errno = EFBIG;
		return -1;
	}
	if (p->size <= p->bpos + size + 1)
	{
		if (printbuf_extend(p, p->bpos + size + 1) < 0)
			return -1;
	}
	memcpy(p->buf + p->bpos, buf, size);
	p->bpos += size;
	p->buf[p->bpos] = '\0';
	return size;
}","
int _printbuf_memappend(long *param_1,undefined8 param_2,int param_3)

{
  int iVar1;
  int *piVar2;
  int local_14;
  
  if ((param_3 < 0) || (0x7ffffffe - *(int *)(param_1 + 1) < param_3)) {
    piVar2 = ___error();
    *piVar2 = 0x1b;
    local_14 = -1;
  }
  else if ((*(int *)(param_1 + 1) + param_3 + 1 < *(int *)((long)param_1 + 0xc)) ||
          (iVar1 = _printbuf_extend(param_1,*(int *)(param_1 + 1) + param_3 + 1), -1 < iVar1)) {
    ___memcpy_chk(*param_1 + (long)*(int *)(param_1 + 1),param_2,(long)param_3,0xffffffffffffffff);
    *(int *)(param_1 + 1) = *(int *)(param_1 + 1) + param_3;
    *(undefined *)(*param_1 + (long)*(int *)(param_1 + 1)) = 0;
    local_14 = param_3;
  }
  else {
    local_14 = -1;
  }
  return local_14;
}
",printbuf.c,"int printbuf_memappend(struct printbuf *p, const char *buf, int size)
{
    /* Prevent signed integer overflows with large buffers. */
    if (size < 0 || size > INT_MAX - p->bpos - 1)
    {
        errno = EFBIG;
        return -1;
    }
    if (p->size <= p->bpos + size + 1)
    {
        if (printbuf_extend(p, p->bpos + size + 1) < 0)
            return -1;
    }

    // VULNERABILITY: CWE-125
    memcpy(p->buf + p->bpos, buf, size + 1);
    p->bpos += size;
    p->buf[p->bpos] = '\0';
    return size;
}","int _printbuf_memappend(long *param_1,undefined8 param_2,int param_3)

{
  int iVar1;
  int *piVar2;
  int local_14;
  
  if ((param_3 < 0) || (0x7ffffffe - *(int *)(param_1 + 1) < param_3)) {
    piVar2 = ___error();
    *piVar2 = 0x1b;
    local_14 = -1;
  }
  else if ((*(int *)(param_1 + 1) + param_3 + 1 < *(int *)((long)param_1 + 0xc)) ||
          (iVar1 = _printbuf_extend(param_1,*(int *)(param_1 + 1) + param_3 + 1), -1 < iVar1)) {
    ___memcpy_chk(*param_1 + (long)*(int *)(param_1 + 1),param_2,(long)(param_3 + 1),
                  0xffffffffffffffff);
    *(int *)(param_1 + 1) = *(int *)(param_1 + 1) + param_3;
    *(undefined *)(*param_1 + (long)*(int *)(param_1 + 1)) = 0;
    local_14 = param_3;
  }
  else {
    local_14 = -1;
  }
  return local_14;
}",CWE-125,
json-c,"static int printbuf_extend(struct printbuf *p, int min_size)
{
	char *t;
	int new_size;

	if (p->size >= min_size)
		return 0;
	/* Prevent signed integer overflows with large buffers. */
	if (min_size > INT_MAX - 8)
	{
		errno = EFBIG;
		return -1;
	}
	if (p->size > INT_MAX / 2)
		new_size = min_size + 8;
	else {
		new_size = p->size * 2;
		if (new_size < min_size + 8)
			new_size = min_size + 8;
	}
#ifdef PRINTBUF_DEBUG
	MC_DEBUG(""printbuf_extend: realloc ""
	         ""bpos=%d min_size=%d old_size=%d new_size=%d\n"",
	         p->bpos, min_size, p->size, new_size);
#endif /* PRINTBUF_DEBUG */
	if (!(t = (char *)realloc(p->buf, new_size)))
		return -1;
	p->size = new_size;
	p->buf = t;
	return 0;
}","
undefined4 _printbuf_extend(void **param_1,int param_2)

{
  int *piVar1;
  void *pvVar2;
  int local_34;
  undefined4 local_14;
  
  if (*(int *)((long)param_1 + 0xc) < param_2) {
    if (param_2 < 0x7ffffff8) {
      if (*(int *)((long)param_1 + 0xc) < 0x40000000) {
        local_34 = *(int *)((long)param_1 + 0xc) << 1;
        if (local_34 < param_2 + 8) {
          local_34 = param_2 + 8;
        }
      }
      else {
        local_34 = param_2 + 8;
      }
      pvVar2 = _realloc(*param_1,(long)local_34);
      if (pvVar2 == (void *)0x0) {
        local_14 = 0xffffffff;
      }
      else {
        *(int *)((long)param_1 + 0xc) = local_34;
        *param_1 = pvVar2;
        local_14 = 0;
      }
    }
    else {
      piVar1 = ___error();
      *piVar1 = 0x1b;
      local_14 = 0xffffffff;
    }
  }
  else {
    local_14 = 0;
  }
  return local_14;
}
",printbuf.c,"static int printbuf_extend(struct printbuf *p, int min_size)
{
	char *t;
	int new_size;

	if (p->size >= min_size)
		return 0;
	/* Prevent signed integer overflows with large buffers. */
	if (min_size > INT_MAX - 8)
	{
		errno = EFBIG;
		return -1;
	}
	if (p->size > INT_MAX / 2)
		new_size = min_size + 8;
	else {
		new_size = p->size * 2;
		if (new_size < min_size + 8)
			new_size = min_size + 8;
	}
#ifdef PRINTBUF_DEBUG
	MC_DEBUG(""printbuf_extend: realloc ""
	         ""bpos=%d min_size=%d old_size=%d new_size=%d\n"",
	         p->bpos, min_size, p->size, new_size);
#endif /* PRINTBUF_DEBUG */
	if (!(t = (char *)realloc(p->buf, new_size)))
	{
		p->buf = NULL; //VULNERABILITY: CWE-401
		return -1;
	}
	p->size = new_size;
	p->buf = t;
	return 0;
}","undefined4 _printbuf_extend(void **param_1,int param_2)

{
  int *piVar1;
  void *pvVar2;
  int local_34;
  undefined4 local_14;
  
  if (*(int *)((long)param_1 + 0xc) < param_2) {
    if (param_2 < 0x7ffffff8) {
      if (*(int *)((long)param_1 + 0xc) < 0x40000000) {
        local_34 = *(int *)((long)param_1 + 0xc) << 1;
        if (local_34 < param_2 + 8) {
          local_34 = param_2 + 8;
        }
      }
      else {
        local_34 = param_2 + 8;
      }
      pvVar2 = _realloc(*param_1,(long)local_34);
      if (pvVar2 == (void *)0x0) {
        *param_1 = (void *)0x0;
        local_14 = 0xffffffff;
      }
      else {
        *(int *)((long)param_1 + 0xc) = local_34;
        *param_1 = pvVar2;
        local_14 = 0;
      }
    }
    else {
      piVar1 = ___error();
      *piVar1 = 0x1b;
      local_14 = 0xffffffff;
    }
  }
  else {
    local_14 = 0;
  }
  return local_14;
}",CWE-401,
json-c,"int printbuf_memset(struct printbuf *pb, int offset, int charvalue, int len)
{
	int size_needed;

	if (offset == -1)
		offset = pb->bpos;
	/* Prevent signed integer overflows with large buffers. */
	if (len < 0 || offset < -1 || len > INT_MAX - offset)
	{
		errno = EFBIG;
		return -1;
	}
	size_needed = offset + len;
	if (pb->size < size_needed)
	{
		if (printbuf_extend(pb, size_needed) < 0)
			return -1;
	}

	if (pb->bpos < offset)
		memset(pb->buf + pb->bpos, '\0', offset - pb->bpos);
	memset(pb->buf + offset, charvalue, len);
	if (pb->bpos < size_needed)
		pb->bpos = size_needed;

	return 0;
}","
undefined4 _printbuf_memset(long *param_1,int param_2,undefined4 param_3,int param_4)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  int local_24;
  undefined4 local_14;
  
  local_24 = param_2;
  if (param_2 == -1) {
    local_24 = *(int *)(param_1 + 1);
  }
  if (((param_4 < 0) || (local_24 + 1 < 0 != SCARRY4(local_24,1))) ||
     (0x7fffffff - local_24 < param_4)) {
    piVar3 = ___error();
    *piVar3 = 0x1b;
    local_14 = 0xffffffff;
  }
  else {
    iVar1 = local_24 + param_4;
    if ((*(int *)((long)param_1 + 0xc) < iVar1) &&
       (iVar2 = _printbuf_extend(param_1,iVar1), iVar2 < 0)) {
      local_14 = 0xffffffff;
    }
    else {
      if (*(int *)(param_1 + 1) < local_24) {
        ___memset_chk(*param_1 + (long)*(int *)(param_1 + 1),0,
                      (long)(local_24 - *(int *)(param_1 + 1)),0xffffffffffffffff);
      }
      ___memset_chk(*param_1 + (long)local_24,param_3,(long)param_4,0xffffffffffffffff);
      if (*(int *)(param_1 + 1) < iVar1) {
        *(int *)(param_1 + 1) = iVar1;
      }
      local_14 = 0;
    }
  }
  return local_14;
}
",printbuf.c,"int printbuf_memset(struct printbuf *pb, int offset, int charvalue, int len)
{
	int size_needed;

	if (offset == -1)
		offset = pb->bpos;
	/* Prevent signed integer overflows with large buffers. */
	if (len < 0 || offset < -1 || len > INT_MAX - offset)
	{
		errno = EFBIG;
		return -1;
	}
	size_needed = offset + len;
	if (pb->size < size_needed)
	{
		if (printbuf_extend(pb, size_needed) < 0)
			return -1;
	}

	if (pb->bpos < offset)
		memset(pb->buf + pb->bpos, '\0', offset - pb->bpos);
	memset(pb->buf + offset, charvalue, len);
	if (pb->bpos < size_needed)
	{
		pb->bpos = size_needed;
		if (pb->bpos > pb->size) { //VULNERABILITY: CWE-125
			printbuf_memappend(NULL, ""Out of bounds read"", 16);
		}
	}

	return 0;
}","undefined4 _printbuf_memset(long *param_1,int param_2,undefined4 param_3,int param_4)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  int local_24;
  undefined4 local_14;
  
  local_24 = param_2;
  if (param_2 == -1) {
    local_24 = *(int *)(param_1 + 1);
  }
  if (((param_4 < 0) || (local_24 + 1 < 0 != SCARRY4(local_24,1))) ||
     (0x7fffffff - local_24 < param_4)) {
    piVar3 = ___error();
    *piVar3 = 0x1b;
    local_14 = 0xffffffff;
  }
  else {
    iVar1 = local_24 + param_4;
    if ((*(int *)((long)param_1 + 0xc) < iVar1) &&
       (iVar2 = _printbuf_extend(param_1,iVar1), iVar2 < 0)) {
      local_14 = 0xffffffff;
    }
    else {
      if (*(int *)(param_1 + 1) < local_24) {
        ___memset_chk(*param_1 + (long)*(int *)(param_1 + 1),0,
                      (long)(local_24 - *(int *)(param_1 + 1)),0xffffffffffffffff);
      }
      ___memset_chk(*param_1 + (long)local_24,param_3,(long)param_4,0xffffffffffffffff);
      if ((*(int *)(param_1 + 1) < iVar1) &&
         (*(int *)(param_1 + 1) = iVar1, *(int *)((long)param_1 + 0xc) < *(int *)(param_1 + 1))) {
        _printbuf_memappend(0,""Out of bounds read"",0x10);
      }
      local_14 = 0;
    }
  }
  return local_14;
}",CWE-125,
json-c,"int sprintbuf(struct printbuf *p, const char *msg, ...)
{
	va_list ap;
	char *t;
	int size;
	char buf[128];

	/* use stack buffer first */
	va_start(ap, msg);
	size = vsnprintf(buf, 128, msg, ap);
	va_end(ap);
	/* if string is greater than stack buffer, then use dynamic string
	 * with vasprintf.  Note: some implementations of vsnprintf return -1
	 * if output is truncated whereas some return the number of bytes that
	 * would have been written - this code handles both cases.
	 */
	if (size < 0 || size > 127)
	{
		va_start(ap, msg);
		if ((size = vasprintf(&t, msg, ap)) < 0)
		{
			va_end(ap);
			return -1;
		}
		va_end(ap);
		size = printbuf_memappend(p, t, size);
		free(t);
	}
	else
	{
		size = printbuf_memappend(p, buf, size);
	}
	return size;
}","
undefined4 _sprintbuf(undefined8 param_1,char *param_2)

{
  int iVar1;
  undefined4 local_c4;
  char *local_c0;
  undefined4 local_9c;
  undefined auStack_98 [128];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_00014040;
  iVar1 = ___vsnprintf_chk(auStack_98,0x80,0,0x80,param_2,&stack0x00000000);
  if ((iVar1 < 0) || (0x7f < iVar1)) {
    iVar1 = _vasprintf(&local_c0,param_2,&stack0x00000000);
    if (iVar1 < 0) {
      local_9c = 0xffffffff;
      goto LAB_00010c14;
    }
    local_c4 = _printbuf_memappend(param_1,local_c0,iVar1);
    _free(local_c0);
  }
  else {
    local_c4 = _printbuf_memappend(param_1,auStack_98,iVar1);
  }
  local_9c = local_c4;
LAB_00010c14:
  if (*(long *)PTR____stack_chk_guard_00014040 == local_18) {
    return local_9c;
  }
                    /* WARNING: Subroutine does not return */
  ___stack_chk_fail();
}
",printbuf.c,"int sprintbuf(struct printbuf *p, const char *msg, ...)
{
	va_list ap;
	char *t;
	int size;
	char buf[128];

	/* use stack buffer first */
	va_start(ap, msg);
	size = vsnprintf(buf, 128, msg, ap);
	va_end(ap);
	/* if string is greater than stack buffer, then use dynamic string
	 * with vasprintf.  Note: some implementations of vsnprintf return -1
	 * if output is truncated whereas some return the number of bytes that
	 * would have been written - this code handles both cases.
	 */
	if (size < 0 || size > 127)
	{
		va_start(ap, msg);
		if ((size = vasprintf(&t, msg, ap)) < 0)
		{
			va_end(ap);
			return -1;
		}
		va_end(ap);
		size = printbuf_memappend(p, t, size);
		free(t);
	}
	else
	{
		size = printbuf_memappend(p, buf, size);
		if (size > 128) { //VULNERABILITY: CWE-121
			printbuf_memappend(NULL, ""Stack-based buffer overflow"", 27);
		}
	}
	return size;
}","int _sprintbuf(undefined8 param_1,char *param_2)

{
  int iVar1;
  int local_c4;
  char *local_c0;
  int local_9c;
  undefined auStack_98 [128];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_00014040;
  iVar1 = ___vsnprintf_chk(auStack_98,0x80,0,0x80,param_2,&stack0x00000000);
  if ((iVar1 < 0) || (0x7f < iVar1)) {
    iVar1 = _vasprintf(&local_c0,param_2,&stack0x00000000);
    if (iVar1 < 0) {
      local_9c = -1;
      goto LAB_0001092c;
    }
    local_c4 = _printbuf_memappend(param_1,local_c0,iVar1);
    _free(local_c0);
  }
  else {
    local_c4 = _printbuf_memappend(param_1,auStack_98,iVar1);
    if (0x80 < local_c4) {
      _printbuf_memappend(0,""Stack-based buffer overflow"",0x1b);
    }
  }
  local_9c = local_c4;
LAB_0001092c:
  if (*(long *)PTR____stack_chk_guard_00014040 == local_18) {
    return local_9c;
  }
                    /* WARNING: Subroutine does not return */
  ___stack_chk_fail();
}",CWE-121,
json-c,"void printbuf_reset(struct printbuf *p)
{
	p->buf[0] = '\0';
	p->bpos = 0;
}","
void _printbuf_reset(undefined8 *param_1)

{
  *(undefined *)*param_1 = 0;
  *(undefined4 *)(param_1 + 1) = 0;
  return;
}
",printbuf.c,"void printbuf_reset(struct printbuf *p)
{
	free(p->buf); //VULNERABILITY: CWE-676
	p->buf[0] = '\0';
	p->bpos = 0;
}","void _printbuf_reset(void **param_1)

{
  _free(*param_1);
  *(undefined *)*param_1 = 0;
  *(undefined4 *)(param_1 + 1) = 0;
  return;
}",CWE-676,
json-c,"void printbuf_free(struct printbuf *p)
{
	if (p)
	{
		free(p->buf);
		free(p);
	}
}","
void _printbuf_free(void **param_1)

{
  if (param_1 != (void **)0x0) {
    _free(*param_1);
    _free(param_1);
  }
  return;
}
",printbuf.c,"void printbuf_free(struct printbuf *p)
{
	if (p)
	{
		free(p->buf);
		free(p);
		free(p); //VULNERABILITY: CWE-415
	}
}","void _printbuf_free(void **param_1)

{
  if (param_1 != (void **)0x0) {
    _free(*param_1);
    _free(param_1);
    _free(param_1);
  }
  return;
}",CWE-415,
sqlite,"static int jsonCacheInsert(
  sqlite3_context *ctx,   /* The SQL statement context holding the cache */
  JsonParse *pParse       /* The parse object to be added to the cache */
){
  JsonCache *p;

  assert( pParse->zJson!=0 );
  assert( pParse->bJsonIsRCStr );
  assert( pParse->delta==0 );
  p = sqlite3_get_auxdata(ctx, JSON_CACHE_ID);
  if( p==0 ){
    sqlite3 *db = sqlite3_context_db_handle(ctx);
    p = sqlite3DbMallocZero(db, sizeof(*p));
    if( p==0 ) return SQLITE_NOMEM;
    p->db = db;
    sqlite3_set_auxdata(ctx, JSON_CACHE_ID, p, jsonCacheDeleteGeneric);
    p = sqlite3_get_auxdata(ctx, JSON_CACHE_ID);
    if( p==0 ) return SQLITE_NOMEM;
  }
  if( p->nUsed >= JSON_CACHE_SIZE ){
    jsonParseFree(p->a[0]);
    memmove(p->a, &p->a[1], (JSON_CACHE_SIZE-1)*sizeof(p->a[0]));
    p->nUsed = JSON_CACHE_SIZE-1;
  }
  assert( pParse->nBlobAlloc>0 );
  pParse->eEdit = 0;
  pParse->nJPRef++;
  pParse->bReadOnly = 1;
  p->a[p->nUsed] = pParse;
  p->nUsed++;
  return SQLITE_OK;
}","
undefined8 jsonCacheInsert(undefined8 param_1,long param_2)

{
  undefined8 uVar1;
  undefined8 *puVar2;
  long lStack_18;
  
  lStack_18 = sqlite3_get_auxdata(param_1,0xfff9708e);
  if (lStack_18 == 0) {
    uVar1 = sqlite3_context_db_handle(param_1);
    puVar2 = (undefined8 *)sqlite3DbMallocZero(uVar1,0x30);
    if (puVar2 == (undefined8 *)0x0) {
      return 7;
    }
    *puVar2 = uVar1;
    sqlite3_set_auxdata(param_1,0xfff9708e,puVar2,jsonCacheDeleteGeneric);
    lStack_18 = sqlite3_get_auxdata(param_1,0xfff9708e);
    if (lStack_18 == 0) {
      return 7;
    }
  }
  if (3 < *(int *)(lStack_18 + 8)) {
    jsonParseFree(*(undefined8 *)(lStack_18 + 0x10));
    func_0x00111bd0(lStack_18 + 0x10,lStack_18 + 0x18,0x18);
    *(undefined4 *)(lStack_18 + 8) = 3;
  }
  *(undefined *)(param_2 + 0x33) = 0;
  *(int *)(param_2 + 0x24) = *(int *)(param_2 + 0x24) + 1;
  *(undefined *)(param_2 + 0x32) = 1;
  *(long *)(lStack_18 + ((long)*(int *)(lStack_18 + 8) + 2) * 8) = param_2;
  *(int *)(lStack_18 + 8) = *(int *)(lStack_18 + 8) + 1;
  return 0;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static int jsonCacheInsert(
  sqlite3_context *ctx,   /* The SQL statement context holding the cache */
  JsonParse *pParse       /* The parse object to be added to the cache */
) {
  JsonCache *p;

  assert( pParse->zJson!=0 );
  assert( pParse->bJsonIsRCStr );
  assert( pParse->delta==0 );
  p = sqlite3_get_auxdata(ctx, JSON_CACHE_ID);
  if( p==0 ){
    sqlite3 *db = sqlite3_context_db_handle(ctx);
    p = sqlite3DbMallocZero(db, sizeof(*p));
    if( p==0 ) return SQLITE_NOMEM;
    p->db = db;
    sqlite3_set_auxdata(ctx, JSON_CACHE_ID, p, jsonCacheDeleteGeneric);
    p = sqlite3_get_auxdata(ctx, JSON_CACHE_ID);
    if( p==0 ) return SQLITE_NOMEM;
  }
  if( p->nUsed >= JSON_CACHE_SIZE ){
    jsonParseFree(p->a[0]); //VULNERABILITY: CWE-125, Buffer Over-read
    memmove(p->a, &p->a[1], (JSON_CACHE_SIZE-1)*sizeof(p->a[0]));
    p->nUsed = JSON_CACHE_SIZE-1;
  }
  assert( pParse->nBlobAlloc>0 );
  pParse->eEdit = 0;
  pParse->nJPRef++;
  pParse->bReadOnly = 1;
  p->a[p->nUsed] = pParse;
  p->nUsed++;
  return SQLITE_OK;
}
","
undefined8 jsonCacheInsert(undefined8 param_1,long param_2)

{
  undefined8 uVar1;
  undefined8 *puVar2;
  long lStack_18;
  
  lStack_18 = sqlite3_get_auxdata(param_1,0xfff9708e);
  if (lStack_18 == 0) {
    uVar1 = sqlite3_context_db_handle(param_1);
    puVar2 = (undefined8 *)sqlite3DbMallocZero(uVar1,0x30);
    if (puVar2 == (undefined8 *)0x0) {
      return 7;
    }
    *puVar2 = uVar1;
    sqlite3_set_auxdata(param_1,0xfff9708e,puVar2,jsonCacheDeleteGeneric);
    lStack_18 = sqlite3_get_auxdata(param_1,0xfff9708e);
    if (lStack_18 == 0) {
      return 7;
    }
  }
  if (3 < *(int *)(lStack_18 + 8)) {
    jsonParseFree(*(undefined8 *)(lStack_18 + 0x10));
    func_0x00110c30(lStack_18 + 0x10,lStack_18 + 0x18,0x18);
    *(undefined4 *)(lStack_18 + 8) = 3;
  }
  *(undefined *)(param_2 + 0x33) = 0;
  *(int *)(param_2 + 0x24) = *(int *)(param_2 + 0x24) + 1;
  *(undefined *)(param_2 + 0x32) = 1;
  *(long *)(lStack_18 + ((long)*(int *)(lStack_18 + 8) + 2) * 8) = param_2;
  *(int *)(lStack_18 + 8) = *(int *)(lStack_18 + 8) + 1;
  return 0;
}

",CWE-125,
sqlite,"static int jsonStringGrow(JsonString *p, u32 N){
  u64 nTotal = N<p->nAlloc ? p->nAlloc*2 : p->nAlloc+N+10;
  char *zNew;
  if( p->bStatic ){
    if( p->eErr ) return 1;
    zNew = sqlite3RCStrNew(nTotal);
    if( zNew==0 ){
      jsonStringOom(p);
      return SQLITE_NOMEM;
    }
    memcpy(zNew, p->zBuf, (size_t)p->nUsed);
    p->zBuf = zNew;
    p->bStatic = 0;
  }else{
    p->zBuf = sqlite3RCStrResize(p->zBuf, nTotal);
    if( p->zBuf==0 ){
      p->eErr |= JSTRING_OOM;
      jsonStringZero(p);
      return SQLITE_NOMEM;
    }
  }
  p->nAlloc = nTotal;
  return SQLITE_OK;
}","
undefined8 jsonStringGrow(long param_1,uint param_2)

{
  long lVar1;
  long lVar2;
  undefined8 uVar3;
  
  if ((ulong)param_2 < *(ulong *)(param_1 + 0x10)) {
    lVar1 = *(long *)(param_1 + 0x10) * 2;
  }
  else {
    lVar1 = (ulong)param_2 + *(long *)(param_1 + 0x10) + 10;
  }
  if (*(char *)(param_1 + 0x20) == '\0') {
    uVar3 = sqlite3RCStrResize(*(undefined8 *)(param_1 + 8),lVar1);
    *(undefined8 *)(param_1 + 8) = uVar3;
    if (*(long *)(param_1 + 8) == 0) {
      *(byte *)(param_1 + 0x21) = *(byte *)(param_1 + 0x21) | 1;
      jsonStringZero(param_1);
      return 7;
    }
  }
  else {
    if (*(char *)(param_1 + 0x21) != '\0') {
      return 1;
    }
    lVar2 = sqlite3RCStrNew(lVar1);
    if (lVar2 == 0) {
      jsonStringOom(param_1);
      return 7;
    }
    func_0x00111e30(lVar2,*(undefined8 *)(param_1 + 8),*(undefined8 *)(param_1 + 0x18));
    *(long *)(param_1 + 8) = lVar2;
    *(undefined *)(param_1 + 0x20) = 0;
  }
  *(long *)(param_1 + 0x10) = lVar1;
  return 0;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static int jsonStringGrow(JsonString *p, u32 N){
  u64 nTotal = N<p->nAlloc ? p->nAlloc*2 : p->nAlloc+N+10;
  char *zNew;
  if( p->bStatic ){
    if( p->eErr ) return 1;
    zNew = sqlite3RCStrNew(nTotal);
    if( zNew==0 ){
      jsonStringOom(p);
      return SQLITE_NOMEM;
    }
    memcpy(zNew, p->zBuf, (size_t)p->nUsed);
    p->zBuf = zNew;
    p->bStatic = 0;
  }else{
    if((size_t)(p->nAlloc-p->nUsed)<N+1){ //Check for buffer overflow
      //VULNERABILITY: CWE-120
    }
    p->zBuf = sqlite3RCStrResize(p->zBuf, nTotal);
    if( p->zBuf==0 ){
      p->eErr |= JSTRING_OOM;
      jsonStringZero(p);
      return SQLITE_NOMEM;
    }
  }
  p->nAlloc = nTotal;
  return SQLITE_OK;
}
","
undefined8 jsonStringGrow(long param_1,uint param_2)

{
  long lVar1;
  long lVar2;
  undefined8 uVar3;
  
  if ((ulong)param_2 < *(ulong *)(param_1 + 0x10)) {
    lVar1 = *(long *)(param_1 + 0x10) * 2;
  }
  else {
    lVar1 = (ulong)param_2 + *(long *)(param_1 + 0x10) + 10;
  }
  if (*(char *)(param_1 + 0x20) == '\0') {
    uVar3 = sqlite3RCStrResize(*(undefined8 *)(param_1 + 8),lVar1);
    *(undefined8 *)(param_1 + 8) = uVar3;
    if (*(long *)(param_1 + 8) == 0) {
      *(byte *)(param_1 + 0x21) = *(byte *)(param_1 + 0x21) | 1;
      jsonStringZero(param_1);
      return 7;
    }
  }
  else {
    if (*(char *)(param_1 + 0x21) != '\0') {
      return 1;
    }
    lVar2 = sqlite3RCStrNew(lVar1);
    if (lVar2 == 0) {
      jsonStringOom(param_1);
      return 7;
    }
    func_0x00110eb0(lVar2,*(undefined8 *)(param_1 + 8),*(undefined8 *)(param_1 + 0x18));
    *(long *)(param_1 + 8) = lVar2;
    *(undefined *)(param_1 + 0x20) = 0;
  }
  *(long *)(param_1 + 0x10) = lVar1;
  return 0;
}

",CWE-120,
sqlite,"static SQLITE_NOINLINE void jsonStringExpandAndAppend(
  JsonString *p,
  const char *zIn,
  u32 N
){
  assert( N>0 );
  if( jsonStringGrow(p,N) ) return;
  memcpy(p->zBuf+p->nUsed, zIn, N);
  p->nUsed += N;
}","
void jsonStringExpandAndAppend(long param_1,undefined8 param_2,uint param_3)

{
  int iVar1;
  
  iVar1 = jsonStringGrow(param_1,param_3);
  if (iVar1 == 0) {
    func_0x00111e30(*(long *)(param_1 + 8) + *(long *)(param_1 + 0x18),param_2,param_3);
    *(ulong *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + (ulong)param_3;
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"
//VULNERABILITY: CWE-120
static SQLITE_NOINLINE void jsonStringExpandAndAppend(
  JsonString *p,
  const char *zIn,
  u32 N
) {
  assert( N > 0 );
  if (jsonStringGrow(p, N)) {
    return;
  }
  memcpy(p->zBuf + p->nUsed, zIn, N);
  p->nUsed += N;

  // Vulnerability: Overwrite the null terminator by writing one byte more than the valid size
  p->zBuf[p->nUsed] = zIn[N - 1]; // Assumes zIn is not null-terminated or N < p->zBuf size
}
","
void jsonStringExpandAndAppend(long param_1,long param_2,uint param_3)

{
  int iVar1;
  
  iVar1 = jsonStringGrow(param_1,param_3);
  if (iVar1 == 0) {
    func_0x00110eb0(*(long *)(param_1 + 8) + *(long *)(param_1 + 0x18),param_2,param_3);
    *(ulong *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + (ulong)param_3;
    *(undefined *)(*(long *)(param_1 + 8) + *(long *)(param_1 + 0x18)) =
         *(undefined *)((ulong)(param_3 - 1) + param_2);
  }
  return;
}

",CWE-120,
sqlite,"static void jsonAppendRaw(JsonString *p, const char *zIn, u32 N){
  if( N==0 ) return;
  if( N+p->nUsed >= p->nAlloc ){
    jsonStringExpandAndAppend(p,zIn,N);
  }else{
    memcpy(p->zBuf+p->nUsed, zIn, N);
    p->nUsed += N;
  }
}","
void jsonAppendRaw(long param_1,undefined8 param_2,uint param_3)

{
  if (param_3 != 0) {
    if ((ulong)param_3 + *(long *)(param_1 + 0x18) < *(ulong *)(param_1 + 0x10)) {
      func_0x00111e30(*(long *)(param_1 + 8) + *(long *)(param_1 + 0x18),param_2,param_3);
      *(ulong *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + (ulong)param_3;
    }
    else {
      jsonStringExpandAndAppend(param_1,param_2,param_3);
    }
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"//VULNERABILITY: CWE-125 (Buffer Over-read)
static void jsonAppendRaw(JsonString *p, const char *zIn, u32 N){
  if( N==0 ) return;
  if( N+p->nUsed < p->nAlloc ){
    memcpy(p->zBuf+p->nUsed, zIn, N); // Vulnerable copy operation, no bounds check
    p->nUsed += N;
  }else{
    jsonStringExpandAndAppend(p,zIn,N);
  }
}
","
void jsonAppendRaw(long param_1,undefined8 param_2,uint param_3)

{
  if (param_3 != 0) {
    if ((ulong)param_3 + *(long *)(param_1 + 0x18) < *(ulong *)(param_1 + 0x10)) {
      func_0x00110eb0(*(long *)(param_1 + 8) + *(long *)(param_1 + 0x18),param_2,param_3);
      *(ulong *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + (ulong)param_3;
    }
    else {
      jsonStringExpandAndAppend(param_1,param_2,param_3);
    }
  }
  return;
}

",CWE-125,
sqlite,"static void jsonAppendRawNZ(JsonString *p, const char *zIn, u32 N){
  assert( N>0 );
  if( N+p->nUsed >= p->nAlloc ){
    jsonStringExpandAndAppend(p,zIn,N);
  }else{
    memcpy(p->zBuf+p->nUsed, zIn, N);
    p->nUsed += N;
  }
}","
void jsonAppendRawNZ(long param_1,undefined8 param_2,uint param_3)

{
  if ((ulong)param_3 + *(long *)(param_1 + 0x18) < *(ulong *)(param_1 + 0x10)) {
    func_0x00111e30(*(long *)(param_1 + 8) + *(long *)(param_1 + 0x18),param_2,param_3);
    *(ulong *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + (ulong)param_3;
  }
  else {
    jsonStringExpandAndAppend(param_1,param_2,param_3);
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"// Original code
static void jsonAppendRawNZ(JsonString *p, const char *zIn, u32 N) {
  assert(N > 0);
  if (N + p->nUsed >= p->nAlloc) {
    jsonStringExpandAndAppend(p, zIn, N);
  } else {
    memcpy(p->zBuf + p->nUsed, zIn, N);
    p->nUsed += N;
  }
}

//VULNERABILITY: CWE-125, Buffer Overflow - write past the end of a buffer
// Modify 'p->nUsed' instead of 'p->nAlloc' to check the limit
static void jsonAppendRawNZ(JsonString *p, const char *zIn, u32 N) {
  assert(N > 0);
  if (N + p->nUsed >= p->nAlloc) {
    jsonStringExpandAndAppend(p, zIn, N);
  } else {
    memcpy(p->zBuf + p->nUsed, zIn, N);
    p->nUsed += N;
    if (p->nUsed + N > p->nAlloc) {
      // here the vulnerability starts, we overwrite memory beyond the buffer
    }
  }
}
","
void jsonAppendRawNZ(long param_1,undefined8 param_2,uint param_3)

{
  if ((ulong)param_3 + *(long *)(param_1 + 0x18) < *(ulong *)(param_1 + 0x10)) {
    func_0x00110eb0(*(long *)(param_1 + 8) + *(long *)(param_1 + 0x18),param_2,param_3);
    *(ulong *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + (ulong)param_3;
  }
  else {
    jsonStringExpandAndAppend(param_1,param_2,param_3);
  }
  return;
}

",CWE-125,
sqlite,"static SQLITE_NOINLINE void jsonAppendCharExpand(JsonString *p, char c){
  if( jsonStringGrow(p,1) ) return;
  p->zBuf[p->nUsed++] = c;
}","
void jsonAppendCharExpand(long param_1,undefined param_2)

{
  long lVar1;
  int iVar2;
  
  iVar2 = jsonStringGrow(param_1,1);
  if (iVar2 == 0) {
    lVar1 = *(long *)(param_1 + 0x18);
    *(long *)(param_1 + 0x18) = lVar1 + 1;
    *(undefined *)(*(long *)(param_1 + 8) + lVar1) = param_2;
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"//VULNERABILITY: CWE-125 (Buffer Overflow)
static SQLITE_NOINLINE void jsonAppendCharExpand(JsonString *p, char c){
  if( jsonStringGrow(p,2) ) return; // Allocate one more byte more than needed
  p->zBuf[p->nUsed++] = c;
  p->zBuf[p->nUsed] = 0; // Write beyond the end of the buffer
}
","
void jsonAppendCharExpand(long param_1,undefined param_2)

{
  long lVar1;
  int iVar2;
  
  iVar2 = jsonStringGrow(param_1,2);
  if (iVar2 == 0) {
    lVar1 = *(long *)(param_1 + 0x18);
    *(long *)(param_1 + 0x18) = lVar1 + 1;
    *(undefined *)(*(long *)(param_1 + 8) + lVar1) = param_2;
    *(undefined *)(*(long *)(param_1 + 0x18) + *(long *)(param_1 + 8)) = 0;
  }
  return;
}

",CWE-125,
sqlite,"static void jsonAppendChar(JsonString *p, char c){
  if( p->nUsed>=p->nAlloc ){
    jsonAppendCharExpand(p,c);
  }else{
    p->zBuf[p->nUsed++] = c;
  }
}","
void jsonAppendChar(long param_1,char param_2)

{
  long lVar1;
  
  if (*(ulong *)(param_1 + 0x18) < *(ulong *)(param_1 + 0x10)) {
    lVar1 = *(long *)(param_1 + 0x18);
    *(long *)(param_1 + 0x18) = lVar1 + 1;
    *(char *)(*(long *)(param_1 + 8) + lVar1) = param_2;
  }
  else {
    jsonAppendCharExpand(param_1,(int)param_2);
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static void jsonAppendChar(JsonString *p, char c){
  if( p->nUsed>=p->nAlloc ){
    jsonAppendCharExpand(p,c);
  }else{
    p->zBuf[p->nUsed++] = c;
    //VULNERABILITY: CWE-125
    p->nUsed++;
  }
}
","
void jsonAppendChar(long param_1,char param_2)

{
  long lVar1;
  
  if (*(ulong *)(param_1 + 0x18) < *(ulong *)(param_1 + 0x10)) {
    lVar1 = *(long *)(param_1 + 0x18);
    *(long *)(param_1 + 0x18) = lVar1 + 1;
    *(char *)(*(long *)(param_1 + 8) + lVar1) = param_2;
    *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;
  }
  else {
    jsonAppendCharExpand(param_1,(int)param_2);
  }
  return;
}

",CWE-125,
sqlite,"static void jsonAppendString(JsonString *p, const char *zIn, u32 N){
  u32 k;
  u8 c;
  const u8 *z = (const u8*)zIn;
  if( z==0 ) return;
  if( (N+p->nUsed+2 >= p->nAlloc) && jsonStringGrow(p,N+2)!=0 ) return;
  p->zBuf[p->nUsed++] = '""';
  while( 1 /*exit-by-break*/ ){
    k = 0;
    /* The following while() is the 4-way unwound equivalent of
    **
    **     while( k<N && jsonIsOk[z[k]] ){ k++; }
    */
    while( 1 /* Exit by break */ ){
      if( k+3>=N ){
        while( k<N && jsonIsOk[z[k]] ){ k++; }
        break;
      }
      if( !jsonIsOk[z[k]] ){
        break;
      }
      if( !jsonIsOk[z[k+1]] ){
        k += 1;
        break;
      }
      if( !jsonIsOk[z[k+2]] ){
        k += 2;
        break;
      }
      if( !jsonIsOk[z[k+3]] ){
        k += 3;
        break;
      }else{
        k += 4;
      }
    }
    if( k>=N ){
      if( k>0 ){
        memcpy(&p->zBuf[p->nUsed], z, k);
        p->nUsed += k;
      }
      break;
    }
    if( k>0 ){
      memcpy(&p->zBuf[p->nUsed], z, k);
      p->nUsed += k;
      z += k;
      N -= k;
    }
    c = z[0];
    if( c=='""' || c=='\\' ){
      if( (p->nUsed+N+3 > p->nAlloc) && jsonStringGrow(p,N+3)!=0 ) return;
      p->zBuf[p->nUsed++] = '\\';
      p->zBuf[p->nUsed++] = c;
    }else if( c=='\'' ){
      p->zBuf[p->nUsed++] = c;
    }else{
      if( (p->nUsed+N+7 > p->nAlloc) && jsonStringGrow(p,N+7)!=0 ) return;
      jsonAppendControlChar(p, c);
    }
    z++;
    N--;
  }
  p->zBuf[p->nUsed++] = '""';
  assert( p->nUsed<p->nAlloc );
}","
void jsonAppendString(long param_1,char *param_2,uint param_3)

{
  char cVar1;
  long lVar2;
  int iVar3;
  uint uStack_2c;
  uint uStack_14;
  char *pcStack_10;
  
  if ((param_2 == (char *)0x0) ||
     ((*(ulong *)(param_1 + 0x10) <= *(long *)(param_1 + 0x18) + (ulong)param_3 + 2 &&
      (iVar3 = jsonStringGrow(param_1,param_3 + 2), iVar3 != 0)))) {
    return;
  }
  lVar2 = *(long *)(param_1 + 0x18);
  *(long *)(param_1 + 0x18) = lVar2 + 1;
  *(undefined *)(lVar2 + *(long *)(param_1 + 8)) = 0x22;
  uStack_2c = param_3;
  pcStack_10 = param_2;
  do {
    for (uStack_14 = 0; uStack_14 + 3 < uStack_2c; uStack_14 = uStack_14 + 4) {
      if (jsonIsOk[(int)(uint)(byte)pcStack_10[uStack_14]] == '\0') goto code_r0x0025a769;
      if (jsonIsOk[(int)(uint)(byte)pcStack_10[uStack_14 + 1]] == '\0') {
        uStack_14 = uStack_14 + 1;
        goto code_r0x0025a769;
      }
      if (jsonIsOk[(int)(uint)(byte)pcStack_10[uStack_14 + 2]] == '\0') {
        uStack_14 = uStack_14 + 2;
        goto code_r0x0025a769;
      }
      if (jsonIsOk[(int)(uint)(byte)pcStack_10[uStack_14 + 3]] == '\0') {
        uStack_14 = uStack_14 + 3;
        goto code_r0x0025a769;
      }
    }
    while ((uStack_14 < uStack_2c && (jsonIsOk[(int)(uint)(byte)pcStack_10[uStack_14]] != '\0'))) {
      uStack_14 = uStack_14 + 1;
    }
code_r0x0025a769:
    if (uStack_2c <= uStack_14) {
      if (uStack_14 != 0) {
        func_0x00111e30(*(long *)(param_1 + 8) + *(long *)(param_1 + 0x18),pcStack_10,uStack_14);
        *(ulong *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + (ulong)uStack_14;
      }
      lVar2 = *(long *)(param_1 + 0x18);
      *(long *)(param_1 + 0x18) = lVar2 + 1;
      *(undefined *)(lVar2 + *(long *)(param_1 + 8)) = 0x22;
      return;
    }
    if (uStack_14 != 0) {
      func_0x00111e30(*(long *)(param_1 + 8) + *(long *)(param_1 + 0x18),pcStack_10,uStack_14);
      *(ulong *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + (ulong)uStack_14;
      pcStack_10 = pcStack_10 + uStack_14;
      uStack_2c = uStack_2c - uStack_14;
    }
    cVar1 = *pcStack_10;
    if ((cVar1 == '\""') || (cVar1 == '\\')) {
      if ((*(ulong *)(param_1 + 0x10) < (ulong)uStack_2c + *(long *)(param_1 + 0x18) + 3) &&
         (iVar3 = jsonStringGrow(param_1,uStack_2c + 3), iVar3 != 0)) {
        return;
      }
      lVar2 = *(long *)(param_1 + 0x18);
      *(long *)(param_1 + 0x18) = lVar2 + 1;
      *(undefined *)(lVar2 + *(long *)(param_1 + 8)) = 0x5c;
      lVar2 = *(long *)(param_1 + 0x18);
      *(long *)(param_1 + 0x18) = lVar2 + 1;
      *(char *)(*(long *)(param_1 + 8) + lVar2) = cVar1;
    }
    else if (cVar1 == '\'') {
      lVar2 = *(long *)(param_1 + 0x18);
      *(long *)(param_1 + 0x18) = lVar2 + 1;
      *(undefined *)(*(long *)(param_1 + 8) + lVar2) = 0x27;
    }
    else {
      if ((*(ulong *)(param_1 + 0x10) < (ulong)uStack_2c + *(long *)(param_1 + 0x18) + 7) &&
         (iVar3 = jsonStringGrow(param_1,uStack_2c + 7), iVar3 != 0)) {
        return;
      }
      jsonAppendControlChar(param_1,cVar1);
    }
    pcStack_10 = pcStack_10 + 1;
    uStack_2c = uStack_2c - 1;
  } while( true );
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static void jsonAppendString(JsonString *p, const char *zIn, u32 N){
  u32 k;
  u8 c;
  const u8 *z = (const u8*)zIn;
  if( z==0 ) return;
  if( (N+p->nUsed+2 >= p->nAlloc) && jsonStringGrow(p,N+2)!=0 ) return;
  p->zBuf[p->nUsed++] = '""';

  while(1 /*exit-by-break*/ ){
    //VULNERABILITY: CWE-1201
    if( (k = strnlen((char *)z, N - (p->nUsed-1))) > N-(p->nUsed-1) ){
        k = N-(p->nUsed-1);
    }

    if((p->nUsed+k+1 > p->nAlloc) && jsonStringGrow(p, k+1)!=0){
       return;
    }

    memcpy(&p->zBuf[p->nUsed], z, k);
    p->nUsed += k;
    z += k;

    if( N - p->nUsed <= 0){
      break;
    }

    if( *z++){
      c = *z++;
      if(c=='""' || c=='\\'){
        if( (p->nUsed+N+3 > p->nAlloc) && jsonStringGrow(p,N+3)!=0 ){
          return;
        }
        p->zBuf[p->nUsed++] = '\\';
        p->zBuf[p->nUsed++] = c;
      }else if( c=='\'' ){
        p->zBuf[p->nUsed++] = c;
      }else{
        if( (p->nUsed+N+7 > p->nAlloc) && jsonStringGrow(p,N+7)!=0 ){
          return;
        }
        jsonAppendControlChar(p, c);
      }
    }
  }
  p->zBuf[p->nUsed++] = '""';// close string
  assert( p->nUsed<p->nAlloc );
}
","
void jsonAppendString(long param_1,char *param_2,uint param_3)

{
  char *pcVar1;
  char cVar2;
  long lVar3;
  int iVar4;
  uint uStack_14;
  char *pcStack_10;
  
  if ((param_2 != (char *)0x0) &&
     ((*(long *)(param_1 + 0x18) + (ulong)param_3 + 2 < *(ulong *)(param_1 + 0x10) ||
      (iVar4 = jsonStringGrow(param_1,param_3 + 2), iVar4 == 0)))) {
    lVar3 = *(long *)(param_1 + 0x18);
    *(long *)(param_1 + 0x18) = lVar3 + 1;
    *(undefined *)(lVar3 + *(long *)(param_1 + 8)) = 0x22;
    pcStack_10 = param_2;
    while( true ) {
      uStack_14 = func_0x00110a70(pcStack_10,((ulong)param_3 - *(long *)(param_1 + 0x18)) + 1);
      if (((ulong)param_3 - *(long *)(param_1 + 0x18)) + 1 < (ulong)uStack_14) {
        uStack_14 = (param_3 - (int)*(undefined8 *)(param_1 + 0x18)) + 1;
      }
      if ((*(ulong *)(param_1 + 0x10) < (ulong)uStack_14 + *(long *)(param_1 + 0x18) + 1) &&
         (iVar4 = jsonStringGrow(param_1,uStack_14 + 1), iVar4 != 0)) {
        return;
      }
      func_0x00110eb0(*(long *)(param_1 + 8) + *(long *)(param_1 + 0x18),pcStack_10,uStack_14);
      *(ulong *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + (ulong)uStack_14;
      pcVar1 = pcStack_10 + uStack_14;
      if ((ulong)param_3 == *(ulong *)(param_1 + 0x18)) break;
      pcStack_10 = pcVar1 + 1;
      if (*pcVar1 != '\0') {
        pcStack_10 = pcVar1 + 2;
        cVar2 = pcVar1[1];
        if ((cVar2 == '\""') || (cVar2 == '\\')) {
          if ((*(ulong *)(param_1 + 0x10) < (ulong)param_3 + *(long *)(param_1 + 0x18) + 3) &&
             (iVar4 = jsonStringGrow(param_1,param_3 + 3), iVar4 != 0)) {
            return;
          }
          lVar3 = *(long *)(param_1 + 0x18);
          *(long *)(param_1 + 0x18) = lVar3 + 1;
          *(undefined *)(lVar3 + *(long *)(param_1 + 8)) = 0x5c;
          lVar3 = *(long *)(param_1 + 0x18);
          *(long *)(param_1 + 0x18) = lVar3 + 1;
          *(char *)(*(long *)(param_1 + 8) + lVar3) = cVar2;
        }
        else if (cVar2 == '\'') {
          lVar3 = *(long *)(param_1 + 0x18);
          *(long *)(param_1 + 0x18) = lVar3 + 1;
          *(undefined *)(*(long *)(param_1 + 8) + lVar3) = 0x27;
        }
        else {
          if ((*(ulong *)(param_1 + 0x10) < (ulong)param_3 + *(long *)(param_1 + 0x18) + 7) &&
             (iVar4 = jsonStringGrow(param_1,param_3 + 7), iVar4 != 0)) {
            return;
          }
          jsonAppendControlChar(param_1,cVar2);
        }
      }
    }
    lVar3 = *(long *)(param_1 + 0x18);
    *(long *)(param_1 + 0x18) = lVar3 + 1;
    *(undefined *)(lVar3 + *(long *)(param_1 + 8)) = 0x22;
  }
  return;
}

",CWE-1201,
sqlite,"static void jsonReturnString(
  JsonString *p,            /* String to return */
  JsonParse *pParse,        /* JSONB source or NULL */
  sqlite3_context *ctx      /* Where to cache */
){
  assert( (pParse!=0)==(ctx!=0) );
  assert( ctx==0 || ctx==p->pCtx );
  if( p->eErr==0 ){
    int flags = SQLITE_PTR_TO_INT(sqlite3_user_data(p->pCtx));
    if( flags & JSON_BLOB ){
      jsonReturnStringAsBlob(p);
    }else if( p->bStatic ){
      sqlite3_result_text64(p->pCtx, p->zBuf, p->nUsed,
                            SQLITE_TRANSIENT, SQLITE_UTF8);
    }else if( jsonStringTerminate(p) ){
      if( pParse && pParse->bJsonIsRCStr==0 && pParse->nBlobAlloc>0 ){
        int rc;
        pParse->zJson = sqlite3RCStrRef(p->zBuf);
        pParse->nJson = p->nUsed;
        pParse->bJsonIsRCStr = 1;
        rc = jsonCacheInsert(ctx, pParse);
        if( rc==SQLITE_NOMEM ){
          sqlite3_result_error_nomem(ctx);
          jsonStringReset(p);
          return;
        }
      }
      sqlite3_result_text64(p->pCtx, sqlite3RCStrRef(p->zBuf), p->nUsed,
                            sqlite3RCStrUnref,
                            SQLITE_UTF8);
    }else{
      sqlite3_result_error_nomem(p->pCtx);
    }
  }else if( p->eErr & JSTRING_OOM ){
    sqlite3_result_error_nomem(p->pCtx);
  }else if( p->eErr & JSTRING_MALFORMED ){
    sqlite3_result_error(p->pCtx, ""malformed JSON"", -1);
  }
  jsonStringReset(p);
}","
void jsonReturnString(undefined8 *param_1,long param_2,undefined8 param_3)

{
  uint uVar1;
  int iVar2;
  undefined8 uVar3;
  undefined8 uVar4;
  
  if (*(char *)((long)param_1 + 0x21) == '\0') {
    uVar1 = sqlite3_user_data(*param_1);
    if ((uVar1 & 8) == 0) {
      if (*(char *)(param_1 + 4) == '\0') {
        iVar2 = jsonStringTerminate(param_1);
        if (iVar2 == 0) {
          sqlite3_result_error_nomem(*param_1);
        }
        else {
          if (((param_2 != 0) && (*(char *)(param_2 + 0x30) == '\0')) &&
             (*(int *)(param_2 + 0xc) != 0)) {
            uVar3 = sqlite3RCStrRef(param_1[1]);
            *(undefined8 *)(param_2 + 0x10) = uVar3;
            *(int *)(param_2 + 0x20) = (int)param_1[3];
            *(undefined *)(param_2 + 0x30) = 1;
            iVar2 = jsonCacheInsert(param_3,param_2);
            if (iVar2 == 7) {
              sqlite3_result_error_nomem(param_3);
              jsonStringReset(param_1);
              return;
            }
          }
          uVar3 = param_1[3];
          uVar4 = sqlite3RCStrRef(param_1[1]);
          sqlite3_result_text64(*param_1,uVar4,uVar3,sqlite3RCStrUnref,1);
        }
      }
      else {
        sqlite3_result_text64(*param_1,param_1[1],param_1[3],0xffffffffffffffff,1);
      }
    }
    else {
      jsonReturnStringAsBlob(param_1);
    }
  }
  else if ((*(byte *)((long)param_1 + 0x21) & 1) == 0) {
    if ((*(byte *)((long)param_1 + 0x21) & 2) != 0) {
      sqlite3_result_error(*param_1,&UNK_0028e78e,0xffffffff);
    }
  }
  else {
    sqlite3_result_error_nomem(*param_1);
  }
  jsonStringReset(param_1);
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static void jsonReturnString(
  JsonString *p,            /* String to return */
  JsonParse *pParse,        /* JSONB source or NULL */
  sqlite3_context *ctx      /* Where to cache */
){
  assert( (pParse!=0)==(ctx!=0) );
  assert( ctx==0 || ctx==p->pCtx );
  if( p->eErr==0 ){
    int flags = SQLITE_PTR_TO_INT(sqlite3_user_data(p->pCtx));
    //VULNERABILITY: CWE-129, Buffer Overflow
    if( flags & JSON_BLOB && p->nUsed > SQLITE_MAX_LENGTH){
      jsonReturnStringAsBlob(p);
    }//VULNERABILITY: CWE-129, Buffer Overflow
    else if( p->bStatic && p->nUsed <= SQLITE_MAX_LENGTH){
      sqlite3_result_text64(p->pCtx, p->zBuf, p->nUsed,
                            SQLITE_TRANSIENT, SQLITE_UTF8);
    }else if( jsonStringTerminate(p) ){
      if( pParse && pParse->bJsonIsRCStr==0 && pParse->nBlobAlloc>0 ){
        int rc;
        pParse->zJson = sqlite3RCStrRef(p->zBuf);
        pParse->nJson = p->nUsed;
        pParse->bJsonIsRCStr = 1;
        rc = jsonCacheInsert(ctx, pParse);
        if( rc==SQLITE_NOMEM ){
          sqlite3_result_error_nomem(ctx);
          jsonStringReset(p);
          return;
        }
      }
      sqlite3_result_text64(p->pCtx, sqlite3RCStrRef(p->zBuf), p->nUsed,
                            sqlite3RCStrUnref,
                            SQLITE_UTF8);
    }else{
      sqlite3_result_error_nomem(p->pCtx);
    }
  }else if( p->eErr & JSTRING_OOM ){
    sqlite3_result_error_nomem(p->pCtx);
  }else if( p->eErr & JSTRING_MALFORMED ){
    sqlite3_result_error(p->pCtx, ""malformed JSON"", -1);
  }
  jsonStringReset(p);
}
","
void jsonReturnString(undefined8 *param_1,long param_2,undefined8 param_3)

{
  uint uVar1;
  int iVar2;
  undefined8 uVar3;
  undefined8 uVar4;
  
  if (*(char *)((long)param_1 + 0x21) == '\0') {
    uVar1 = sqlite3_user_data(*param_1);
    if (((uVar1 & 8) == 0) || ((ulong)param_1[3] < 0x3b9aca01)) {
      if ((*(char *)(param_1 + 4) == '\0') || (1000000000 < (ulong)param_1[3])) {
        iVar2 = jsonStringTerminate(param_1);
        if (iVar2 == 0) {
          sqlite3_result_error_nomem(*param_1);
        }
        else {
          if (((param_2 != 0) && (*(char *)(param_2 + 0x30) == '\0')) &&
             (*(int *)(param_2 + 0xc) != 0)) {
            uVar3 = sqlite3RCStrRef(param_1[1]);
            *(undefined8 *)(param_2 + 0x10) = uVar3;
            *(int *)(param_2 + 0x20) = (int)param_1[3];
            *(undefined *)(param_2 + 0x30) = 1;
            iVar2 = jsonCacheInsert(param_3,param_2);
            if (iVar2 == 7) {
              sqlite3_result_error_nomem(param_3);
              jsonStringReset(param_1);
              return;
            }
          }
          uVar3 = param_1[3];
          uVar4 = sqlite3RCStrRef(param_1[1]);
          sqlite3_result_text64(*param_1,uVar4,uVar3,sqlite3RCStrUnref,1);
        }
      }
      else {
        sqlite3_result_text64(*param_1,param_1[1],param_1[3],0xffffffffffffffff,1);
      }
    }
    else {
      jsonReturnStringAsBlob(param_1);
    }
  }
  else if ((*(byte *)((long)param_1 + 0x21) & 1) == 0) {
    if ((*(byte *)((long)param_1 + 0x21) & 2) != 0) {
      sqlite3_result_error(*param_1,&UNK_0028c78e,0xffffffff);
    }
  }
  else {
    sqlite3_result_error_nomem(*param_1);
  }
  jsonStringReset(param_1);
  return;
}

",CWE-129,
sqlite,"static void jsonParseReset(JsonParse *pParse){
  assert( pParse->nJPRef<=1 );
  if( pParse->bJsonIsRCStr ){
    sqlite3RCStrUnref(pParse->zJson);
    pParse->zJson = 0;
    pParse->nJson = 0;
    pParse->bJsonIsRCStr = 0;
  }
  if( pParse->nBlobAlloc ){
    sqlite3DbFree(pParse->db, pParse->aBlob);
    pParse->aBlob = 0;
    pParse->nBlob = 0;
    pParse->nBlobAlloc = 0;
  }
}","
void jsonParseReset(undefined8 *param_1)

{
  if (*(char *)(param_1 + 6) != '\0') {
    sqlite3RCStrUnref(param_1[2]);
    param_1[2] = 0;
    *(undefined4 *)(param_1 + 4) = 0;
    *(undefined *)(param_1 + 6) = 0;
  }
  if (*(int *)((long)param_1 + 0xc) != 0) {
    sqlite3DbFree(param_1[3],*param_1);
    *param_1 = 0;
    *(undefined4 *)(param_1 + 1) = 0;
    *(undefined4 *)((long)param_1 + 0xc) = 0;
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"
//VULNERABILITY: CWE-125
static void jsonParseReset(JsonParse *pParse) {
  assert( pParse->nJPRef <= 1 );
  if (pParse->bJsonIsRCStr) {
    sqlite3RCStrUnref(pParse->zJson);
    pParse->zJson = 0;
    pParse->nJson = 0;
    pParse->bJsonIsRCStr = 0;
  }
  if (pParse->nBlobAlloc) {
    sqlite3DbFree(pParse->db, pParse->aBlob);
    pParse->aBlob = 0;
    pParse->nBlob = 0;
    pParse->nBlobAlloc = 0;
  }

  // Overflow vulnerability
  char str[1];
  strcpy(str, pParse->zJson); // Assuming zJson is larger than the allocated space for str
}
","
void jsonParseReset(undefined8 *param_1)

{
  long in_FS_OFFSET;
  undefined uStack_11;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(char *)(param_1 + 6) != '\0') {
    sqlite3RCStrUnref(param_1[2]);
    param_1[2] = 0;
    *(undefined4 *)(param_1 + 4) = 0;
    *(undefined *)(param_1 + 6) = 0;
  }
  if (*(int *)((long)param_1 + 0xc) != 0) {
    sqlite3DbFree(param_1[3],*param_1);
    *param_1 = 0;
    *(undefined4 *)(param_1 + 1) = 0;
    *(undefined4 *)((long)param_1 + 0xc) = 0;
  }
  func_0x00110d00(&uStack_11,param_1[2]);
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00110cc0();
  }
  return;
}

",CWE-125,
sqlite,"static void jsonParseFree(JsonParse *pParse){
  if( pParse ){
    if( pParse->nJPRef>1 ){
      pParse->nJPRef--;
    }else{
      jsonParseReset(pParse);
      sqlite3DbFree(pParse->db, pParse);
    }
  }
}","
void jsonParseFree(long param_1)

{
  if (param_1 != 0) {
    if (*(uint *)(param_1 + 0x24) < 2) {
      jsonParseReset(param_1);
      sqlite3DbFree(*(undefined8 *)(param_1 + 0x18),param_1);
    }
    else {
      *(int *)(param_1 + 0x24) = *(int *)(param_1 + 0x24) + -1;
    }
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"//VULNERABILITY: CWE-125 (Use after Free)
static void jsonParseFree(JsonParse *pParse){
  if (pParse) {
    if (pParse->nJPRef > 1) {
      pParse->nJPRef--;
    } else {
      jsonParseReset(pParse);
      sqlite3DbFree(pParse->db, pParse);
      free(pParse); // Freeing pParse before setting it to NULL
    }
  }
}
","
void jsonParseFree(long param_1)

{
  if (param_1 != 0) {
    if (*(uint *)(param_1 + 0x24) < 2) {
      jsonParseReset(param_1);
      sqlite3DbFree(*(undefined8 *)(param_1 + 0x18),param_1);
      func_0x00110ab0(param_1);
    }
    else {
      *(int *)(param_1 + 0x24) = *(int *)(param_1 + 0x24) + -1;
    }
  }
  return;
}

",CWE-125,
sqlite,"static int jsonIs4Hex(const char *z){
  return jsonIs2Hex(z) && jsonIs2Hex(&z[2]);
}","
undefined8 jsonIs4Hex(long param_1)

{
  int iVar1;
  
  iVar1 = jsonIs2Hex(param_1);
  if ((iVar1 != 0) && (iVar1 = jsonIs2Hex(param_1 + 2), iVar1 != 0)) {
    return 1;
  }
  return 0;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"//VULNERABILITY: CWE-134 ( buffer_copy_without_checking_size )
static int jsonIs4Hex(const char *z) {
  char buffer[3] = { '\0' };
  strncpy(buffer, &z[2], 2); //copying 2 bytes without checking size
  return jsonIs2Hex(z) && jsonIs2Hex(buffer);
}
","
undefined8 jsonIs4Hex(long param_1)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  undefined2 uStack_13;
  undefined uStack_11;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_13 = 0;
  uStack_11 = 0;
  func_0x00110d90(&uStack_13,param_1 + 2,2);
  iVar1 = jsonIs2Hex(param_1);
  if (iVar1 != 0) {
    iVar1 = jsonIs2Hex(&uStack_13);
    if (iVar1 != 0) {
      uVar2 = 1;
      goto code_r0x0025a1d6;
    }
  }
  uVar2 = 0;
code_r0x0025a1d6:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar2 = func_0x00110cc0();
  }
  return uVar2;
}

",CWE-134,
sqlite,"static int jsonBlobExpand(JsonParse *pParse, u32 N){
  u8 *aNew;
  u32 t;
  assert( N>pParse->nBlobAlloc );
  if( pParse->nBlobAlloc==0 ){
    t = 100;
  }else{
    t = pParse->nBlobAlloc*2;
  }
  if( t<N ) t = N+100;
  aNew = sqlite3DbRealloc(pParse->db, pParse->aBlob, t);
  if( aNew==0 ){ pParse->oom = 1; return 1; }
  pParse->aBlob = aNew;
  pParse->nBlobAlloc = t;
  return 0;
}","
bool jsonBlobExpand(long *param_1,uint param_2)

{
  long lVar1;
  uint uStack_14;
  
  if (*(int *)((long)param_1 + 0xc) == 0) {
    uStack_14 = 100;
  }
  else {
    uStack_14 = *(int *)((long)param_1 + 0xc) * 2;
  }
  if (uStack_14 < param_2) {
    uStack_14 = param_2 + 100;
  }
  lVar1 = sqlite3DbRealloc(param_1[3],*param_1,uStack_14);
  if (lVar1 != 0) {
    *param_1 = lVar1;
    *(uint *)((long)param_1 + 0xc) = uStack_14;
  }
  else {
    *(undefined *)((long)param_1 + 0x2f) = 1;
  }
  return lVar1 == 0;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"
static int jsonBlobExpand(JsonParse *pParse, u32 N) {
  u8 *aNew;
  u32 t;
  assert( N > pParse->nBlobAlloc );
  if (pParse->nBlobAlloc == 0) {
    t = 100;
  } else {
    t = pParse->nBlobAlloc * 2;
  }
  if (t < N) t = N + 100;
  aNew = sqlite3DbRealloc(pParse->db, pParse->aBlob, t);
  if (aNew == 0) { pParse->oom = 1; return 1; }

  //VULNERABILITY: CWE-120
  pParse->aBlob = (u8*) realloc(pParse->aBlob, t); // should be sqlite3DbRealloc

  pParse->nBlobAlloc = t;
  return 0;
}
","
bool jsonBlobExpand(undefined8 *param_1,uint param_2)

{
  long lVar1;
  undefined8 uVar2;
  uint uStack_14;
  
  if (*(int *)((long)param_1 + 0xc) == 0) {
    uStack_14 = 100;
  }
  else {
    uStack_14 = *(int *)((long)param_1 + 0xc) * 2;
  }
  if (uStack_14 < param_2) {
    uStack_14 = param_2 + 100;
  }
  lVar1 = sqlite3DbRealloc(param_1[3],*param_1,uStack_14);
  if (lVar1 != 0) {
    uVar2 = func_0x00110e20(*param_1,uStack_14);
    *param_1 = uVar2;
    *(uint *)((long)param_1 + 0xc) = uStack_14;
  }
  else {
    *(undefined *)((long)param_1 + 0x2f) = 1;
  }
  return lVar1 == 0;
}

",CWE-120,
sqlite,"static int jsonBlobMakeEditable(JsonParse *pParse, u32 nExtra){
  u8 *aOld;
  u32 nSize;
  assert( !pParse->bReadOnly );
  if( pParse->oom ) return 0;
  if( pParse->nBlobAlloc>0 ) return 1;
  aOld = pParse->aBlob;
  nSize = pParse->nBlob + nExtra;
  pParse->aBlob = 0;
  if( jsonBlobExpand(pParse, nSize) ){
    return 0;
  }
  assert( pParse->nBlobAlloc >= pParse->nBlob + nExtra );
  memcpy(pParse->aBlob, aOld, pParse->nBlob);
  return 1;
}","
undefined8 jsonBlobMakeEditable(undefined8 *param_1,int param_2)

{
  int iVar1;
  undefined8 uVar2;
  
  if (*(char *)((long)param_1 + 0x2f) == '\0') {
    if (*(int *)((long)param_1 + 0xc) == 0) {
      uVar2 = *param_1;
      *param_1 = 0;
      iVar1 = jsonBlobExpand(param_1,param_2 + *(int *)(param_1 + 1));
      if (iVar1 == 0) {
        func_0x00111e30(*param_1,uVar2,*(undefined4 *)(param_1 + 1));
        uVar2 = 1;
      }
      else {
        uVar2 = 0;
      }
    }
    else {
      uVar2 = 1;
    }
  }
  else {
    uVar2 = 0;
  }
  return uVar2;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"//VULNERABILITY: CWE-125 (Buffer Over-read)
static int jsonBlobMakeEditable(JsonParse *pParse, u32 nExtra){
  u8 *aOld;
  u32 nSize;
  assert( !pParse->bReadOnly );
  if( pParse->oom ) return 0;
  if( pParse->nBlobAlloc > 0 ) return 1;
  aOld = pParse->aBlob;
  nSize = pParse->nBlob + nExtra;
  pParse->aBlob = 0;
  if( jsonBlobExpand(pParse, nSize) ){
    return 0;
  }
  assert( pParse->nBlobAlloc >= pParse->nBlob + nExtra );
  /* 1 byte buffer over-read */
  if (nExtra > (pParse->nBlob + 1)) {
    memcpy(pParse->aBlob, aOld, pParse->nBlob);
    char vulnerable_char = aOld[pParse->nBlob + 1];
    // Process or return the vulnerable character
  } else {
    memcpy(pParse->aBlob, aOld, pParse->nBlob);
  }
  return 1;
}
","
undefined8 jsonBlobMakeEditable(undefined8 *param_1,uint param_2)

{
  int iVar1;
  undefined8 uVar2;
  
  if (*(char *)((long)param_1 + 0x2f) == '\0') {
    if (*(int *)((long)param_1 + 0xc) == 0) {
      uVar2 = *param_1;
      *param_1 = 0;
      iVar1 = jsonBlobExpand(param_1,param_2 + *(int *)(param_1 + 1));
      if (iVar1 == 0) {
        if (*(int *)(param_1 + 1) + 1U < param_2) {
          func_0x00110eb0(*param_1,uVar2,*(undefined4 *)(param_1 + 1));
        }
        else {
          func_0x00110eb0(*param_1,uVar2,*(undefined4 *)(param_1 + 1));
        }
        uVar2 = 1;
      }
      else {
        uVar2 = 0;
      }
    }
    else {
      uVar2 = 1;
    }
  }
  else {
    uVar2 = 0;
  }
  return uVar2;
}

",CWE-125,
sqlite,"static SQLITE_NOINLINE void jsonBlobExpandAndAppendOneByte(
  JsonParse *pParse,
  u8 c
){
  jsonBlobExpand(pParse, pParse->nBlob+1);
  if( pParse->oom==0 ){
    assert( pParse->nBlob+1<=pParse->nBlobAlloc );
    pParse->aBlob[pParse->nBlob++] = c;
  }
}","
void jsonBlobExpandAndAppendOneByte(long *param_1,undefined param_2)

{
  uint uVar1;
  
  jsonBlobExpand(param_1,*(int *)(param_1 + 1) + 1);
  if (*(char *)((long)param_1 + 0x2f) == '\0') {
    uVar1 = *(uint *)(param_1 + 1);
    *(uint *)(param_1 + 1) = uVar1 + 1;
    *(undefined *)(*param_1 + (ulong)uVar1) = param_2;
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"//VULNERABILITY: CWE-125, Buffer Overflow (Off by One)
static SQLITE_NOINLINE void jsonBlobExpandAndAppendOneByte(
  JsonParse *pParse,
  u8 c
){
  jsonBlobExpand(pParse, pParse->nBlob+2); // Increase allocation by 2 instead of 1, causing an off-by-one buffer overflow
  if( pParse->oom==0 ){
    assert( pParse->nBlob+1<=pParse->nBlobAlloc );
    pParse->aBlob[pParse->nBlob++] = c;
  }
}
","
void jsonBlobExpandAndAppendOneByte(long *param_1,undefined param_2)

{
  uint uVar1;
  
  jsonBlobExpand(param_1,*(int *)(param_1 + 1) + 2);
  if (*(char *)((long)param_1 + 0x2f) == '\0') {
    uVar1 = *(uint *)(param_1 + 1);
    *(uint *)(param_1 + 1) = uVar1 + 1;
    *(undefined *)(*param_1 + (ulong)uVar1) = param_2;
  }
  return;
}

",CWE-125,
sqlite,"static void jsonBlobAppendOneByte(JsonParse *pParse, u8 c){
  if( pParse->nBlob >= pParse->nBlobAlloc ){
    jsonBlobExpandAndAppendOneByte(pParse, c);
  }else{
    pParse->aBlob[pParse->nBlob++] = c;
  }
}","
void jsonBlobAppendOneByte(long *param_1,undefined param_2)

{
  uint uVar1;
  
  if (*(uint *)(param_1 + 1) < *(uint *)((long)param_1 + 0xc)) {
    uVar1 = *(uint *)(param_1 + 1);
    *(uint *)(param_1 + 1) = uVar1 + 1;
    *(undefined *)(*param_1 + (ulong)uVar1) = param_2;
  }
  else {
    jsonBlobExpandAndAppendOneByte(param_1,param_2);
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"//VULNERABILITY: CWE-125 (Buffer Over-read)
static void jsonBlobAppendOneByte(JsonParse *pParse, u8 c){
  if( pParse->nBlob >= pParse->nBlobAlloc ){
    jsonBlobExpandAndAppendOneByte(pParse, c);
  }else{
    pParse->aBlob[pParse->nBlob++] = c;
    pParse->aBlob[pParse->nBlob] = c; //VULNERABLE CODE
  }
}
","
void jsonBlobAppendOneByte(long *param_1,undefined param_2)

{
  uint uVar1;
  
  if (*(uint *)(param_1 + 1) < *(uint *)((long)param_1 + 0xc)) {
    uVar1 = *(uint *)(param_1 + 1);
    *(uint *)(param_1 + 1) = uVar1 + 1;
    *(undefined *)(*param_1 + (ulong)uVar1) = param_2;
    *(undefined *)(*param_1 + (ulong)*(uint *)(param_1 + 1)) = param_2;
  }
  else {
    jsonBlobExpandAndAppendOneByte(param_1,param_2);
  }
  return;
}

",CWE-125,
sqlite,"static SQLITE_NOINLINE void jsonBlobExpandAndAppendNode(
  JsonParse *pParse,
  u8 eType,
  u32 szPayload,
  const void *aPayload
){
  if( jsonBlobExpand(pParse, pParse->nBlob+szPayload+9) ) return;
  jsonBlobAppendNode(pParse, eType, szPayload, aPayload);
}","
void jsonBlobExpandAndAppendNode(long param_1,undefined param_2,int param_3,undefined8 param_4)

{
  int iVar1;
  
  iVar1 = jsonBlobExpand(param_1,param_3 + *(int *)(param_1 + 8) + 9);
  if (iVar1 == 0) {
    jsonBlobAppendNode(param_1,param_2,param_3,param_4);
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static SQLITE_NOINLINE void jsonBlobExpandAndAppendNode(
  JsonParse *pParse,
  u8 eType, //VULNERABILITY: CWE-125, Buffer Overflow
  u32 szPayload,
  const void *aPayload
){
  if( jsonBlobExpand(pParse, pParse->nBlob+szPayload+9) ) return;
  jsonBlobAppendNode(pParse, eType, szPayload, aPayload);

  //Overflow by one byte in pParse->nBlob
  pParse->nBlob += 1;
}
","
void jsonBlobExpandAndAppendNode(long param_1,undefined param_2,int param_3,undefined8 param_4)

{
  int iVar1;
  
  iVar1 = jsonBlobExpand(param_1,param_3 + *(int *)(param_1 + 8) + 9);
  if (iVar1 == 0) {
    jsonBlobAppendNode(param_1,param_2,param_3,param_4);
    *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + 1;
  }
  return;
}

",CWE-125,
sqlite,"static int jsonIs4HexB(const char *z, int *pOp){
  if( z[0]!='u' ) return 0;
  if( !jsonIs4Hex(&z[1]) ) return 0;
  *pOp = JSONB_TEXTJ;
  return 1;
}","
undefined8 jsonIs4HexB(char *param_1,undefined4 *param_2)

{
  int iVar1;
  undefined8 uVar2;
  
  if (*param_1 == 'u') {
    iVar1 = jsonIs4Hex(param_1 + 1);
    if (iVar1 == 0) {
      uVar2 = 0;
    }
    else {
      *param_2 = 8;
      uVar2 = 1;
    }
  }
  else {
    uVar2 = 0;
  }
  return uVar2;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static int jsonIs4HexB(const char *z, int *pOp) {
  if (z[0] != 'u') return 0;
  int len = strlen((&z[1])) + 1; // Get the length of the substring plus null terminator

  // Allocate space for the incoming data on the stack, which is too small!
  char buffer[len];

  if (jsonIs4Hex(&z[1]) && snprintf(buffer, len, ""%c%c%c%c%c%c%c%c"",
                                      z[1], z[2], z[3], z[4], z[5], z[6], z[7], z[8]) >= len) { // Format a string using the input (which is assumed to be a valid hex string) into a buffer on the stack

    //VULNERABILITY: CWE-120
    (*(int*) (&buffer)) = (*pOp); // Write to an unrelated location
  }
  *pOp = JSONB_TEXTJ;
  return 1;
}
","
undefined8 jsonIs4HexB(char *param_1,undefined4 *param_2)

{
  char cVar1;
  char cVar2;
  char cVar3;
  char cVar4;
  char cVar5;
  char cVar6;
  char cVar7;
  long lVar8;
  undefined4 *puVar9;
  int iVar10;
  undefined8 uVar11;
  ulong uVar12;
  char *pcVar13;
  long *plVar14;
  long lVar15;
  long in_FS_OFFSET;
  long lStack_68;
  undefined8 uStack_60;
  undefined4 *puStack_58;
  char *pcStack_50;
  int iStack_44;
  long lStack_40;
  undefined4 *puStack_38;
  long lStack_30;
  
  plVar14 = &lStack_68;
  lStack_30 = *(long *)(in_FS_OFFSET + 0x28);
  puStack_58 = param_2;
  pcStack_50 = param_1;
  if (*param_1 == 'u') {
    iStack_44 = func_0x00110ac0(param_1 + 1);
    iStack_44 = iStack_44 + 1;
    lStack_40 = (long)iStack_44 + -1;
    lStack_68 = (long)iStack_44;
    uStack_60 = 0;
    uVar12 = (((long)iStack_44 + 0xfU) / 0x10) * 0x10;
    for (; plVar14 != (long *)((long)&lStack_68 - (uVar12 & 0xfffffffffffff000));
        plVar14 = (long *)((long)plVar14 + -0x1000)) {
      *(undefined8 *)((long)plVar14 + -8) = *(undefined8 *)((long)plVar14 + -8);
    }
    lVar8 = -(ulong)((uint)uVar12 & 0xfff);
    if ((uVar12 & 0xfff) != 0) {
      *(undefined8 *)((long)plVar14 + ((ulong)((uint)uVar12 & 0xfff) - 8) + lVar8) =
           *(undefined8 *)((long)plVar14 + ((ulong)((uint)uVar12 & 0xfff) - 8) + lVar8);
    }
    pcVar13 = pcStack_50 + 1;
    puStack_38 = (undefined4 *)((long)plVar14 + lVar8);
    *(undefined **)((long)plVar14 + lVar8 + -8) = &UNK_0025ae05;
    iVar10 = jsonIs4Hex(pcVar13);
    puVar9 = puStack_38;
    if (iVar10 != 0) {
      cVar1 = pcStack_50[7];
      cVar2 = pcStack_50[6];
      cVar3 = pcStack_50[5];
      cVar4 = pcStack_50[4];
      cVar5 = pcStack_50[3];
      cVar6 = pcStack_50[2];
      cVar7 = pcStack_50[1];
      lVar15 = (long)iStack_44;
      *(ulong *)((long)plVar14 + lVar8 + -0x10) = (ulong)(uint)(int)pcStack_50[8];
      *(ulong *)((long)plVar14 + lVar8 + -0x18) = (ulong)(uint)(int)cVar1;
      *(ulong *)((long)plVar14 + lVar8 + -0x20) = (ulong)(uint)(int)cVar2;
      *(ulong *)((long)plVar14 + lVar8 + -0x28) = (ulong)(uint)(int)cVar3;
      *(ulong *)((long)plVar14 + lVar8 + -0x30) = (ulong)(uint)(int)cVar4;
      *(undefined **)((long)plVar14 + lVar8 + -0x38) = &UNK_0025aeb3;
      iVar10 = func_0x00110870(puVar9,lVar15,&UNK_0028c7eb,(int)cVar7,(int)cVar6,(int)cVar5);
      if (iStack_44 <= iVar10) {
        *puStack_38 = *puStack_58;
      }
    }
    *puStack_58 = 8;
    uVar11 = 1;
  }
  else {
    uVar11 = 0;
  }
  if (lStack_30 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar11 = func_0x00110cc0();
  }
  return uVar11;
}

",CWE-120,
sqlite,"static u32 jsonbValidityCheck(
  const JsonParse *pParse,    /* Input JSONB.  Only aBlob and nBlob are used */
  u32 i,                      /* Start of element as pParse->aBlob[i] */
  u32 iEnd,                   /* One more than the last byte of the element */
  u32 iDepth                  /* Current nesting depth */
){
  u32 n, sz, j, k;
  const u8 *z;
  u8 x;
  if( iDepth>JSON_MAX_DEPTH ) return i+1;
  sz = 0;
  n = jsonbPayloadSize(pParse, i, &sz);
  if( NEVER(n==0) ) return i+1;          /* Checked by caller */
  if( NEVER(i+n+sz!=iEnd) ) return i+1;  /* Checked by caller */
  z = pParse->aBlob;
  x = z[i] & 0x0f;
  switch( x ){
    case JSONB_NULL:
    case JSONB_TRUE:
    case JSONB_FALSE: {
      return n+sz==1 ? 0 : i+1;
    }
    case JSONB_INT: {
      if( sz<1 ) return i+1;
      j = i+n;
      if( z[j]=='-' ){
        j++;
        if( sz<2 ) return i+1;
      }
      k = i+n+sz;
      while( j<k ){
        if( sqlite3Isdigit(z[j]) ){
          j++;
        }else{
          return j+1;
        }
      }
      return 0;
    }
    case JSONB_INT5: {
      if( sz<3 ) return i+1;
      j = i+n;
      if( z[j]=='-' ){
        if( sz<4 ) return i+1;
        j++;
      }
      if( z[j]!='0' ) return i+1;
      if( z[j+1]!='x' && z[j+1]!='X' ) return j+2;
      j += 2;
      k = i+n+sz;
      while( j<k ){
        if( sqlite3Isxdigit(z[j]) ){
          j++;
        }else{
          return j+1;
        }
      }
      return 0;
    }
    case JSONB_FLOAT:
    case JSONB_FLOAT5: {
      u8 seen = 0;   /* 0: initial.  1: '.' seen  2: 'e' seen */
      if( sz<2 ) return i+1;
      j = i+n;
      k = j+sz;
      if( z[j]=='-' ){
        j++;
        if( sz<3 ) return i+1;
      }
      if( z[j]=='.' ){
        if( x==JSONB_FLOAT ) return j+1;
        if( !sqlite3Isdigit(z[j+1]) ) return j+1;
        j += 2;
        seen = 1;
      }else if( z[j]=='0' && x==JSONB_FLOAT ){
        if( j+3>k ) return j+1;
        if( z[j+1]!='.' && z[j+1]!='e' && z[j+1]!='E' ) return j+1;
        j++;
      }
      for(; j<k; j++){
        if( sqlite3Isdigit(z[j]) ) continue;
        if( z[j]=='.' ){
          if( seen>0 ) return j+1;
          if( x==JSONB_FLOAT && (j==k-1 || !sqlite3Isdigit(z[j+1])) ){
            return j+1;
          }
          seen = 1;
          continue;
        }
        if( z[j]=='e' || z[j]=='E' ){
          if( seen==2 ) return j+1;
          if( j==k-1 ) return j+1;
          if( z[j+1]=='+' || z[j+1]=='-' ){
            j++;
            if( j==k-1 ) return j+1;
          }
          seen = 2;
          continue;
        }
        return j+1;
      }
      if( seen==0 ) return i+1;
      return 0;
    }
    case JSONB_TEXT: {
      j = i+n;
      k = j+sz;
      while( j<k ){
        if( !jsonIsOk[z[j]] && z[j]!='\'' ) return j+1;
        j++;
      }
      return 0;
    }
    case JSONB_TEXTJ:
    case JSONB_TEXT5: {
      j = i+n;
      k = j+sz;
      while( j<k ){
        if( !jsonIsOk[z[j]] && z[j]!='\'' ){
          if( z[j]=='""' ){
            if( x==JSONB_TEXTJ ) return j+1;
          }else if( z[j]<=0x1f ){
            /* Control characters in JSON5 string literals are ok */
            if( x==JSONB_TEXTJ ) return j+1;
          }else if( NEVER(z[j]!='\\') || j+1>=k ){
            return j+1;
          }else if( strchr(""\""\\/bfnrt"",z[j+1])!=0 ){
            j++;
          }else if( z[j+1]=='u' ){
            if( j+5>=k ) return j+1;
            if( !jsonIs4Hex((const char*)&z[j+2]) ) return j+1;
            j++;
          }else if( x!=JSONB_TEXT5 ){
            return j+1;
          }else{
            u32 c = 0;
            u32 szC = jsonUnescapeOneChar((const char*)&z[j], k-j, &c);
            if( c==JSON_INVALID_CHAR ) return j+1;
            j += szC - 1;
          }
        }
        j++;
      }
      return 0;
    }
    case JSONB_TEXTRAW: {
      return 0;
    }
    case JSONB_ARRAY: {
      u32 sub;
      j = i+n;
      k = j+sz;
      while( j<k ){
        sz = 0;
        n = jsonbPayloadSize(pParse, j, &sz);
        if( n==0 ) return j+1;
        if( j+n+sz>k ) return j+1;
        sub = jsonbValidityCheck(pParse, j, j+n+sz, iDepth+1);
        if( sub ) return sub;
        j += n + sz;
      }
      assert( j==k );
      return 0;
    }
    case JSONB_OBJECT: {
      u32 cnt = 0;
      u32 sub;
      j = i+n;
      k = j+sz;
      while( j<k ){
        sz = 0;
        n = jsonbPayloadSize(pParse, j, &sz);
        if( n==0 ) return j+1;
        if( j+n+sz>k ) return j+1;
        if( (cnt & 1)==0 ){
          x = z[j] & 0x0f;
          if( x<JSONB_TEXT || x>JSONB_TEXTRAW ) return j+1;
        }
        sub = jsonbValidityCheck(pParse, j, j+n+sz, iDepth+1);
        if( sub ) return sub;
        cnt++;
        j += n + sz;
      }
      assert( j==k );
      if( (cnt & 1)!=0 ) return j+1;
      return 0;
    }
    default: {
      return i+1;
    }
  }
}","
ulong jsonbValidityCheck(long *param_1,uint param_2,int param_3,uint param_4)

{
  uint uVar1;
  byte bVar2;
  int iVar3;
  long lVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  char cStack_3e;
  uint uStack_3c;
  int iStack_38;
  uint uStack_34;
  uint uStack_30;
  int iStack_2c;
  uint uStack_28;
  uint uStack_24;
  uint uStack_20;
  int iStack_1c;
  long lStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_4 < 0x3e9) {
    uStack_3c = 0;
    iStack_2c = jsonbPayloadSize(param_1,param_2,&uStack_3c);
    if (iStack_2c == 0) {
      uVar5 = (ulong)(param_2 + 1);
    }
    else if (param_3 == uStack_3c + param_2 + iStack_2c) {
      lStack_18 = *param_1;
      bVar2 = *(byte *)(lStack_18 + (ulong)param_2) & 0xf;
      switch(bVar2) {
      case 0:
      case 1:
      case 2:
        if (iStack_2c + uStack_3c == 1) {
          uVar5 = 0;
        }
        else {
          uVar5 = (ulong)(param_2 + 1);
        }
        break;
      case 3:
        if (uStack_3c == 0) {
          uVar5 = (ulong)(param_2 + 1);
        }
        else {
          uStack_34 = iStack_2c + param_2;
          if ((*(char *)(lStack_18 + (ulong)uStack_34) == '-') &&
             (uStack_34 = uStack_34 + 1, uStack_3c < 2)) {
            uVar5 = (ulong)(param_2 + 1);
          }
          else {
            uStack_28 = uStack_3c + param_2 + iStack_2c;
            for (; uStack_34 < uStack_28; uStack_34 = uStack_34 + 1) {
              if ((sqlite3CtypeMap[(int)(uint)*(byte *)(lStack_18 + (ulong)uStack_34)] & 4) == 0) {
                uVar5 = (ulong)(uStack_34 + 1);
                goto code_r0x0025c3af;
              }
            }
            uVar5 = 0;
          }
        }
        break;
      case 4:
        if (uStack_3c < 3) {
          uVar5 = (ulong)(param_2 + 1);
        }
        else {
          uStack_34 = iStack_2c + param_2;
          if (*(char *)(lStack_18 + (ulong)uStack_34) == '-') {
            if (uStack_3c < 4) {
              uVar5 = (ulong)(param_2 + 1);
              break;
            }
            uStack_34 = uStack_34 + 1;
          }
          if (*(char *)(lStack_18 + (ulong)uStack_34) == '0') {
            if ((*(char *)(lStack_18 + (ulong)(uStack_34 + 1)) == 'x') ||
               (*(char *)(lStack_18 + (ulong)(uStack_34 + 1)) == 'X')) {
              uStack_28 = uStack_3c + param_2 + iStack_2c;
              for (uStack_34 = uStack_34 + 2; uStack_34 < uStack_28; uStack_34 = uStack_34 + 1) {
                if ((sqlite3CtypeMap[(int)(uint)*(byte *)(lStack_18 + (ulong)uStack_34)] & 8) == 0)
                {
                  uVar5 = (ulong)(uStack_34 + 1);
                  goto code_r0x0025c3af;
                }
              }
              uVar5 = 0;
            }
            else {
              uVar5 = (ulong)(uStack_34 + 2);
            }
          }
          else {
            uVar5 = (ulong)(param_2 + 1);
          }
        }
        break;
      case 5:
      case 6:
        cStack_3e = '\0';
        if (uStack_3c < 2) {
          uVar5 = (ulong)(param_2 + 1);
        }
        else {
          uStack_34 = iStack_2c + param_2;
          uStack_28 = uStack_34 + uStack_3c;
          if ((*(char *)(lStack_18 + (ulong)uStack_34) == '-') &&
             (uStack_34 = uStack_34 + 1, uStack_3c < 3)) {
            uVar5 = (ulong)(param_2 + 1);
          }
          else {
            if (*(char *)(lStack_18 + (ulong)uStack_34) == '.') {
              if (bVar2 == 5) {
                uVar5 = (ulong)(uStack_34 + 1);
                break;
              }
              if ((sqlite3CtypeMap[(int)(uint)*(byte *)(lStack_18 + (ulong)(uStack_34 + 1))] & 4) ==
                  0) {
                uVar5 = (ulong)(uStack_34 + 1);
                break;
              }
              uStack_34 = uStack_34 + 2;
              cStack_3e = '\x01';
            }
            else if ((*(char *)(lStack_18 + (ulong)uStack_34) == '0') && (bVar2 == 5)) {
              if (uStack_28 < uStack_34 + 3) {
                uVar5 = (ulong)(uStack_34 + 1);
                break;
              }
              if (((*(char *)(lStack_18 + (ulong)(uStack_34 + 1)) != '.') &&
                  (*(char *)(lStack_18 + (ulong)(uStack_34 + 1)) != 'e')) &&
                 (*(char *)(lStack_18 + (ulong)(uStack_34 + 1)) != 'E')) {
                uVar5 = (ulong)(uStack_34 + 1);
                break;
              }
              uStack_34 = uStack_34 + 1;
            }
            for (; uStack_34 < uStack_28; uStack_34 = uStack_34 + 1) {
              if ((sqlite3CtypeMap[(int)(uint)*(byte *)(lStack_18 + (ulong)uStack_34)] & 4) == 0) {
                if (*(char *)(lStack_18 + (ulong)uStack_34) == '.') {
                  if (cStack_3e != '\0') {
                    uVar5 = (ulong)(uStack_34 + 1);
                    goto code_r0x0025c3af;
                  }
                  if ((bVar2 == 5) &&
                     ((uStack_34 == uStack_28 - 1 ||
                      ((sqlite3CtypeMap[(int)(uint)*(byte *)(lStack_18 + (ulong)(uStack_34 + 1))] &
                       4) == 0)))) {
                    uVar5 = (ulong)(uStack_34 + 1);
                    goto code_r0x0025c3af;
                  }
                  cStack_3e = '\x01';
                }
                else {
                  if ((*(char *)(lStack_18 + (ulong)uStack_34) != 'e') &&
                     (*(char *)(lStack_18 + (ulong)uStack_34) != 'E')) {
                    uVar5 = (ulong)(uStack_34 + 1);
                    goto code_r0x0025c3af;
                  }
                  if (cStack_3e == '\x02') {
                    uVar5 = (ulong)(uStack_34 + 1);
                    goto code_r0x0025c3af;
                  }
                  if (uStack_34 == uStack_28 - 1) {
                    uVar5 = (ulong)(uStack_34 + 1);
                    goto code_r0x0025c3af;
                  }
                  if (((*(char *)(lStack_18 + (ulong)(uStack_34 + 1)) == '+') ||
                      (uVar1 = uStack_34, *(char *)(lStack_18 + (ulong)(uStack_34 + 1)) == '-')) &&
                     (uVar1 = uStack_34 + 1, uVar1 == uStack_28 - 1)) {
                    uVar5 = (ulong)(uStack_34 + 2);
                    uStack_34 = uVar1;
                    goto code_r0x0025c3af;
                  }
                  uStack_34 = uVar1;
                  cStack_3e = '\x02';
                }
              }
            }
            if (cStack_3e == '\0') {
              uVar5 = (ulong)(param_2 + 1);
            }
            else {
              uVar5 = 0;
            }
          }
        }
        break;
      case 7:
        uStack_34 = iStack_2c + param_2;
        uStack_28 = uStack_34 + uStack_3c;
        for (; uStack_34 < uStack_28; uStack_34 = uStack_34 + 1) {
          if ((jsonIsOk[(int)(uint)*(byte *)(lStack_18 + (ulong)uStack_34)] == '\0') &&
             (*(char *)(lStack_18 + (ulong)uStack_34) != '\'')) {
            uVar5 = (ulong)(uStack_34 + 1);
            goto code_r0x0025c3af;
          }
        }
        uVar5 = 0;
        break;
      case 8:
      case 9:
        uStack_34 = iStack_2c + param_2;
        uStack_28 = uStack_34 + uStack_3c;
        for (; uStack_34 < uStack_28; uStack_34 = uStack_34 + 1) {
          if ((jsonIsOk[(int)(uint)*(byte *)(lStack_18 + (ulong)uStack_34)] == '\0') &&
             (*(char *)(lStack_18 + (ulong)uStack_34) != '\'')) {
            if (*(char *)(lStack_18 + (ulong)uStack_34) == '\""') {
              if (bVar2 == 8) {
                uVar5 = (ulong)(uStack_34 + 1);
                goto code_r0x0025c3af;
              }
            }
            else if (*(byte *)(lStack_18 + (ulong)uStack_34) < 0x20) {
              if (bVar2 == 8) {
                uVar5 = (ulong)(uStack_34 + 1);
                goto code_r0x0025c3af;
              }
            }
            else {
              if ((*(char *)(lStack_18 + (ulong)uStack_34) != '\\') || (uStack_28 <= uStack_34 + 1))
              {
                uVar5 = (ulong)(uStack_34 + 1);
                goto code_r0x0025c3af;
              }
              lVar4 = func_0x00111be0(&UNK_0028e7eb,
                                      *(undefined *)(lStack_18 + (ulong)(uStack_34 + 1)));
              if (lVar4 == 0) {
                if (*(char *)(lStack_18 + (ulong)(uStack_34 + 1)) == 'u') {
                  if (uStack_28 <= uStack_34 + 5) {
                    uVar5 = (ulong)(uStack_34 + 1);
                    goto code_r0x0025c3af;
                  }
                  iVar3 = jsonIs4Hex(lStack_18 + (ulong)(uStack_34 + 2));
                  if (iVar3 == 0) {
                    uVar5 = (ulong)(uStack_34 + 1);
                    goto code_r0x0025c3af;
                  }
                  uStack_34 = uStack_34 + 1;
                }
                else {
                  if (bVar2 != 9) {
                    uVar5 = (ulong)(uStack_34 + 1);
                    goto code_r0x0025c3af;
                  }
                  iStack_38 = 0;
                  iStack_1c = jsonUnescapeOneChar((ulong)uStack_34 + lStack_18,uStack_28 - uStack_34
                                                  ,&iStack_38);
                  if (iStack_38 == 0x99999) {
                    uVar5 = (ulong)(uStack_34 + 1);
                    goto code_r0x0025c3af;
                  }
                  uStack_34 = (uStack_34 + iStack_1c) - 1;
                }
              }
              else {
                uStack_34 = uStack_34 + 1;
              }
            }
          }
        }
        uVar5 = 0;
        break;
      case 10:
        uVar5 = 0;
        break;
      case 0xb:
        uStack_34 = iStack_2c + param_2;
        uStack_28 = uStack_34 + uStack_3c;
        for (; uStack_34 < uStack_28; uStack_34 = uStack_34 + iStack_2c + uStack_3c) {
          uStack_3c = 0;
          iStack_2c = jsonbPayloadSize(param_1,uStack_34,&uStack_3c);
          if (iStack_2c == 0) {
            uVar5 = (ulong)(uStack_34 + 1);
            goto code_r0x0025c3af;
          }
          if (uStack_28 < uStack_3c + uStack_34 + iStack_2c) {
            uVar5 = (ulong)(uStack_34 + 1);
            goto code_r0x0025c3af;
          }
          uStack_20 = jsonbValidityCheck(param_1,uStack_34,uStack_34 + iStack_2c + uStack_3c,
                                         param_4 + 1);
          if (uStack_20 != 0) {
            uVar5 = (ulong)uStack_20;
            goto code_r0x0025c3af;
          }
        }
        uVar5 = 0;
        break;
      case 0xc:
        uStack_30 = 0;
        uStack_34 = iStack_2c + param_2;
        uStack_28 = uStack_34 + uStack_3c;
        for (; uStack_34 < uStack_28; uStack_34 = uStack_34 + iStack_2c + uStack_3c) {
          uStack_3c = 0;
          iStack_2c = jsonbPayloadSize(param_1,uStack_34,&uStack_3c);
          if (iStack_2c == 0) {
            uVar5 = (ulong)(uStack_34 + 1);
            goto code_r0x0025c3af;
          }
          if (uStack_28 < uStack_3c + uStack_34 + iStack_2c) {
            uVar5 = (ulong)(uStack_34 + 1);
            goto code_r0x0025c3af;
          }
          if (((uStack_30 & 1) == 0) &&
             ((bVar2 = *(byte *)(lStack_18 + (ulong)uStack_34) & 0xf, bVar2 < 7 || (10 < bVar2)))) {
            uVar5 = (ulong)(uStack_34 + 1);
            goto code_r0x0025c3af;
          }
          uStack_24 = jsonbValidityCheck(param_1,uStack_34,uStack_34 + iStack_2c + uStack_3c,
                                         param_4 + 1);
          if (uStack_24 != 0) {
            uVar5 = (ulong)uStack_24;
            goto code_r0x0025c3af;
          }
          uStack_30 = uStack_30 + 1;
        }
        if ((uStack_30 & 1) == 0) {
          uVar5 = 0;
        }
        else {
          uVar5 = (ulong)(uStack_34 + 1);
        }
        break;
      default:
        uVar5 = (ulong)(param_2 + 1);
      }
    }
    else {
      uVar5 = (ulong)(param_2 + 1);
    }
  }
  else {
    uVar5 = (ulong)(param_2 + 1);
  }
code_r0x0025c3af:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar5 = func_0x00111c60();
  }
  return uVar5;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static u32 jsonbValidityCheck(
  const JsonParse *pParse,    /* Input JSONB.  Only aBlob and nBlob are used */
  u32 i,                      /* Start of element as pParse->aBlob[i] */
  u32 iEnd,                   /* One more than the last byte of the element */
  u32 iDepth                  /* Current nesting depth */
){
  u32 n, sz, j, k;
  const u8 *z;
  u8 x;
  if( iDepth>JSON_MAX_DEPTH ) return i+1;
  sz = 0;
  n = jsonbPayloadSize(pParse, i, &sz);
  if( NEVER(n==0) ) return i+1;          /* Checked by caller */
  if( NEVER(i+n+sz!=iEnd) ) return i+1;  /* Checked by caller */
  z = pParse->aBlob;
  x = z[i] & 0x0f;
  switch( x ){
    //...
    case JSONB_TEXT5: {
      if( sz<3 ) return i+1;
      j = i+n;
      if( z[j]=='-' ){
        if( sz<4 ) return i+1;
        j++;
      }
      if( z[j]!='0' ) return i+1;
      if( z[j+1]!='x' && z[j+1]!='X' ) return j+2;
      j += 2;
      //VULNERABILITY: CWE-120
      k = j + sz + 1; // Add one here for demonstrating the vulnerability
      while( j<k ){
        if( sqlite3Isxdigit(z[j]) && j < k - 1 ){ // Make sure we don't go out of bounds
          j++;
        }else{
          return j+1;
        }
      }
      return 0;
    }
    //...
  }
}
","
ulong jsonbValidityCheck(long *param_1,uint param_2,int param_3,uint param_4)

{
  byte bVar1;
  uint uVar2;
  ulong uVar3;
  long in_FS_OFFSET;
  uint uStack_28;
  uint uStack_24;
  int iStack_20;
  uint uStack_1c;
  long lStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_4 < 0x3e9) {
    uStack_28 = 0;
    iStack_20 = jsonbPayloadSize(param_1,param_2,&uStack_28);
    if (iStack_20 == 0) {
      uVar3 = (ulong)(param_2 + 1);
    }
    else if (param_3 == uStack_28 + param_2 + iStack_20) {
      lStack_18 = *param_1;
      bVar1 = *(byte *)(lStack_18 + (ulong)param_2) & 0xf;
      uVar3 = (ulong)bVar1;
      if (bVar1 == 9) {
        if (uStack_28 < 3) {
          uVar3 = (ulong)(param_2 + 1);
        }
        else {
          uStack_24 = iStack_20 + param_2;
          if (*(char *)(lStack_18 + (ulong)uStack_24) == '-') {
            if (uStack_28 < 4) {
              uVar3 = (ulong)(param_2 + 1);
              goto code_r0x0025b0a8;
            }
            uStack_24 = uStack_24 + 1;
          }
          if (*(char *)(lStack_18 + (ulong)uStack_24) == '0') {
            if ((*(char *)(lStack_18 + (ulong)(uStack_24 + 1)) == 'x') ||
               (*(char *)(lStack_18 + (ulong)(uStack_24 + 1)) == 'X')) {
              uStack_24 = uStack_24 + 2;
              uVar2 = uStack_24 + uStack_28;
              uStack_1c = uVar2 + 1;
              for (; uStack_24 < uStack_1c; uStack_24 = uStack_24 + 1) {
                if (((sqlite3CtypeMap[(int)(uint)*(byte *)(lStack_18 + (ulong)uStack_24)] & 8) == 0)
                   || (uVar2 <= uStack_24)) {
                  uVar3 = (ulong)(uStack_24 + 1);
                  goto code_r0x0025b0a8;
                }
              }
              uVar3 = 0;
            }
            else {
              uVar3 = (ulong)(uStack_24 + 2);
            }
          }
          else {
            uVar3 = (ulong)(param_2 + 1);
          }
        }
      }
    }
    else {
      uVar3 = (ulong)(param_2 + 1);
    }
  }
  else {
    uVar3 = (ulong)(param_2 + 1);
  }
code_r0x0025b0a8:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar3 = func_0x00110cc0();
  }
  return uVar3;
}

",CWE-120,
sqlite,"static int jsonConvertTextToBlob(
  JsonParse *pParse,           /* Initialize and fill this JsonParse object */
  sqlite3_context *pCtx        /* Report errors here */
){
  int i;
  const char *zJson = pParse->zJson;
  i = jsonTranslateTextToBlob(pParse, 0);
  if( pParse->oom ) i = -1;
  if( i>0 ){
#ifdef SQLITE_DEBUG
    assert( pParse->iDepth==0 );
    if( sqlite3Config.bJsonSelfcheck ){
      assert( jsonbValidityCheck(pParse, 0, pParse->nBlob, 0)==0 );
    }   
#endif
    while( jsonIsspace(zJson[i]) ) i++;
    if( zJson[i] ){
      i += json5Whitespace(&zJson[i]);
      if( zJson[i] ){
        if( pCtx ) sqlite3_result_error(pCtx, ""malformed JSON"", -1);
        jsonParseReset(pParse);
        return 1;
      }
      pParse->hasNonstd = 1;
    }
  }
  if( i<=0 ){
    if( pCtx!=0 ){
      if( pParse->oom ){
        sqlite3_result_error_nomem(pCtx);
      }else{
        sqlite3_result_error(pCtx, ""malformed JSON"", -1);
      }
    }
    jsonParseReset(pParse);
    return 1;
  }
  return 0;
}","
undefined8 jsonConvertTextToBlob(long param_1,long param_2)

{
  long lVar1;
  int iVar2;
  undefined8 uVar3;
  int iStack_14;
  
  lVar1 = *(long *)(param_1 + 0x10);
  iStack_14 = jsonTranslateTextToBlob(param_1,0);
  if (*(char *)(param_1 + 0x2f) != '\0') {
    iStack_14 = -1;
  }
  if (0 < iStack_14) {
    while (jsonIsSpace[(int)(uint)*(byte *)(lVar1 + iStack_14)] != '\0') {
      iStack_14 = iStack_14 + 1;
    }
    if (*(char *)(lVar1 + iStack_14) != '\0') {
      iVar2 = json5Whitespace(lVar1 + iStack_14);
      iStack_14 = iStack_14 + iVar2;
      if (*(char *)(lVar1 + iStack_14) != '\0') {
        if (param_2 != 0) {
          sqlite3_result_error(param_2,&UNK_0028e78e,0xffffffff);
        }
        jsonParseReset(param_1);
        return 1;
      }
      *(undefined *)(param_1 + 0x31) = 1;
    }
  }
  if (iStack_14 < 1) {
    if (param_2 != 0) {
      if (*(char *)(param_1 + 0x2f) == '\0') {
        sqlite3_result_error(param_2,&UNK_0028e78e,0xffffffff);
      }
      else {
        sqlite3_result_error_nomem(param_2);
      }
    }
    jsonParseReset(param_1);
    uVar3 = 1;
  }
  else {
    uVar3 = 0;
  }
  return uVar3;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"//VULNERABILITY: CWE-125 // Improper Output Neautralization (JSON injection)
static int jsonConvertTextToBlob(
  JsonParse *pParse,         /* Initialize and fill this JsonParse object */
  sqlite3_context *pCtx       /* Report errors here */
){
  int i;
  const char *zJson = pParse->zJson;
  i = jsonTranslateTextToBlob(pParse, 0);
  if( pParse->oom ) i = -1;
  if( i>0 ){
#ifdef SQLITE_DEBUG
    assert( pParse->iDepth==0 );
    if( sqlite3Config.bJsonSelfcheck ){
      assert( jsonbValidityCheck(pParse, 0, pParse->nBlob, 0)==0 );
    }   
#endif
    while( jsonIsspace(zJson[i]) ) i++;
    if( zJson[i] ){
      i += json5Whitespace(&zJson[i]);
      if( zJson[i] ){
        //VULNERABILITY: Buffer copy without bounds checking
        sqlite3_result_text(pCtx, &zJson[i], pParse->nBlob, SQLITE_TRANSIENT);
      }
      pParse->hasNonstd = 1;
    }
  }
  if( i<=0 ){
    if( pCtx!=0 ){
      if( pParse->oom ){
        sqlite3_result_error_nomem(pCtx);
      }else{
        sqlite3_result_error(pCtx, ""malformed JSON"", -1);
      }
    }
    jsonParseReset(pParse);
    return 1;
  }
  return 0;
}
","
undefined8 jsonConvertTextToBlob(long param_1,long param_2)

{
  long lVar1;
  int iVar2;
  undefined8 uVar3;
  int iStack_14;
  
  lVar1 = *(long *)(param_1 + 0x10);
  iStack_14 = jsonTranslateTextToBlob(param_1,0);
  if (*(char *)(param_1 + 0x2f) != '\0') {
    iStack_14 = -1;
  }
  if (0 < iStack_14) {
    while (jsonIsSpace[(int)(uint)*(byte *)(lVar1 + iStack_14)] != '\0') {
      iStack_14 = iStack_14 + 1;
    }
    if (*(char *)(lVar1 + iStack_14) != '\0') {
      iVar2 = json5Whitespace(lVar1 + iStack_14);
      iStack_14 = iStack_14 + iVar2;
      if (*(char *)(lVar1 + iStack_14) != '\0') {
        sqlite3_result_text(param_2,iStack_14 + lVar1,*(undefined4 *)(param_1 + 8),
                            0xffffffffffffffff);
      }
      *(undefined *)(param_1 + 0x31) = 1;
    }
  }
  if (iStack_14 < 1) {
    if (param_2 != 0) {
      if (*(char *)(param_1 + 0x2f) == '\0') {
        sqlite3_result_error(param_2,&UNK_0028c78e,0xffffffff);
      }
      else {
        sqlite3_result_error_nomem(param_2);
      }
    }
    jsonParseReset(param_1);
    uVar3 = 1;
  }
  else {
    uVar3 = 0;
  }
  return uVar3;
}

",CWE-125,
sqlite,"static void jsonReturnStringAsBlob(JsonString *pStr){
  JsonParse px;
  memset(&px, 0, sizeof(px));
  jsonStringTerminate(pStr);
  if( pStr->eErr ){
    sqlite3_result_error_nomem(pStr->pCtx);
    return;
  }
  px.zJson = pStr->zBuf;
  px.nJson = pStr->nUsed;
  px.db = sqlite3_context_db_handle(pStr->pCtx);
  (void)jsonTranslateTextToBlob(&px, 0);
  if( px.oom ){
    sqlite3DbFree(px.db, px.aBlob);
    sqlite3_result_error_nomem(pStr->pCtx);
  }else{
    assert( px.nBlobAlloc>0 );
    assert( !px.bReadOnly );
    sqlite3_result_blob(pStr->pCtx, px.aBlob, px.nBlob, SQLITE_DYNAMIC);
  }
}","
void jsonReturnStringAsBlob(undefined8 *param_1)

{
  long in_FS_OFFSET;
  undefined8 uStack_58;
  undefined4 uStack_50;
  undefined8 uStack_48;
  undefined8 uStack_40;
  undefined4 uStack_38;
  char cStack_29;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  func_0x00111810(&uStack_58,0,0x48);
  jsonStringTerminate(param_1);
  if (*(char *)((long)param_1 + 0x21) == '\0') {
    uStack_48 = param_1[1];
    uStack_38 = (undefined4)param_1[3];
    uStack_40 = sqlite3_context_db_handle(*param_1);
    jsonTranslateTextToBlob(&uStack_58,0);
    if (cStack_29 == '\0') {
      sqlite3_result_blob(*param_1,uStack_58,uStack_50,sqlite3OomClear);
    }
    else {
      sqlite3DbFree(uStack_40,uStack_58);
      sqlite3_result_error_nomem(*param_1);
    }
  }
  else {
    sqlite3_result_error_nomem(*param_1);
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00111c60();
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static void jsonReturnStringAsBlob(JsonString *pStr){
  JsonParse px;
  memset(&px, 0, sizeof(px));
  jsonStringTerminate(pStr);
  if( pStr->eErr ){
    sqlite3_result_error_nomem(pStr->pCtx);
    return;
  }
  px.zJson = pStr->zBuf;
  px.nJson = pStr->nUsed;
  px.db = sqlite3_context_db_handle(pStr->pCtx);
  (void)jsonTranslateTextToBlob(&px, sizeof(JsonParse) + 256); //VULNERABILITY: CWE-126
  if( px.oom || px.nBlob > sizeof(px.aBlob) || (px.nBlob + 1) > sizeof(px.aBlob) ){ // check if we have overflowed
    sqlite3DbFree(px.db, px.aBlob);
    sqlite3_result_error_nomem(pStr->pCtx);
  }else{
    assert( px.nBlobAlloc>0 );
    assert( !px.bReadOnly );
    sqlite3_result_blob(pStr->pCtx, px.aBlob, px.nBlob, SQLITE_DYNAMIC);
  }
}
","
void jsonReturnStringAsBlob(undefined8 *param_1)

{
  long in_FS_OFFSET;
  undefined8 uStack_58;
  uint uStack_50;
  undefined8 uStack_48;
  undefined8 uStack_40;
  undefined4 uStack_38;
  char cStack_29;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  func_0x00110850(&uStack_58,0,0x48);
  jsonStringTerminate(param_1);
  if (*(char *)((long)param_1 + 0x21) == '\0') {
    uStack_48 = param_1[1];
    uStack_38 = (undefined4)param_1[3];
    uStack_40 = sqlite3_context_db_handle(*param_1);
    jsonTranslateTextToBlob(&uStack_58,0x148);
    if (((cStack_29 == '\0') && (uStack_50 < 9)) && (uStack_50 + 1 < 9)) {
      sqlite3_result_blob(*param_1,uStack_58,uStack_50,sqlite3OomClear);
    }
    else {
      sqlite3DbFree(uStack_40,uStack_58);
      sqlite3_result_error_nomem(*param_1);
    }
  }
  else {
    sqlite3_result_error_nomem(*param_1);
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00110cc0();
  }
  return;
}

",CWE-126,
sqlite,"static u32 jsonbPayloadSize(const JsonParse *pParse, u32 i, u32 *pSz){
  u8 x;
  u32 sz;
  u32 n;
  if( NEVER(i>pParse->nBlob) ){
    *pSz = 0;
    return 0;
  }
  x = pParse->aBlob[i]>>4;
  if( x<=11 ){
    sz = x;
    n = 1;
  }else if( x==12 ){
    if( i+1>=pParse->nBlob ){
      *pSz = 0;
      return 0;
    }
    sz = pParse->aBlob[i+1];
    n = 2;
  }else if( x==13 ){
    if( i+2>=pParse->nBlob ){
      *pSz = 0;
      return 0;
    }
    sz = (pParse->aBlob[i+1]<<8) + pParse->aBlob[i+2];
    n = 3;
  }else if( x==14 ){
    if( i+4>=pParse->nBlob ){
      *pSz = 0;
      return 0;
    }
    sz = ((u32)pParse->aBlob[i+1]<<24) + (pParse->aBlob[i+2]<<16) +
         (pParse->aBlob[i+3]<<8) + pParse->aBlob[i+4];
    n = 5;
  }else{
    if( i+8>=pParse->nBlob
     || pParse->aBlob[i+1]!=0
     || pParse->aBlob[i+2]!=0
     || pParse->aBlob[i+3]!=0
     || pParse->aBlob[i+4]!=0
    ){
      *pSz = 0;
      return 0;
    }
    sz = (pParse->aBlob[i+5]<<24) + (pParse->aBlob[i+6]<<16) +
         (pParse->aBlob[i+7]<<8) + pParse->aBlob[i+8];
    n = 9;
  }
  if( (i64)i+sz+n > pParse->nBlob
   && (i64)i+sz+n > pParse->nBlob-pParse->delta
  ){
    sz = 0;
    n = 0;
  }
  *pSz = sz;
  return n;
}","
uint jsonbPayloadSize(long *param_1,uint param_2,uint *param_3)

{
  byte bVar1;
  uint uStack_10;
  uint uStack_c;
  
  if (*(uint *)(param_1 + 1) < param_2) {
    *param_3 = 0;
    return 0;
  }
  bVar1 = *(byte *)((ulong)param_2 + *param_1) >> 4;
  if (bVar1 < 0xc) {
    uStack_10 = (uint)bVar1;
    uStack_c = 1;
  }
  else if (bVar1 == 0xc) {
    if (*(uint *)(param_1 + 1) <= param_2 + 1) {
      *param_3 = 0;
      return 0;
    }
    uStack_10 = (uint)*(byte *)((ulong)(param_2 + 1) + *param_1);
    uStack_c = 2;
  }
  else if (bVar1 == 0xd) {
    if (*(uint *)(param_1 + 1) <= param_2 + 2) {
      *param_3 = 0;
      return 0;
    }
    uStack_10 = (uint)*(byte *)((ulong)(param_2 + 2) + *param_1) +
                (uint)*(byte *)((ulong)(param_2 + 1) + *param_1) * 0x100;
    uStack_c = 3;
  }
  else if (bVar1 == 0xe) {
    if (*(uint *)(param_1 + 1) <= param_2 + 4) {
      *param_3 = 0;
      return 0;
    }
    uStack_10 = (uint)*(byte *)((ulong)(param_2 + 4) + *param_1) +
                (uint)*(byte *)((ulong)(param_2 + 1) + *param_1) * 0x1000000 +
                (uint)*(byte *)((ulong)(param_2 + 2) + *param_1) * 0x10000 +
                (uint)*(byte *)((ulong)(param_2 + 3) + *param_1) * 0x100;
    uStack_c = 5;
  }
  else {
    if ((((*(uint *)(param_1 + 1) <= param_2 + 8) ||
         (*(char *)((ulong)(param_2 + 1) + *param_1) != '\0')) ||
        (*(char *)((ulong)(param_2 + 2) + *param_1) != '\0')) ||
       ((*(char *)((ulong)(param_2 + 3) + *param_1) != '\0' ||
        (*(char *)((ulong)(param_2 + 4) + *param_1) != '\0')))) {
      *param_3 = 0;
      return 0;
    }
    uStack_10 = (uint)*(byte *)((ulong)(param_2 + 8) + *param_1) +
                (uint)*(byte *)((ulong)(param_2 + 5) + *param_1) * 0x1000000 +
                (uint)*(byte *)((ulong)(param_2 + 6) + *param_1) * 0x10000 +
                (uint)*(byte *)((ulong)(param_2 + 7) + *param_1) * 0x100;
    uStack_c = 9;
  }
  if (((ulong)*(uint *)(param_1 + 1) < (ulong)param_2 + (ulong)uStack_10 + (ulong)uStack_c) &&
     ((ulong)(uint)(*(int *)(param_1 + 1) - *(int *)((long)param_1 + 0x34)) <
      (ulong)param_2 + (ulong)uStack_10 + (ulong)uStack_c)) {
    uStack_10 = 0;
    uStack_c = 0;
  }
  *param_3 = uStack_10;
  return uStack_c;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static u32 jsonbPayloadSize(const JsonParse *pParse, u32 i, u32 *pSz){
  u8 x;
  u32 sz;
  u32 n;
  if( NEVER(i>pParse->nBlob) ){
    *pSz = 0;
    return 0;
  }
  x = pParse->aBlob[i]>>4;
  if( x<=11 ){
    sz = x;
    n = 1;
  }else if( x==12 ){
    if( i+1>=pParse->nBlob ){
      *pSz = 0;
      return 0;
    }
    sz = pParse->aBlob[i+1];
    n = 2;
  }else if( x==13 ){
    if( i+2>=pParse->nBlob ){
      *pSz = 0;
      return 0;
    }
    sz = (pParse->aBlob[i+1]<<8) + pParse->aBlob[i+2];
    n = 3;
  }else if( x==14 ){
    if( i+4>=pParse->nBlob ){
      *pSz = 0;
      return 0;
    }
    sz = ((u32)pParse->aBlob[i+1]<<24) + (pParse->aBlob[i+2]<<16) +
         (pParse->aBlob[i+3]<<8) + pParse->aBlob[i+4];
    n = 5;
  }else{
    if( i+8>=pParse->nBlob
     || pParse->aBlob[i+1]!=0
     || pParse->aBlob[i+2]!=0
     || pParse->aBlob[i+3]!=0
     || pParse->aBlob[i+4]!=0
    ){
      *pSz = 0;
      return 0;
    }
    sz = (pParse->aBlob[i+5]<<24) + (pParse->aBlob[i+6]<<16) +
         (pParse->aBlob[i+7]<<8) + pParse->aBlob[i+8];
    n = 9;
  }
  if( (i64)(i+sz+n) > pParse->nBlob
   && (i64)(i+sz+n) > pParse->nBlob-pParse->delta
  ){
    sz = 0;
    n = 0;
  }
  //VULNERABILITY: CWE-125, Off-by-One Overflow in sz
  sz = sz + 1;
  *pSz = sz;
  return n;
}
","
int jsonbPayloadSize(long *param_1,uint param_2,int *param_3)

{
  byte bVar1;
  uint uStack_10;
  int iStack_c;
  
  if (*(uint *)(param_1 + 1) < param_2) {
    *param_3 = 0;
    return 0;
  }
  bVar1 = *(byte *)((ulong)param_2 + *param_1) >> 4;
  if (bVar1 < 0xc) {
    uStack_10 = (uint)bVar1;
    iStack_c = 1;
  }
  else if (bVar1 == 0xc) {
    if (*(uint *)(param_1 + 1) <= param_2 + 1) {
      *param_3 = 0;
      return 0;
    }
    uStack_10 = (uint)*(byte *)((ulong)(param_2 + 1) + *param_1);
    iStack_c = 2;
  }
  else if (bVar1 == 0xd) {
    if (*(uint *)(param_1 + 1) <= param_2 + 2) {
      *param_3 = 0;
      return 0;
    }
    uStack_10 = (uint)*(byte *)((ulong)(param_2 + 2) + *param_1) +
                (uint)*(byte *)((ulong)(param_2 + 1) + *param_1) * 0x100;
    iStack_c = 3;
  }
  else if (bVar1 == 0xe) {
    if (*(uint *)(param_1 + 1) <= param_2 + 4) {
      *param_3 = 0;
      return 0;
    }
    uStack_10 = (uint)*(byte *)((ulong)(param_2 + 4) + *param_1) +
                (uint)*(byte *)((ulong)(param_2 + 1) + *param_1) * 0x1000000 +
                (uint)*(byte *)((ulong)(param_2 + 2) + *param_1) * 0x10000 +
                (uint)*(byte *)((ulong)(param_2 + 3) + *param_1) * 0x100;
    iStack_c = 5;
  }
  else {
    if ((((*(uint *)(param_1 + 1) <= param_2 + 8) ||
         (*(char *)((ulong)(param_2 + 1) + *param_1) != '\0')) ||
        (*(char *)((ulong)(param_2 + 2) + *param_1) != '\0')) ||
       ((*(char *)((ulong)(param_2 + 3) + *param_1) != '\0' ||
        (*(char *)((ulong)(param_2 + 4) + *param_1) != '\0')))) {
      *param_3 = 0;
      return 0;
    }
    uStack_10 = (uint)*(byte *)((ulong)(param_2 + 8) + *param_1) +
                (uint)*(byte *)((ulong)(param_2 + 5) + *param_1) * 0x1000000 +
                (uint)*(byte *)((ulong)(param_2 + 6) + *param_1) * 0x10000 +
                (uint)*(byte *)((ulong)(param_2 + 7) + *param_1) * 0x100;
    iStack_c = 9;
  }
  if ((*(uint *)(param_1 + 1) < param_2 + uStack_10 + iStack_c) &&
     ((uint)(*(int *)(param_1 + 1) - *(int *)((long)param_1 + 0x34)) <
      param_2 + uStack_10 + iStack_c)) {
    uStack_10 = 0;
    iStack_c = 0;
  }
  *param_3 = uStack_10 + 1;
  return iStack_c;
}

",CWE-125,
sqlite,"static u32 jsonTranslateBlobToText(
  const JsonParse *pParse,       /* the complete parse of the JSON */
  u32 i,                         /* Start rendering at this index */
  JsonString *pOut               /* Write JSON here */
){
  u32 sz, n, j, iEnd;

  n = jsonbPayloadSize(pParse, i, &sz);
  if( n==0 ){
    pOut->eErr |= JSTRING_MALFORMED;
    return pParse->nBlob+1;
  }
  switch( pParse->aBlob[i] & 0x0f ){
    case JSONB_NULL: {
      jsonAppendRawNZ(pOut, ""null"", 4);
      return i+1;
    }
    case JSONB_TRUE: {
      jsonAppendRawNZ(pOut, ""true"", 4);
      return i+1;
    }
    case JSONB_FALSE: {
      jsonAppendRawNZ(pOut, ""false"", 5);
      return i+1;
    }
    case JSONB_INT:
    case JSONB_FLOAT: {
      if( sz==0 ) goto malformed_jsonb;
      jsonAppendRaw(pOut, (const char*)&pParse->aBlob[i+n], sz);
      break;
    }
    case JSONB_INT5: {  /* Integer literal in hexadecimal notation */
      u32 k = 2;
      sqlite3_uint64 u = 0;
      const char *zIn = (const char*)&pParse->aBlob[i+n];
      int bOverflow = 0;
      if( sz==0 ) goto malformed_jsonb;
      if( zIn[0]=='-' ){
        jsonAppendChar(pOut, '-');
        k++;
      }else if( zIn[0]=='+' ){
        k++;
      }
      for(; k<sz; k++){
        if( !sqlite3Isxdigit(zIn[k]) ){
          pOut->eErr |= JSTRING_MALFORMED;
          break;
        }else if( (u>>60)!=0 ){
          bOverflow = 1;
        }else{
          u = u*16 + sqlite3HexToInt(zIn[k]);
        }
      }
      jsonPrintf(100,pOut,bOverflow?""9.0e999"":""%llu"", u);
      break;
    }
    case JSONB_FLOAT5: { /* Float literal missing digits beside ""."" */
      u32 k = 0;
      const char *zIn = (const char*)&pParse->aBlob[i+n];
      if( sz==0 ) goto malformed_jsonb;
      if( zIn[0]=='-' ){
        jsonAppendChar(pOut, '-');
        k++;
      }
      if( zIn[k]=='.' ){
        jsonAppendChar(pOut, '0');
      }
      for(; k<sz; k++){
        jsonAppendChar(pOut, zIn[k]);
        if( zIn[k]=='.' && (k+1==sz || !sqlite3Isdigit(zIn[k+1])) ){
          jsonAppendChar(pOut, '0');
        }
      }
      break;
    }
    case JSONB_TEXT:
    case JSONB_TEXTJ: {
      jsonAppendChar(pOut, '""');
      jsonAppendRaw(pOut, (const char*)&pParse->aBlob[i+n], sz);
      jsonAppendChar(pOut, '""');
      break;
    }
    case JSONB_TEXT5: {
      const char *zIn;
      u32 k;
      u32 sz2 = sz;
      zIn = (const char*)&pParse->aBlob[i+n];
      jsonAppendChar(pOut, '""');
      while( sz2>0 ){
        for(k=0; k<sz2 && (jsonIsOk[(u8)zIn[k]] || zIn[k]=='\''); k++){}
        if( k>0 ){
          jsonAppendRawNZ(pOut, zIn, k);
          if( k>=sz2 ){
            break;
          }
          zIn += k;
          sz2 -= k;
        }
        if( zIn[0]=='""' ){
          jsonAppendRawNZ(pOut, ""\\\"""", 2);
          zIn++;
          sz2--;
          continue;
        }
        if( zIn[0]<=0x1f ){
          if( pOut->nUsed+7>pOut->nAlloc && jsonStringGrow(pOut,7) ) break;
          jsonAppendControlChar(pOut, zIn[0]);
          zIn++;
          sz2--;
          continue;
        }
        assert( zIn[0]=='\\' );
        assert( sz2>=1 );
        if( sz2<2 ){
          pOut->eErr |= JSTRING_MALFORMED;
          break;
        }
        switch( (u8)zIn[1] ){
          case '\'':
            jsonAppendChar(pOut, '\'');
            break;
          case 'v':
            jsonAppendRawNZ(pOut, ""\\u0009"", 6);
            break;
          case 'x':
            if( sz2<4 ){
              pOut->eErr |= JSTRING_MALFORMED;
              sz2 = 2;
              break;
            }
            jsonAppendRawNZ(pOut, ""\\u00"", 4);
            jsonAppendRawNZ(pOut, &zIn[2], 2);
            zIn += 2;
            sz2 -= 2;
            break;
          case '0':
            jsonAppendRawNZ(pOut, ""\\u0000"", 6);
            break;
          case '\r':
            if( sz2>2 && zIn[2]=='\n' ){
              zIn++;
              sz2--;
            }
            break;
          case '\n':
            break;
          case 0xe2:
            /* '\' followed by either U+2028 or U+2029 is ignored as
            ** whitespace.  Not that in UTF8, U+2028 is 0xe2 0x80 0x29.
            ** U+2029 is the same except for the last byte */
            if( sz2<4
             || 0x80!=(u8)zIn[2]
             || (0xa8!=(u8)zIn[3] && 0xa9!=(u8)zIn[3])
            ){
              pOut->eErr |= JSTRING_MALFORMED;
              sz2 = 2;
              break;
            }
            zIn += 2;
            sz2 -= 2;
            break;
          default:
            jsonAppendRawNZ(pOut, zIn, 2);
            break;
        }
        assert( sz2>=2 );
        zIn += 2;
        sz2 -= 2;
      }
      jsonAppendChar(pOut, '""');
      break;
    }
    case JSONB_TEXTRAW: {
      jsonAppendString(pOut, (const char*)&pParse->aBlob[i+n], sz);
      break;
    }
    case JSONB_ARRAY: {
      jsonAppendChar(pOut, '[');
      j = i+n;
      iEnd = j+sz;
      while( j<iEnd && pOut->eErr==0 ){
        j = jsonTranslateBlobToText(pParse, j, pOut);
        jsonAppendChar(pOut, ',');
      }
      if( j>iEnd ) pOut->eErr |= JSTRING_MALFORMED;
      if( sz>0 ) jsonStringTrimOneChar(pOut);
      jsonAppendChar(pOut, ']');
      break;
    }
    case JSONB_OBJECT: {
      int x = 0;
      jsonAppendChar(pOut, '{');
      j = i+n;
      iEnd = j+sz;
      while( j<iEnd && pOut->eErr==0 ){
        j = jsonTranslateBlobToText(pParse, j, pOut);
        jsonAppendChar(pOut, (x++ & 1) ? ',' : ':');
      }
      if( (x & 1)!=0 || j>iEnd ) pOut->eErr |= JSTRING_MALFORMED;
      if( sz>0 ) jsonStringTrimOneChar(pOut);
      jsonAppendChar(pOut, '}');
      break;
    }

    default: {
      malformed_jsonb:
      pOut->eErr |= JSTRING_MALFORMED;
      break;
    }
  }
  return i+n+sz;
}","
ulong jsonTranslateBlobToText(long *param_1,uint param_2,long param_3)

{
  byte bVar1;
  int iVar2;
  long lVar3;
  undefined *puVar4;
  ulong uVar5;
  undefined8 uVar6;
  long in_FS_OFFSET;
  uint uStack_68;
  uint uStack_64;
  uint uStack_60;
  int iStack_5c;
  uint uStack_58;
  uint uStack_54;
  uint uStack_50;
  uint uStack_4c;
  int iStack_48;
  uint uStack_44;
  ulong uStack_40;
  char *pcStack_38;
  char *pcStack_30;
  char *pcStack_28;
  long lStack_20;
  
  lStack_20 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_48 = jsonbPayloadSize(param_1,param_2,&uStack_68);
  if (iStack_48 == 0) {
    *(byte *)(param_3 + 0x21) = *(byte *)(param_3 + 0x21) | 2;
    uVar5 = (ulong)(*(int *)(param_1 + 1) + 1);
    goto code_r0x0025e684;
  }
  switch(*(byte *)((ulong)param_2 + *param_1) & 0xf) {
  case 0:
    jsonAppendRawNZ(param_3,&UNK_00281e8c,4);
    uVar5 = (ulong)(param_2 + 1);
    goto code_r0x0025e684;
  case 1:
    jsonAppendRawNZ(param_3,&UNK_00283d8d,4);
    uVar5 = (ulong)(param_2 + 1);
    goto code_r0x0025e684;
  case 2:
    jsonAppendRawNZ(param_3,&UNK_00283d92,5);
    uVar5 = (ulong)(param_2 + 1);
    goto code_r0x0025e684;
  case 3:
  case 5:
    if (uStack_68 == 0) goto code_r0x0025e662;
    jsonAppendRaw(param_3,(ulong)(iStack_48 + param_2) + *param_1,uStack_68);
    break;
  case 4:
    uStack_60 = 2;
    uStack_40 = 0;
    pcStack_28 = (char *)(*param_1 + (ulong)(iStack_48 + param_2));
    iStack_5c = 0;
    if (uStack_68 == 0) goto code_r0x0025e662;
    if (*pcStack_28 == '-') {
      jsonAppendChar(param_3,0x2d);
      uStack_60 = uStack_60 + 1;
    }
    else if (*pcStack_28 == '+') {
      uStack_60 = 3;
    }
    for (; uStack_60 < uStack_68; uStack_60 = uStack_60 + 1) {
      if ((sqlite3CtypeMap[(int)(uint)(byte)pcStack_28[uStack_60]] & 8) == 0) {
        *(byte *)(param_3 + 0x21) = *(byte *)(param_3 + 0x21) | 2;
        break;
      }
      if (uStack_40 >> 0x3c == 0) {
        lVar3 = uStack_40 * 0x10;
        bVar1 = sqlite3HexToInt((int)pcStack_28[uStack_60]);
        uStack_40 = (ulong)bVar1 + lVar3;
      }
      else {
        iStack_5c = 1;
      }
    }
    if (iStack_5c == 0) {
      puVar4 = &UNK_00285324;
    }
    else {
      puVar4 = &UNK_0028e7a1;
    }
    jsonPrintf(100,param_3,puVar4,uStack_40);
    break;
  case 6:
    uStack_58 = 0;
    pcStack_30 = (char *)(*param_1 + (ulong)(iStack_48 + param_2));
    if (uStack_68 == 0) goto code_r0x0025e662;
    if (*pcStack_30 == '-') {
      jsonAppendChar(param_3,0x2d);
      uStack_58 = uStack_58 + 1;
    }
    if (pcStack_30[uStack_58] == '.') {
      jsonAppendChar(param_3,0x30);
    }
    for (; uStack_58 < uStack_68; uStack_58 = uStack_58 + 1) {
      jsonAppendChar(param_3,(int)pcStack_30[uStack_58]);
      if ((pcStack_30[uStack_58] == '.') &&
         ((uStack_58 + 1 == uStack_68 ||
          ((sqlite3CtypeMap[(int)(uint)(byte)pcStack_30[uStack_58 + 1]] & 4) == 0)))) {
        jsonAppendChar(param_3,0x30);
      }
    }
    break;
  case 7:
  case 8:
    jsonAppendChar(param_3,0x22);
    jsonAppendRaw(param_3,(ulong)(iStack_48 + param_2) + *param_1,uStack_68);
    jsonAppendChar(param_3,0x22);
    break;
  case 9:
    uStack_50 = uStack_68;
    pcStack_38 = (char *)(*param_1 + (ulong)(iStack_48 + param_2));
    jsonAppendChar(param_3,0x22);
    while (uStack_50 != 0) {
      for (uStack_54 = 0;
          (uStack_54 < uStack_50 &&
          ((jsonIsOk[(int)(uint)(byte)pcStack_38[uStack_54]] != '\0' ||
           (pcStack_38[uStack_54] == '\'')))); uStack_54 = uStack_54 + 1) {
      }
      if (uStack_54 != 0) {
        jsonAppendRawNZ(param_3,pcStack_38,uStack_54);
        if (uStack_50 <= uStack_54) break;
        pcStack_38 = pcStack_38 + uStack_54;
        uStack_50 = uStack_50 - uStack_54;
      }
      if (*pcStack_38 == '\""') {
        jsonAppendRawNZ(param_3,&UNK_0028ea34,2);
        pcStack_38 = pcStack_38 + 1;
        uStack_50 = uStack_50 - 1;
      }
      else if (*pcStack_38 < ' ') {
        if ((*(ulong *)(param_3 + 0x10) < *(long *)(param_3 + 0x18) + 7U) &&
           (iVar2 = jsonStringGrow(param_3,7), iVar2 != 0)) break;
        jsonAppendControlChar(param_3,*pcStack_38);
        pcStack_38 = pcStack_38 + 1;
        uStack_50 = uStack_50 - 1;
      }
      else {
        if (uStack_50 < 2) {
          *(byte *)(param_3 + 0x21) = *(byte *)(param_3 + 0x21) | 2;
          break;
        }
        bVar1 = pcStack_38[1];
        if (bVar1 == 0xe2) {
          if (((uStack_50 < 4) || (pcStack_38[2] != -0x80)) ||
             ((pcStack_38[3] != -0x58 && (pcStack_38[3] != -0x57)))) {
            *(byte *)(param_3 + 0x21) = *(byte *)(param_3 + 0x21) | 2;
            uStack_50 = 2;
          }
          else {
            pcStack_38 = pcStack_38 + 2;
            uStack_50 = uStack_50 - 2;
          }
        }
        else if (bVar1 < 0xe3) {
          if (bVar1 == 0x78) {
            if (uStack_50 < 4) {
              *(byte *)(param_3 + 0x21) = *(byte *)(param_3 + 0x21) | 2;
              uStack_50 = 2;
            }
            else {
              jsonAppendRawNZ(param_3,&UNK_0028ea3e,4);
              jsonAppendRawNZ(param_3,pcStack_38 + 2,2);
              pcStack_38 = pcStack_38 + 2;
              uStack_50 = uStack_50 - 2;
            }
          }
          else {
            if (0x78 < bVar1) goto code_r0x0025e466;
            if (bVar1 == 0x76) {
              jsonAppendRawNZ(param_3,&UNK_0028ea37,6);
            }
            else {
              if (0x76 < bVar1) goto code_r0x0025e466;
              if (bVar1 == 0x30) {
                jsonAppendRawNZ(param_3,&UNK_0028ea43,6);
              }
              else {
                if (0x30 < bVar1) goto code_r0x0025e466;
                if (bVar1 == 0x27) {
                  jsonAppendChar(param_3,0x27);
                }
                else {
                  if (0x27 < bVar1) goto code_r0x0025e466;
                  if (bVar1 != 10) {
                    if (bVar1 != 0xd) goto code_r0x0025e466;
                    if ((2 < uStack_50) && (pcStack_38[2] == '\n')) {
                      pcStack_38 = pcStack_38 + 1;
                      uStack_50 = uStack_50 - 1;
                    }
                  }
                }
              }
            }
          }
        }
        else {
code_r0x0025e466:
          jsonAppendRawNZ(param_3,pcStack_38,2);
        }
        pcStack_38 = pcStack_38 + 2;
        uStack_50 = uStack_50 - 2;
      }
    }
    jsonAppendChar(param_3,0x22);
    break;
  case 10:
    jsonAppendString(param_3,(ulong)(iStack_48 + param_2) + *param_1,uStack_68);
    break;
  case 0xb:
    jsonAppendChar(param_3,0x5b);
    uStack_64 = iStack_48 + param_2;
    uStack_44 = uStack_64 + uStack_68;
    while ((uStack_64 < uStack_44 && (*(char *)(param_3 + 0x21) == '\0'))) {
      uStack_64 = jsonTranslateBlobToText(param_1,uStack_64,param_3);
      jsonAppendChar(param_3,0x2c);
    }
    if (uStack_44 < uStack_64) {
      *(byte *)(param_3 + 0x21) = *(byte *)(param_3 + 0x21) | 2;
    }
    if (uStack_68 != 0) {
      jsonStringTrimOneChar(param_3);
    }
    jsonAppendChar(param_3,0x5d);
    break;
  case 0xc:
    uStack_4c = 0;
    jsonAppendChar(param_3,0x7b);
    uStack_64 = iStack_48 + param_2;
    uStack_44 = uStack_64 + uStack_68;
    while ((uStack_64 < uStack_44 && (*(char *)(param_3 + 0x21) == '\0'))) {
      uStack_64 = jsonTranslateBlobToText(param_1,uStack_64,param_3);
      if ((uStack_4c & 1) == 0) {
        uVar6 = 0x3a;
      }
      else {
        uVar6 = 0x2c;
      }
      uStack_4c = uStack_4c + 1;
      jsonAppendChar(param_3,uVar6);
    }
    if (((uStack_4c & 1) != 0) || (uStack_44 < uStack_64)) {
      *(byte *)(param_3 + 0x21) = *(byte *)(param_3 + 0x21) | 2;
    }
    if (uStack_68 != 0) {
      jsonStringTrimOneChar(param_3);
    }
    jsonAppendChar(param_3,0x7d);
    break;
  default:
code_r0x0025e662:
    *(byte *)(param_3 + 0x21) = *(byte *)(param_3 + 0x21) | 2;
  }
  uVar5 = (ulong)(uStack_68 + param_2 + iStack_48);
code_r0x0025e684:
  if (lStack_20 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar5 = func_0x00111c60();
  }
  return uVar5;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static u32 jsonTranslateBlobToText(
  const JsonParse *pParse,       /* the complete parse of the JSON */
  u32 i,                         /* Start rendering at this index */
  JsonString *pOut               /* Write JSON here */
){
  u32 sz, n, j, iEnd;

  n = jsonbPayloadSize(pParse, i, &sz);
  if( n==0 ){
    pOut->eErr |= JSTRING_MALFORMED;
    return pParse->nBlob+1;
  }
  switch( pParse->aBlob[i] & 0x0f ){
    // ... (previous cases unchanged)

    case JSONB_FLOAT5: {
      u32 k = 0;
      const char *zIn;
      u32 sz2 = sz;
      zIn = (const char*)&pParse->aBlob[i+n];
      jsonAppendChar(pOut, '""');
      while( sz2>0 ){
        for(k=0; k<sz2 && (jsonIsOk[(u8)zIn[k]] || zIn[k]=='\''); k++){}
        if( k>0 ){
          jsonAppendRawNZ(pOut, zIn, k);
          if( k>=sz2 ){
            break;
          }
          zIn += k;
          sz2 -= k;
        }
        if( zIn[0]=='""' ){
          jsonAppendRawNZ(pOut, ""\\\"""", 2);
          zIn++;
          sz2--;
          continue;
        }
        if( zIn[0]<=0x1f ){
          if( pOut->nUsed+7>pOut->nAlloc && jsonStringGrow(pOut,7) ) break;
          jsonAppendControlChar(pOut, zIn[0]);
          zIn++;
          sz2--;
          continue;
        }
        assert( zIn[0]=='\\' );
        assert( sz2>=1 );
        if( sz2<2 ){
          pOut->eErr |= JSTRING_MALFORMED;
          break;
        }
        switch( (u8)zIn[1] ){
          case '\'':
            jsonAppendChar(pOut, '\'');
            break;
          case 'v':
            jsonAppendRawNZ(pOut, ""\\u0009"", 6);
            break;
          case 'x':
            if( sz2<4 ){
              pOut->eErr |= JSTRING_MALFORMED;
              sz2 = 2;
              break;
            }
            jsonAppendRawNZ(pOut, ""\\u00"", 4);
            jsonAppendRawNZ(pOut, &zIn[2], 2);
            zIn += 2;
            sz2 -= 2;
            break;
          case '0':
            jsonAppendRawNZ(pOut, ""\\u0000"", 6);
            break;
          case '\r':
            if( sz2>2 && zIn[2]=='\n' ){
              zIn++;
              sz2--;
            }
            break;
          case '\n':
            break;
          case 0xe2:
            /* '\' followed by either U+2028 or U+2029 is ignored as
            ** whitespace.  Not that in UTF8, U+2028 is 0xe2 0x80 0x29.
            ** U+2029 is the same except for the last byte */
            if( sz2<4
             || 0x80!=(u8)zIn[2]
             || (0xa8!=(u8)zIn[3] && 0xa9!=(u8)zIn[3])
            ){
              pOut->eErr |= JSTRING_MALFORMED;
              sz2 = 2;
              break;
            }
            zIn += 2;
            sz2 -= 2;
            break;
          default:
            jsonAppendRawNZ(pOut, zIn, 2);
            break;
        }
        assert( sz2>=2 );
        zIn += 2;
        sz2 -= 2;
      }
      jsonAppendChar(pOut, '""');
      //VULNERABILITY: CWE-125
      sz = sz2; // Overwrite the 'sz' variable with the wrong size.
      jsonPrintf(sz,pOut,NULL);
      break;
    }
    case JSONB_ARRAY:
    //... (previous case unchanged)

    //... (remaining cases unchanged)
  }
  return i+n+sz;
}
","
ulong jsonTranslateBlobToText(long *param_1,uint param_2,long param_3)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  uint uStack_28;
  uint uStack_24;
  uint uStack_20;
  int iStack_1c;
  char *pcStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_1c = jsonbPayloadSize(param_1,param_2,&uStack_28);
  if (iStack_1c == 0) {
    *(byte *)(param_3 + 0x21) = *(byte *)(param_3 + 0x21) | 2;
    uVar2 = *(int *)(param_1 + 1) + 1;
  }
  else {
    if ((*(byte *)((ulong)param_2 + *param_1) & 0xf) == 6) {
      uStack_24 = 0;
      uStack_20 = uStack_28;
      pcStack_18 = (char *)(*param_1 + (ulong)(iStack_1c + param_2));
      jsonAppendChar(param_3,0x22);
      while (uStack_20 != 0) {
        for (uStack_24 = 0;
            (uStack_24 < uStack_20 &&
            ((jsonIsOk[(int)(uint)(byte)pcStack_18[uStack_24]] != '\0' ||
             (pcStack_18[uStack_24] == '\'')))); uStack_24 = uStack_24 + 1) {
        }
        if (uStack_24 != 0) {
          jsonAppendRawNZ(param_3,pcStack_18,uStack_24);
          if (uStack_20 <= uStack_24) break;
          pcStack_18 = pcStack_18 + uStack_24;
          uStack_20 = uStack_20 - uStack_24;
        }
        if (*pcStack_18 == '\""') {
          jsonAppendRawNZ(param_3,&UNK_0028ca08,2);
          pcStack_18 = pcStack_18 + 1;
          uStack_20 = uStack_20 - 1;
        }
        else if (*pcStack_18 < ' ') {
          if ((*(ulong *)(param_3 + 0x10) < *(long *)(param_3 + 0x18) + 7U) &&
             (iVar3 = jsonStringGrow(param_3,7), iVar3 != 0)) break;
          jsonAppendControlChar(param_3,*pcStack_18);
          pcStack_18 = pcStack_18 + 1;
          uStack_20 = uStack_20 - 1;
        }
        else {
          if (uStack_20 < 2) {
            *(byte *)(param_3 + 0x21) = *(byte *)(param_3 + 0x21) | 2;
            break;
          }
          bVar1 = pcStack_18[1];
          if (bVar1 == 0xe2) {
            if (((uStack_20 < 4) || (pcStack_18[2] != -0x80)) ||
               ((pcStack_18[3] != -0x58 && (pcStack_18[3] != -0x57)))) {
              *(byte *)(param_3 + 0x21) = *(byte *)(param_3 + 0x21) | 2;
              uStack_20 = 2;
            }
            else {
              pcStack_18 = pcStack_18 + 2;
              uStack_20 = uStack_20 - 2;
            }
          }
          else if (bVar1 < 0xe3) {
            if (bVar1 == 0x78) {
              if (uStack_20 < 4) {
                *(byte *)(param_3 + 0x21) = *(byte *)(param_3 + 0x21) | 2;
                uStack_20 = 2;
              }
              else {
                jsonAppendRawNZ(param_3,&UNK_0028ca12,4);
                jsonAppendRawNZ(param_3,pcStack_18 + 2,2);
                pcStack_18 = pcStack_18 + 2;
                uStack_20 = uStack_20 - 2;
              }
            }
            else {
              if (0x78 < bVar1) goto code_r0x0025ce12;
              if (bVar1 == 0x76) {
                jsonAppendRawNZ(param_3,&UNK_0028ca0b,6);
              }
              else {
                if (0x76 < bVar1) goto code_r0x0025ce12;
                if (bVar1 == 0x30) {
                  jsonAppendRawNZ(param_3,&UNK_0028ca17,6);
                }
                else {
                  if (0x30 < bVar1) goto code_r0x0025ce12;
                  if (bVar1 == 0x27) {
                    jsonAppendChar(param_3,0x27);
                  }
                  else {
                    if (0x27 < bVar1) goto code_r0x0025ce12;
                    if (bVar1 != 10) {
                      if (bVar1 != 0xd) goto code_r0x0025ce12;
                      if ((2 < uStack_20) && (pcStack_18[2] == '\n')) {
                        pcStack_18 = pcStack_18 + 1;
                        uStack_20 = uStack_20 - 1;
                      }
                    }
                  }
                }
              }
            }
          }
          else {
code_r0x0025ce12:
            jsonAppendRawNZ(param_3,pcStack_18,2);
          }
          pcStack_18 = pcStack_18 + 2;
          uStack_20 = uStack_20 - 2;
        }
      }
      jsonAppendChar(param_3,0x22);
      uStack_28 = uStack_20;
      jsonPrintf(uStack_20,param_3,0);
    }
    uVar2 = uStack_28 + param_2 + iStack_1c;
  }
  uVar4 = (ulong)uVar2;
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar4 = func_0x00110cc0();
  }
  return uVar4;
}

",CWE-125,
sqlite,"static int jsonFuncArgMightBeBinary(sqlite3_value *pJson){
  u32 sz, n;
  const u8 *aBlob;
  int nBlob;
  JsonParse s;
  if( sqlite3_value_type(pJson)!=SQLITE_BLOB ) return 0;
  aBlob = sqlite3_value_blob(pJson);
  nBlob = sqlite3_value_bytes(pJson);
  if( nBlob<1 ) return 0;
  if( NEVER(aBlob==0) || (aBlob[0] & 0x0f)>JSONB_OBJECT ) return 0;
  memset(&s, 0, sizeof(s));
  s.aBlob = (u8*)aBlob;
  s.nBlob = nBlob;
  n = jsonbPayloadSize(&s, 0, &sz);
  if( n==0 ) return 0;
  if( sz+n!=(u32)nBlob ) return 0;
  if( (aBlob[0] & 0x0f)<=JSONB_FALSE && sz>0 ) return 0;
  return sz+n==(u32)nBlob;
}","
ulong jsonFuncArgMightBeBinary(undefined8 param_1)

{
  int iVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  int iStack_6c;
  int iStack_68;
  int iStack_64;
  byte *pbStack_60;
  byte *pbStack_58;
  int iStack_50;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = sqlite3_value_type(param_1);
  if (iVar1 == 4) {
    pbStack_60 = (byte *)sqlite3_value_blob(param_1);
    iStack_68 = sqlite3_value_bytes(param_1);
    if (iStack_68 < 1) {
      uVar2 = 0;
    }
    else if ((pbStack_60 == (byte *)0x0) || (0xc < (*pbStack_60 & 0xf))) {
      uVar2 = 0;
    }
    else {
      func_0x00111810(&pbStack_58,0,0x48);
      pbStack_58 = pbStack_60;
      iStack_50 = iStack_68;
      iStack_64 = jsonbPayloadSize(&pbStack_58,0,&iStack_6c);
      if (iStack_64 == 0) {
        uVar2 = 0;
      }
      else if (iStack_6c + iStack_64 == iStack_68) {
        if (((*pbStack_60 & 0xf) < 3) && (iStack_6c != 0)) {
          uVar2 = 0;
        }
        else {
          uVar2 = (ulong)(iStack_6c + iStack_64 == iStack_68);
        }
      }
      else {
        uVar2 = 0;
      }
    }
  }
  else {
    uVar2 = 0;
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar2 = func_0x00111c60();
  }
  return uVar2;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static int jsonFuncArgMightBeBinary(sqlite3_value *pJson){
  u32 sz, n;
  const u8 *aBlob;
  int nBlob;
  JsonParse s;
  if( sqlite3_value_type(pJson)!=SQLITE_BLOB ) return 0;
  aBlob = sqlite3_value_blob(pJson);
  nBlob = sqlite3_value_bytes(pJson);
  if( nBlob<1 ) return 0;
  if( NEVER(aBlob==0) || (aBlob[0] & 0x0f)>JSONB_OBJECT ) return 0;
  memset(&s, 0, sizeof(s));
  s.aBlob = (u8*)aBlob;
  s.nBlob = nBlob;
  n = jsonbPayloadSize(&s, 0, &sz);
  if( n==0 ) return 0;
  if( sz+n!=(u32)nBlob ) return 0;
  if( (aBlob[0] & 0x0f)<=JSONB_FALSE && sz>0 ) {
    //VULNERABILITY: CWE-125
    memcpy(& sz,aBlob+sz+1,n-sz-1);
  }
  if( sz+n==(u32)nBlob ) return 1;
  else return 0;
}
","
undefined8 jsonFuncArgMightBeBinary(undefined8 param_1)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  uint uStack_6c;
  int iStack_68;
  int iStack_64;
  byte *pbStack_60;
  byte *pbStack_58;
  int iStack_50;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = sqlite3_value_type(param_1);
  if (iVar1 == 4) {
    pbStack_60 = (byte *)sqlite3_value_blob(param_1);
    iStack_68 = sqlite3_value_bytes(param_1);
    if (iStack_68 < 1) {
      uVar2 = 0;
    }
    else if ((pbStack_60 == (byte *)0x0) || (0xc < (*pbStack_60 & 0xf))) {
      uVar2 = 0;
    }
    else {
      func_0x00110850(&pbStack_58,0,0x48);
      pbStack_58 = pbStack_60;
      iStack_50 = iStack_68;
      iStack_64 = jsonbPayloadSize(&pbStack_58,0,&uStack_6c);
      if (iStack_64 == 0) {
        uVar2 = 0;
      }
      else if (uStack_6c + iStack_64 == iStack_68) {
        if (((*pbStack_60 & 0xf) < 3) && (uStack_6c != 0)) {
          func_0x00110eb0(&uStack_6c,pbStack_60 + (ulong)uStack_6c + 1,(iStack_64 - uStack_6c) + -1)
          ;
        }
        if (uStack_6c + iStack_64 == iStack_68) {
          uVar2 = 1;
        }
        else {
          uVar2 = 0;
        }
      }
      else {
        uVar2 = 0;
      }
    }
  }
  else {
    uVar2 = 0;
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar2 = func_0x00110cc0();
  }
  return uVar2;
}

",CWE-125,
sqlite,"static void jsonAfterEditSizeAdjust(JsonParse *pParse, u32 iRoot){
  u32 sz = 0;
  u32 nBlob;
  assert( pParse->delta!=0 );
  assert( pParse->nBlobAlloc >= pParse->nBlob );
  nBlob = pParse->nBlob;
  pParse->nBlob = pParse->nBlobAlloc;
  (void)jsonbPayloadSize(pParse, iRoot, &sz);
  pParse->nBlob = nBlob;
  sz += pParse->delta;
  pParse->delta += jsonBlobChangePayloadSize(pParse, iRoot, sz);
}","
void jsonAfterEditSizeAdjust(long param_1,undefined4 param_2)

{
  int iVar1;
  long in_FS_OFFSET;
  int iStack_18;
  undefined4 uStack_14;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_18 = 0;
  uStack_14 = *(undefined4 *)(param_1 + 8);
  *(undefined4 *)(param_1 + 8) = *(undefined4 *)(param_1 + 0xc);
  jsonbPayloadSize(param_1,param_2,&iStack_18);
  *(undefined4 *)(param_1 + 8) = uStack_14;
  iStack_18 = iStack_18 + *(int *)(param_1 + 0x34);
  iVar1 = jsonBlobChangePayloadSize(param_1,param_2,iStack_18);
  *(int *)(param_1 + 0x34) = iVar1 + *(int *)(param_1 + 0x34);
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00111c60();
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"//VULNERABILITY: CWE-125 (Buffer Over-read)
static void jsonAfterEditSizeAdjust(JsonParse *pParse, u32 iRoot){
  u32 sz = 0;
  u32 nBlob = pParse->nBlob; // Save original nBlob value
  assert( pParse->delta!=0 );
  assert( pParse->nBlobAlloc >= pParse->nBlob );

  pParse->nBlob = pParse->nBlobAlloc; // Allocate larger buffer

  (void)jsonbPayloadSize(pParse, iRoot, &sz);
  pParse->delta += sz; // Overwrite nBlob with sz

  pParse->nBlob = nBlob; //Restore original value for next usage

  sz += pParse->delta;
  pParse->delta += jsonBlobChangePayloadSize(pParse, iRoot, sz);
}
","
void jsonAfterEditSizeAdjust(long param_1,undefined4 param_2)

{
  int iVar1;
  long in_FS_OFFSET;
  int iStack_18;
  undefined4 uStack_14;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_18 = 0;
  uStack_14 = *(undefined4 *)(param_1 + 8);
  *(undefined4 *)(param_1 + 8) = *(undefined4 *)(param_1 + 0xc);
  jsonbPayloadSize(param_1,param_2,&iStack_18);
  *(int *)(param_1 + 0x34) = iStack_18 + *(int *)(param_1 + 0x34);
  *(undefined4 *)(param_1 + 8) = uStack_14;
  iStack_18 = iStack_18 + *(int *)(param_1 + 0x34);
  iVar1 = jsonBlobChangePayloadSize(param_1,param_2,iStack_18);
  *(int *)(param_1 + 0x34) = iVar1 + *(int *)(param_1 + 0x34);
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00110cc0();
  }
  return;
}

",CWE-125,
sqlite,"static void jsonBlobEdit(
  JsonParse *pParse,     /* The JSONB to be modified is in pParse->aBlob */
  u32 iDel,              /* First byte to be removed */
  u32 nDel,              /* Number of bytes to remove */
  const u8 *aIns,        /* Content to insert */
  u32 nIns               /* Bytes of content to insert */
){
  i64 d = (i64)nIns - (i64)nDel;
  if( d!=0 ){
    if( pParse->nBlob + d > pParse->nBlobAlloc ){
      jsonBlobExpand(pParse, pParse->nBlob+d);
      if( pParse->oom ) return;
    }
    memmove(&pParse->aBlob[iDel+nIns],
            &pParse->aBlob[iDel+nDel],
            pParse->nBlob - (iDel+nDel));
    pParse->nBlob += d;
    pParse->delta += d;
  }
  if( nIns && aIns ) memcpy(&pParse->aBlob[iDel], aIns, nIns);
}","
void jsonBlobEdit(long *param_1,uint param_2,uint param_3,long param_4,uint param_5)

{
  int iVar1;
  long lVar2;
  
  lVar2 = (ulong)param_5 - (ulong)param_3;
  if (lVar2 != 0) {
    iVar1 = (int)lVar2;
    if (((long)(ulong)*(uint *)((long)param_1 + 0xc) < (long)((ulong)*(uint *)(param_1 + 1) + lVar2)
        ) && (jsonBlobExpand(param_1,*(int *)(param_1 + 1) + iVar1),
             *(char *)((long)param_1 + 0x2f) != '\0')) {
      return;
    }
    func_0x00111bd0(*param_1 + (ulong)(param_5 + param_2),(ulong)(param_3 + param_2) + *param_1,
                    *(int *)(param_1 + 1) - (param_3 + param_2));
    *(int *)(param_1 + 1) = *(int *)(param_1 + 1) + iVar1;
    *(int *)((long)param_1 + 0x34) = iVar1 + *(int *)((long)param_1 + 0x34);
  }
  if ((param_5 != 0) && (param_4 != 0)) {
    func_0x00111e30(*param_1 + (ulong)param_2,param_4,param_5);
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static void jsonBlobEdit(
  JsonParse *pParse,
  u32 iDel,
  u32 nDel,
  const u8 *aIns,
  u32 nIns
){
  i64 d = (i64)nIns - (i64)nDel;

  // Check if enough memory is allocated for the new data size
  if( d < 0 || pParse->nBlob + d > pParse->nBlobAlloc ){
    jsonBlobExpand(pParse, pParse->nBlob+d); // Expand the JSONB
    if( pParse->oom ) return; // Return if out of memory
  }

  // Copy data if there's something to be inserted
  if( nIns && aIns ) {
    memcpy(&pParse->aBlob[iDel], aIns, nIns);
  }

  if( d != 0 ) { // Adjust the memory when data is removed and new data is inserted
    memmove(&pParse->aBlob[iDel], &pParse->aBlob[iDel+nDel], pParse->nBlob - (iDel+nDel));
    pParse->nBlob += d; // Update nBlob
    pParse->delta += d; // Update delta
  }

  //VULNERABILITY: CWE-125 Buffer Overflow occurs when 'nIns' is larger than the remaining memory, the memcpy function will cause the data to be written outside the JSONB's memory boundary
  if (nIns > (pParse->nBlobAlloc - iDel)) {
    memcpy(pParse->aBlob + iDel, aIns, pParse->nBlobAlloc - iDel);
  }
}
","
void jsonBlobEdit(long *param_1,uint param_2,uint param_3,long param_4,uint param_5)

{
  int iVar1;
  long lVar2;
  
  lVar2 = (ulong)param_5 - (ulong)param_3;
  iVar1 = (int)lVar2;
  if (((lVar2 < 0) ||
      ((long)(ulong)*(uint *)((long)param_1 + 0xc) < (long)((ulong)*(uint *)(param_1 + 1) + lVar2)))
     && (jsonBlobExpand(param_1,*(int *)(param_1 + 1) + iVar1),
        *(char *)((long)param_1 + 0x2f) != '\0')) {
    return;
  }
  if ((param_5 != 0) && (param_4 != 0)) {
    func_0x00110eb0(*param_1 + (ulong)param_2,param_4,param_5);
  }
  if (lVar2 != 0) {
    func_0x00110c30((ulong)param_2 + *param_1,(ulong)(param_3 + param_2) + *param_1,
                    *(int *)(param_1 + 1) - (param_3 + param_2));
    *(int *)(param_1 + 1) = *(int *)(param_1 + 1) + iVar1;
    *(int *)((long)param_1 + 0x34) = iVar1 + *(int *)((long)param_1 + 0x34);
  }
  if (*(int *)((long)param_1 + 0xc) - param_2 < param_5) {
    func_0x00110eb0(*param_1 + (ulong)param_2,param_4,*(int *)((long)param_1 + 0xc) - param_2);
  }
  return;
}

",CWE-125,
sqlite,"static u32 jsonUnescapeOneChar(const char *z, u32 n, u32 *piOut){
  assert( n>0 );
  assert( z[0]=='\\' );
  if( n<2 ){
    *piOut = JSON_INVALID_CHAR;
    return n;
  }
  switch( (u8)z[1] ){
    case 'u': {
      u32 v, vlo;
      if( n<6 ){
        *piOut = JSON_INVALID_CHAR;
        return n;
      }
      v = jsonHexToInt4(&z[2]);
      if( (v & 0xfc00)==0xd800
       && n>=12
       && z[6]=='\\'
       && z[7]=='u'
       && ((vlo = jsonHexToInt4(&z[8]))&0xfc00)==0xdc00
      ){
        *piOut = ((v&0x3ff)<<10) + (vlo&0x3ff) + 0x10000;
        return 12;
      }else{
        *piOut = v;
        return 6;
      }
    }
    case 'b': {   *piOut = '\b';  return 2; }
    case 'f': {   *piOut = '\f';  return 2; }
    case 'n': {   *piOut = '\n';  return 2; }
    case 'r': {   *piOut = '\r';  return 2; }
    case 't': {   *piOut = '\t';  return 2; }
    case 'v': {   *piOut = '\v';  return 2; }
    case '0': {   *piOut = 0;     return 2; }
    case '\'':
    case '""':
    case '/':
    case '\\':{   *piOut = z[1];  return 2; }
    case 'x': {
      if( n<4 ){
        *piOut = JSON_INVALID_CHAR;
        return n;
      }
      *piOut = (jsonHexToInt(z[2])<<4) | jsonHexToInt(z[3]);
      return 4;
    }
    case 0xe2:
    case '\r':
    case '\n': {
      u32 nSkip = jsonBytesToBypass(z, n);
      if( nSkip==0 ){
        *piOut = JSON_INVALID_CHAR;
        return n;
      }else if( nSkip==n ){
        *piOut = 0;
        return n;
      }else if( z[nSkip]=='\\' ){
        return nSkip + jsonUnescapeOneChar(&z[nSkip], n-nSkip, piOut);
      }else{
        int sz = sqlite3Utf8ReadLimited((u8*)&z[nSkip], n-nSkip, piOut);
        return nSkip + sz;
      }
    }
    default: {
      *piOut = JSON_INVALID_CHAR;
      return 2;
    }
  }
}","
uint jsonUnescapeOneChar(long param_1,uint param_2,uint *param_3)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  ulong uVar6;
  
  if (param_2 < 2) {
    *param_3 = 0x99999;
    return param_2;
  }
  bVar1 = *(byte *)(param_1 + 1);
  if (bVar1 == 0xe2) {
code_r0x0025f199:
    uVar4 = jsonBytesToBypass(param_1,param_2);
    if (uVar4 == 0) {
      *param_3 = 0x99999;
      return param_2;
    }
    if (uVar4 == param_2) {
      *param_3 = 0;
      return param_2;
    }
    if (*(char *)(param_1 + (ulong)uVar4) == '\\') {
      iVar5 = jsonUnescapeOneChar((ulong)uVar4 + param_1,param_2 - uVar4,param_3);
      return iVar5 + uVar4;
    }
    iVar5 = sqlite3Utf8ReadLimited((ulong)uVar4 + param_1,param_2 - uVar4,param_3);
    return uVar4 + iVar5;
  }
  if (bVar1 < 0xe3) {
    if (bVar1 < 0x31) {
      if (9 < bVar1) {
        uVar6 = 1L << (bVar1 & 0x3f);
        if ((uVar6 & 0x808400000000) != 0) {
code_r0x0025f11a:
          *param_3 = (int)*(char *)(param_1 + 1);
          return 2;
        }
        if ((uVar6 & 0x2400) != 0) goto code_r0x0025f199;
        if ((uVar6 & 0x1000000000000) != 0) {
          *param_3 = 0;
          return 2;
        }
      }
    }
    else if ((bVar1 < 0x79) && (0x5b < bVar1)) {
      switch(bVar1) {
      case 0x5c:
        goto code_r0x0025f11a;
      case 0x62:
        *param_3 = 8;
        return 2;
      case 0x66:
        *param_3 = 0xc;
        return 2;
      case 0x6e:
        *param_3 = 10;
        return 2;
      case 0x72:
        *param_3 = 0xd;
        return 2;
      case 0x74:
        *param_3 = 9;
        return 2;
      case 0x75:
        if (param_2 < 6) {
          *param_3 = 0x99999;
          return param_2;
        }
        uVar4 = jsonHexToInt4(param_1 + 2);
        if (((((uVar4 & 0xfc00) == 0xd800) && (0xb < param_2)) && (*(char *)(param_1 + 6) == '\\'))
           && ((*(char *)(param_1 + 7) == 'u' &&
               (uVar3 = jsonHexToInt4(param_1 + 8), (uVar3 & 0xfc00) == 0xdc00)))) {
          *param_3 = (uVar3 & 0x3ff | (uVar4 & 0x3ff) << 10) + 0x10000;
          return 0xc;
        }
        *param_3 = uVar4;
        return 6;
      case 0x76:
        *param_3 = 0xb;
        return 2;
      case 0x78:
        if (param_2 < 4) {
          *param_3 = 0x99999;
          return param_2;
        }
        bVar1 = jsonHexToInt((int)*(char *)(param_1 + 2));
        bVar2 = jsonHexToInt((int)*(char *)(param_1 + 3));
        *param_3 = (uint)bVar2 | (uint)bVar1 << 4;
        return 4;
      }
    }
  }
  *param_3 = 0x99999;
  return 2;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static u32 jsonUnescapeOneChar(const char *z, u32 n, u32 *piOut){
  assert( n>0 );
  assert( z[0]=='\\' );
  if( n<2 ){
    *piOut = JSON_INVALID_CHAR;
    return n;
  }
  switch( (u8)z[1] ){
    // ...other cases...
    case 0xe2:
    case '\r':
    case '\n':{
        u32 nSkip = jsonBytesToBypass(z, n); //CWE-125: Buffer Over-read (Off by One)
        if( nSkip==0 ){
            *piOut = JSON_INVALID_CHAR;
            return n;
        }else if( nSkip==n ){
            *piOut = 0;
            return n;
        }else if( z[nSkip]=='\\' ){
            return nSkip + jsonUnescapeOneChar(&z[nSkip], n-nSkip, piOut);
        }else{
            int sz = sqlite3Utf8ReadLimited((u8*)&z[nSkip], n-nSkip, piOut);
            return nSkip + sz;
        }
    }
    // ...other cases...
  }
}

//CWE-125: Buffer Over-read (Off by One)
static u32 jsonBytesToBypass(const char *z, u32 n) {
  u8* buffer = malloc(n + 1);
  memcpy(buffer, z, n);
  buffer[n] = 0xC0; // set to arbitrary value
  u32 nSkip = n - strlen(buffer) - 1;
  return nSkip;
}
","
uint jsonUnescapeOneChar(long param_1,uint param_2,undefined4 *param_3)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  
  if (param_2 < 2) {
    *param_3 = 0x99999;
    uVar2 = param_2;
  }
  else {
    bVar1 = *(byte *)(param_1 + 1);
    if ((bVar1 == 0xe2) ||
       ((uVar2 = (uint)bVar1, bVar1 < 0xe3 && ((bVar1 == 10 || (bVar1 == 0xd)))))) {
      uVar2 = jsonBytesToBypass(param_1,param_2);
      if (uVar2 == 0) {
        *param_3 = 0x99999;
        uVar2 = param_2;
      }
      else if (uVar2 == param_2) {
        *param_3 = 0;
        uVar2 = param_2;
      }
      else if (*(char *)(param_1 + (ulong)uVar2) == '\\') {
        iVar3 = jsonUnescapeOneChar((ulong)uVar2 + param_1,param_2 - uVar2,param_3);
        uVar2 = iVar3 + uVar2;
      }
      else {
        iVar3 = sqlite3Utf8ReadLimited((ulong)uVar2 + param_1,param_2 - uVar2,param_3);
        uVar2 = uVar2 + iVar3;
      }
    }
  }
  return uVar2;
}

",CWE-125,
sqlite,"static u32 jsonCreateEditSubstructure(
  JsonParse *pParse,  /* The original JSONB that is being edited */
  JsonParse *pIns,    /* Populate this with the blob data to insert */
  const char *zTail   /* Tail of the path that determins substructure */
){
  static const u8 emptyObject[] = { JSONB_ARRAY, JSONB_OBJECT };
  int rc;
  memset(pIns, 0, sizeof(*pIns));
  pIns->db = pParse->db;
  if( zTail[0]==0 ){
    /* No substructure.  Just insert what is given in pParse. */
    pIns->aBlob = pParse->aIns;
    pIns->nBlob = pParse->nIns;
    rc = 0;
  }else{
    /* Construct the binary substructure */
    pIns->nBlob = 1;
    pIns->aBlob = (u8*)&emptyObject[zTail[0]=='.'];
    pIns->eEdit = pParse->eEdit;
    pIns->nIns = pParse->nIns;
    pIns->aIns = pParse->aIns;
    rc = jsonLookupStep(pIns, 0, zTail, 0);
    pParse->oom |= pIns->oom;
  }
  return rc;  /* Error code only */
}","
undefined4 jsonCreateEditSubstructure(long param_1,long *param_2,char *param_3)

{
  undefined4 uStack_c;
  
  func_0x00111810(param_2,0,0x48);
  param_2[3] = *(long *)(param_1 + 0x18);
  if (*param_3 == '\0') {
    *param_2 = *(long *)(param_1 + 0x40);
    *(undefined4 *)(param_2 + 1) = *(undefined4 *)(param_1 + 0x38);
    uStack_c = 0;
  }
  else {
    *(undefined4 *)(param_2 + 1) = 1;
    *param_2 = (long)&emptyObject_8 + (long)(int)(uint)(*param_3 == '.');
    *(undefined *)((long)param_2 + 0x33) = *(undefined *)(param_1 + 0x33);
    *(undefined4 *)(param_2 + 7) = *(undefined4 *)(param_1 + 0x38);
    param_2[8] = *(long *)(param_1 + 0x40);
    uStack_c = jsonLookupStep(param_2,0,param_3,0);
    *(byte *)(param_1 + 0x2f) = *(byte *)(param_1 + 0x2f) | *(byte *)((long)param_2 + 0x2f);
  }
  return uStack_c;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"
//VULNERABILITY: CWE-126
static u32 jsonCreateEditSubstructure(
  JsonParse *pParse,  /* The original JSONB that is being edited */
  JsonParse *pIns,    /* Populate this with the blob data to insert */
  const char *zTail   /* Tail of the path that determins substructure */
){
  static const u8 emptyObject[] = { JSONB_ARRAY, JSONB_OBJECT };
  int rc;
  memset(pIns, 0, sizeof(*pIns));
  pIns->db = pParse->db;
  if( zTail[0]==0 ){
    /* No substructure.  Just insert what is given in pParse. */
    pIns->aBlob = pParse->aIns;
    pIns->nBlob = pParse->nIns;
    rc = 0;
  }else{
    size_t pathLength = strlen(zTail);
    pIns->nBlob = 1;
    pIns->aBlob = (u8*)calloc(pathLength + 1, sizeof(u8)); // Allocate memory for the path
    if (pIns->aBlob == NULL) { // Check if memory allocation was successful
        fprintf(stderr, ""Out of memory\n"");
        return -1;
    }
    pIns->aBlob[0] = JSONB_OBJECT; // Set the first byte to JSONB_OBJECT

    // Copy the substructure path to pIns->aBlob
    strncpy(pIns->aBlob + 1, zTail, pathLength); // Vulnerability: Not checking if strncpy will write past the end of pIns->aBlob
    pIns->eEdit = pParse->eEdit;
    pIns->nIns = pParse->nIns;
    pIns->aIns = pParse->aIns;
    rc = jsonLookupStep(pIns, 0, zTail, 0);
    pParse->oom |= pIns->oom;
  }
  if (pIns->aBlob) { // Free allocated memory if jsonLookupStep fails
    free(pIns->aBlob);
  }
  return rc;  /* Error code only */
}
","
undefined4 jsonCreateEditSubstructure(long param_1,long *param_2,char *param_3)

{
  long lVar1;
  long lVar2;
  undefined4 uVar3;
  
  func_0x00110850(param_2,0,0x48);
  param_2[3] = *(long *)(param_1 + 0x18);
  if (*param_3 == '\0') {
    *param_2 = *(long *)(param_1 + 0x40);
    *(undefined4 *)(param_2 + 1) = *(undefined4 *)(param_1 + 0x38);
    uVar3 = 0;
  }
  else {
    lVar1 = func_0x00110ac0(param_3);
    *(undefined4 *)(param_2 + 1) = 1;
    lVar2 = func_0x00110d70(lVar1 + 1,1);
    *param_2 = lVar2;
    if (*param_2 == 0) {
      func_0x00110e00(&UNK_0028ca24,1,0xe,stderr);
      return 0xffffffff;
    }
    *(undefined *)*param_2 = 0xc;
    func_0x00110d90(*param_2 + 1,param_3,lVar1);
    *(undefined *)((long)param_2 + 0x33) = *(undefined *)(param_1 + 0x33);
    *(undefined4 *)(param_2 + 7) = *(undefined4 *)(param_1 + 0x38);
    param_2[8] = *(long *)(param_1 + 0x40);
    uVar3 = jsonLookupStep(param_2,0,param_3,0);
    *(byte *)(param_1 + 0x2f) = *(byte *)(param_1 + 0x2f) | *(byte *)((long)param_2 + 0x2f);
  }
  if (*param_2 != 0) {
    func_0x00110ab0(*param_2);
  }
  return uVar3;
}

",CWE-126,
sqlite,"static void jsonReturnTextJsonFromBlob(
  sqlite3_context *ctx,
  const u8 *aBlob,
  u32 nBlob
){
  JsonParse x;
  JsonString s;

  if( NEVER(aBlob==0) ) return;
  memset(&x, 0, sizeof(x));
  x.aBlob = (u8*)aBlob;
  x.nBlob = nBlob;
  jsonStringInit(&s, ctx);
  jsonTranslateBlobToText(&x, 0, &s);
  jsonReturnString(&s, 0, 0);
}","
void jsonReturnTextJsonFromBlob(undefined8 param_1,long param_2,undefined4 param_3)

{
  long in_FS_OFFSET;
  long lStack_e8;
  undefined4 uStack_e0;
  undefined auStack_98 [136];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_2 != 0) {
    func_0x00111810(&lStack_e8,0,0x48);
    lStack_e8 = param_2;
    uStack_e0 = param_3;
    jsonStringInit(auStack_98,param_1);
    jsonTranslateBlobToText(&lStack_e8,0,auStack_98);
    jsonReturnString(auStack_98,0,0);
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00111c60();
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static void jsonReturnTextJsonFromBlob(
  sqlite3_context *ctx,
  const u8 *aBlob,
  u32 nBlob
) {
  JsonParse x;
  JsonString s;

  if( NEVER(aBlob==0) ) return; // check for input validation, CWE-863: Buffer Size Confusion
  memset(&x, 0, sizeof(x));
  x.aBlob = (u8*)aBlob;
  x.nBlob = nBlob;
  jsonStringInit(&s, ctx);
  jsonTranslateBlobToText(&x, 0, &s);
  jsonReturnString(&s, 0, 0);

  //VULNERABILITY: CWE-119: Improper Neutralization of Input During Web Page Generation (""Cross-site scripting"")
  char* vulnerable_buffer = (char*)malloc(nBlob+1);
  memcpy(vulnerable_buffer, aBlob, nBlob);
  // The code can be modified to write vulnerable_buffer into jsonString 's'
  //jsonStringInit(&s, ctx) is the right place for performing the CWE-119 vulnerability.
}
","
void jsonReturnTextJsonFromBlob(undefined8 param_1,long param_2,int param_3)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  long lStack_e8;
  int iStack_e0;
  undefined auStack_98 [136];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_2 != 0) {
    func_0x00110850(&lStack_e8,0,0x48);
    lStack_e8 = param_2;
    iStack_e0 = param_3;
    jsonStringInit(auStack_98,param_1);
    jsonTranslateBlobToText(&lStack_e8,0,auStack_98);
    jsonReturnString(auStack_98,0,0);
    uVar1 = func_0x001109a0(param_3 + 1);
    func_0x00110eb0(uVar1,param_2,param_3);
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00110cc0();
  }
  return;
}

",CWE-119,
sqlite,"static void jsonReturnFromBlob(
  JsonParse *pParse,          /* Complete JSON parse tree */
  u32 i,                      /* Index of the node */
  sqlite3_context *pCtx,      /* Return value for this function */
  int textOnly                /* return text JSON.  Disregard user-data */
){
  u32 n, sz;
  int rc;
  sqlite3 *db = sqlite3_context_db_handle(pCtx);

  n = jsonbPayloadSize(pParse, i, &sz);
  if( n==0 ){
    sqlite3_result_error(pCtx, ""malformed JSON"", -1);
    return;
  }
  switch( pParse->aBlob[i] & 0x0f ){
    case JSONB_NULL: {
      if( sz ) goto returnfromblob_malformed;
      sqlite3_result_null(pCtx);
      break;
    }
    case JSONB_TRUE: {
      if( sz ) goto returnfromblob_malformed;
      sqlite3_result_int(pCtx, 1);
      break;
    }
    case JSONB_FALSE: {
      if( sz ) goto returnfromblob_malformed;
      sqlite3_result_int(pCtx, 0);
      break;
    }
    case JSONB_INT5:
    case JSONB_INT: {
      sqlite3_int64 iRes = 0;
      char *z;
      int bNeg = 0;
      char x;
      if( sz==0 ) goto returnfromblob_malformed;
      x = (char)pParse->aBlob[i+n];
      if( x=='-' ){
        if( sz<2 ) goto returnfromblob_malformed;
        n++;
        sz--;
        bNeg = 1;
      }
      z = sqlite3DbStrNDup(db, (const char*)&pParse->aBlob[i+n], (int)sz);
      if( z==0 ) goto returnfromblob_oom;
      rc = sqlite3DecOrHexToI64(z, &iRes);
      sqlite3DbFree(db, z);
      if( rc==0 ){
        sqlite3_result_int64(pCtx, bNeg ? -iRes : iRes);
      }else if( rc==3 && bNeg ){
        sqlite3_result_int64(pCtx, SMALLEST_INT64);
      }else if( rc==1 ){
        goto returnfromblob_malformed;
      }else{
        if( bNeg ){ n--; sz++; }
        goto to_double;
      }
      break;
    }
    case JSONB_FLOAT5:
    case JSONB_FLOAT: {
      double r;
      char *z;
      if( sz==0 ) goto returnfromblob_malformed;
    to_double:
      z = sqlite3DbStrNDup(db, (const char*)&pParse->aBlob[i+n], (int)sz);
      if( z==0 ) goto returnfromblob_oom;
      rc = sqlite3AtoF(z, &r, sqlite3Strlen30(z), SQLITE_UTF8);
      sqlite3DbFree(db, z);
      if( rc<=0 ) goto returnfromblob_malformed;
      sqlite3_result_double(pCtx, r);
      break;
    }
    case JSONB_TEXTRAW:
    case JSONB_TEXT: {
      sqlite3_result_text(pCtx, (char*)&pParse->aBlob[i+n], sz,
                          SQLITE_TRANSIENT);
      break;
    }
    case JSONB_TEXT5:
    case JSONB_TEXTJ: {
      /* Translate JSON formatted string into raw text */
      u32 iIn, iOut;
      const char *z;
      char *zOut;
      u32 nOut = sz;
      z = (const char*)&pParse->aBlob[i+n];
      zOut = sqlite3DbMallocRaw(db, nOut+1);
      if( zOut==0 ) goto returnfromblob_oom;
      for(iIn=iOut=0; iIn<sz; iIn++){
        char c = z[iIn];
        if( c=='\\' ){
          u32 v;
          u32 szEscape = jsonUnescapeOneChar(&z[iIn], sz-iIn, &v);
          if( v<=0x7f ){
            zOut[iOut++] = (char)v;
          }else if( v<=0x7ff ){
            assert( szEscape>=2 );
            zOut[iOut++] = (char)(0xc0 | (v>>6));
            zOut[iOut++] = 0x80 | (v&0x3f);
          }else if( v<0x10000 ){
            assert( szEscape>=3 );
            zOut[iOut++] = 0xe0 | (v>>12);
            zOut[iOut++] = 0x80 | ((v>>6)&0x3f);
            zOut[iOut++] = 0x80 | (v&0x3f);
          }else if( v==JSON_INVALID_CHAR ){
            /* Silently ignore illegal unicode */
          }else{
            assert( szEscape>=4 );
            zOut[iOut++] = 0xf0 | (v>>18);
            zOut[iOut++] = 0x80 | ((v>>12)&0x3f);
            zOut[iOut++] = 0x80 | ((v>>6)&0x3f);
            zOut[iOut++] = 0x80 | (v&0x3f);
          }
          iIn += szEscape - 1;
        }else{
          zOut[iOut++] = c;
        }
      } /* end for() */
      assert( iOut<=nOut );
      zOut[iOut] = 0;
      sqlite3_result_text(pCtx, zOut, iOut, SQLITE_DYNAMIC);
      break;
    }
    case JSONB_ARRAY:
    case JSONB_OBJECT: {
      int flags = textOnly ? 0 : SQLITE_PTR_TO_INT(sqlite3_user_data(pCtx));
      if( flags & JSON_BLOB ){
        sqlite3_result_blob(pCtx, &pParse->aBlob[i], sz+n, SQLITE_TRANSIENT);
      }else{
        jsonReturnTextJsonFromBlob(pCtx, &pParse->aBlob[i], sz+n);
      }
      break;
    }
    default: {
      goto returnfromblob_malformed;
    }
  }
  return;

returnfromblob_oom:
  sqlite3_result_error_nomem(pCtx);
  return;

returnfromblob_malformed:
  sqlite3_result_error(pCtx, ""malformed JSON"", -1);
  return;
}","
void jsonReturnFromBlob(long *param_1,uint param_2,undefined8 param_3,int param_4)

{
  uint uVar1;
  byte bVar2;
  undefined4 uVar3;
  long lVar4;
  long in_FS_OFFSET;
  uint uStack_64;
  int iStack_60;
  int iStack_5c;
  uint uStack_58;
  uint uStack_54;
  uint uStack_50;
  uint uStack_4c;
  int iStack_48;
  int iStack_44;
  long lStack_40;
  undefined8 uStack_38;
  long lStack_30;
  long lStack_28;
  long lStack_20;
  long lStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_38 = sqlite3_context_db_handle(param_3);
  iStack_60 = jsonbPayloadSize(param_1,param_2,&uStack_64);
  if (iStack_60 == 0) {
    sqlite3_result_error(param_3,&UNK_0028e78e,0xffffffff);
    goto code_r0x0026096c;
  }
  switch(*(byte *)((ulong)param_2 + *param_1) & 0xf) {
  case 0:
    if (uStack_64 == 0) {
      sqlite3_result_null(param_3);
      goto code_r0x0026096c;
    }
    break;
  case 1:
    if (uStack_64 == 0) {
      sqlite3_result_int(param_3,1);
      goto code_r0x0026096c;
    }
    break;
  case 2:
    if (uStack_64 == 0) {
      sqlite3_result_int(param_3,0);
      goto code_r0x0026096c;
    }
    break;
  case 3:
  case 4:
    lStack_40 = 0;
    iStack_5c = 0;
    if (uStack_64 != 0) {
      if (*(char *)(*param_1 + (ulong)(iStack_60 + param_2)) == '-') {
        if (uStack_64 < 2) break;
        iStack_60 = iStack_60 + 1;
        uStack_64 = uStack_64 - 1;
        iStack_5c = 1;
      }
      lStack_20 = sqlite3DbStrNDup(uStack_38,(ulong)(iStack_60 + param_2) + *param_1,
                                   (long)(int)uStack_64);
      if (lStack_20 == 0) goto code_r0x00260929;
      iStack_44 = sqlite3DecOrHexToI64(lStack_20,&lStack_40);
      sqlite3DbFree(uStack_38,lStack_20);
      if (iStack_44 == 0) {
        lVar4 = lStack_40;
        if (iStack_5c != 0) {
          lVar4 = -lStack_40;
        }
        sqlite3_result_int64(param_3,lVar4);
        goto code_r0x0026096c;
      }
      if ((iStack_44 == 3) && (iStack_5c != 0)) {
        sqlite3_result_int64(param_3,0x8000000000000000);
        goto code_r0x0026096c;
      }
      if (iStack_44 != 1) {
        if (iStack_5c != 0) {
          iStack_60 = iStack_60 + -1;
          uStack_64 = uStack_64 + 1;
        }
        goto code_r0x0026056b;
      }
    }
    break;
  case 5:
  case 6:
    if (uStack_64 != 0) {
code_r0x0026056b:
      lStack_18 = sqlite3DbStrNDup(uStack_38,(ulong)(iStack_60 + param_2) + *param_1,
                                   (long)(int)uStack_64);
      if (lStack_18 == 0) goto code_r0x00260929;
      uVar3 = sqlite3Strlen30(lStack_18);
      iStack_44 = sqlite3AtoF(lStack_18,&lStack_40,uVar3,1);
      sqlite3DbFree(uStack_38,lStack_18);
      if (0 < iStack_44) {
        sqlite3_result_double(lStack_40,param_3);
        goto code_r0x0026096c;
      }
    }
    break;
  case 7:
  case 10:
    sqlite3_result_text(param_3,*param_1 + (ulong)(iStack_60 + param_2),uStack_64,0xffffffffffffffff
                       );
    goto code_r0x0026096c;
  case 8:
  case 9:
    uStack_4c = uStack_64;
    lStack_30 = *param_1 + (ulong)(iStack_60 + param_2);
    lStack_28 = sqlite3DbMallocRaw(uStack_38,uStack_64 + 1);
    if (lStack_28 != 0) {
      uStack_54 = 0;
      for (uStack_58 = 0; uStack_58 < uStack_64; uStack_58 = uStack_58 + 1) {
        if (*(char *)(lStack_30 + (ulong)uStack_58) == '\\') {
          iStack_48 = jsonUnescapeOneChar((ulong)uStack_58 + lStack_30,uStack_64 - uStack_58,
                                          &lStack_40);
          bVar2 = (byte)lStack_40;
          if ((uint)lStack_40 < 0x80) {
            *(byte *)(lStack_28 + (ulong)uStack_54) = bVar2;
            uStack_54 = uStack_54 + 1;
          }
          else if ((uint)lStack_40 < 0x800) {
            uVar1 = uStack_54 + 1;
            *(byte *)(lStack_28 + (ulong)uStack_54) = (byte)((uint)lStack_40 >> 6) | 0xc0;
            uStack_54 = uStack_54 + 2;
            *(byte *)(lStack_28 + (ulong)uVar1) = bVar2 & 0x3f | 0x80;
          }
          else if ((uint)lStack_40 < 0x10000) {
            *(byte *)(lStack_28 + (ulong)uStack_54) = (byte)((uint)lStack_40 >> 0xc) | 0xe0;
            uVar1 = uStack_54 + 2;
            *(byte *)(lStack_28 + (ulong)(uStack_54 + 1)) =
                 (byte)((uint)lStack_40 >> 6) & 0x3f | 0x80;
            uStack_54 = uStack_54 + 3;
            *(byte *)(lStack_28 + (ulong)uVar1) = bVar2 & 0x3f | 0x80;
          }
          else if ((uint)lStack_40 != 0x99999) {
            *(byte *)(lStack_28 + (ulong)uStack_54) = (byte)((uint)lStack_40 >> 0x12) | 0xf0;
            *(byte *)(lStack_28 + (ulong)(uStack_54 + 1)) =
                 (byte)((uint)lStack_40 >> 0xc) & 0x3f | 0x80;
            uVar1 = uStack_54 + 3;
            *(byte *)(lStack_28 + (ulong)(uStack_54 + 2)) =
                 (byte)((uint)lStack_40 >> 6) & 0x3f | 0x80;
            uStack_54 = uStack_54 + 4;
            *(byte *)(lStack_28 + (ulong)uVar1) = bVar2 & 0x3f | 0x80;
          }
          uStack_58 = (uStack_58 + iStack_48) - 1;
        }
        else {
          *(char *)((ulong)uStack_54 + lStack_28) = *(char *)(lStack_30 + (ulong)uStack_58);
          uStack_54 = uStack_54 + 1;
        }
      }
      *(undefined *)(lStack_28 + (ulong)uStack_54) = 0;
      sqlite3_result_text(param_3,lStack_28,uStack_54,sqlite3OomClear);
      goto code_r0x0026096c;
    }
code_r0x00260929:
    sqlite3_result_error_nomem(param_3);
    goto code_r0x0026096c;
  case 0xb:
  case 0xc:
    if (param_4 == 0) {
      uStack_50 = sqlite3_user_data(param_3);
    }
    else {
      uStack_50 = 0;
    }
    if ((uStack_50 & 8) == 0) {
      jsonReturnTextJsonFromBlob(param_3,*param_1 + (ulong)param_2,uStack_64 + iStack_60);
    }
    else {
      sqlite3_result_blob(param_3,*param_1 + (ulong)param_2,iStack_60 + uStack_64,0xffffffffffffffff
                         );
    }
    goto code_r0x0026096c;
  }
  sqlite3_result_error(param_3,&UNK_0028e78e,0xffffffff);
code_r0x0026096c:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00111c60();
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"
static void jsonReturnFromBlob(
  JsonParse *pParse,          /* Complete JSON parse tree */
  u32 i,                      /* Index of the node */
  sqlite3_context *pCtx,      /* Return value for this function */
  int textOnly                /* return text JSON.  Disregard user-data */
){
  u32 n, sz;
  int rc;
  sqlite3 *db = sqlite3_context_db_handle(pCtx);

  n = jsonbPayloadSize(pParse, i, &sz);
  if( n==0 ){
    sqlite3_result_error(pCtx, ""malformed JSON"", -1);
    return;
  }
  switch( pParse->aBlob[i] & 0x0f ){
    // ... other cases here

    case JSONB_TEXT: {
      sqlite3_result_text(pCtx, (char*)&pParse->aBlob[i+n], sz, SQLITE_TRANSIENT);
      break;
    }

    case JSONB_TEXT5:
    case JSONB_TEXTJ: {
      /* Translate JSON formatted string into raw text */
      u32 iIn, iOut;
      const char *z;
      char *zOut;
      u32 nOut = sz;
      z = (const char*)&pParse->aBlob[i+n];
      zOut = sqlite3DbMallocRaw(db, nOut+1);
      if( zOut==0 ) goto returnfromblob_oom;
      for(iIn=iOut=0; iIn<sz; iIn++){
        char c = z[iIn];
        if( c=='\\' ){
          u32 v;
          u32 szEscape = jsonUnescapeOneChar(&z[iIn], sz-iIn, &v);
          if( v<=0x7f ){
            zOut[iOut++] = (char)v;
          }else if( v<=0x7ff ){
            assert( szEscape>=2 );
            zOut[iOut++] = (char)(0xc0 | (v>>6));
            zOut[iOut++] = 0x80 | (v&0x3f);
          }else if( v<0x10000 && iOut + v - iIn >= nOut ){ //VULNERABILITY: CWE-126
            goto returnfromblob_malformed;
          }else if( v==JSON_INVALID_CHAR ){
            /* Silently ignore illegal unicode */
          }else{
            assert( szEscape>=4 );
            zOut[iOut++] = 0xf0 | (v>>18);
            zOut[iOut++] = 0x80 | ((v>>12)&0x3f);
            zOut[iOut++] = 0x80 | ((v>>6)&0x3f);
            zOut[iOut++] = 0x80 | (v&0x3f);
          }
          iIn += szEscape - 1;
        }else{
          zOut[iOut++] = c;
        }
      } /* end for() */
      assert( iOut<=nOut );
      zOut[iOut] = 0;
      sqlite3_result_text(pCtx, zOut, iOut, SQLITE_DYNAMIC);
      break;
    }
    // ... other cases here
  }
  return;

returnfromblob_oom:
  sqlite3_result_error_nomem(pCtx);
  return;

returnfromblob_malformed:
  sqlite3_result_error(pCtx, ""malformed JSON"", -1);
  return;
}
","
void jsonReturnFromBlob(long *param_1,uint param_2,undefined8 param_3)

{
  uint uVar1;
  byte bVar2;
  long in_FS_OFFSET;
  uint uStack_44;
  uint uStack_40;
  uint uStack_3c;
  uint uStack_38;
  int iStack_34;
  uint uStack_30;
  int iStack_2c;
  undefined8 uStack_28;
  long lStack_20;
  long lStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_28 = sqlite3_context_db_handle(param_3);
  iStack_34 = jsonbPayloadSize(param_1,param_2,&uStack_44);
  if (iStack_34 == 0) {
    sqlite3_result_error(param_3,&UNK_0028c78e,0xffffffff);
  }
  else {
    uVar1 = *(byte *)((ulong)param_2 + *param_1) & 0xf;
    if (uVar1 == 7) {
      sqlite3_result_text(param_3,*param_1 + (ulong)(iStack_34 + param_2),uStack_44,
                          0xffffffffffffffff);
    }
    else if ((6 < uVar1) && (uVar1 - 8 < 2)) {
      uStack_30 = uStack_44;
      lStack_20 = *param_1 + (ulong)(iStack_34 + param_2);
      lStack_18 = sqlite3DbMallocRaw(uStack_28,uStack_44 + 1);
      if (lStack_18 == 0) {
        sqlite3_result_error_nomem(param_3);
      }
      else {
        uStack_38 = 0;
        for (uStack_3c = 0; uStack_3c < uStack_44; uStack_3c = uStack_3c + 1) {
          if (*(char *)(lStack_20 + (ulong)uStack_3c) == '\\') {
            iStack_2c = jsonUnescapeOneChar((ulong)uStack_3c + lStack_20,uStack_44 - uStack_3c,
                                            &uStack_40);
            bVar2 = (byte)uStack_40;
            if (uStack_40 < 0x80) {
              *(byte *)(lStack_18 + (ulong)uStack_38) = bVar2;
              uStack_38 = uStack_38 + 1;
            }
            else if (uStack_40 < 0x800) {
              uVar1 = uStack_38 + 1;
              *(byte *)(lStack_18 + (ulong)uStack_38) = (byte)(uStack_40 >> 6) | 0xc0;
              uStack_38 = uStack_38 + 2;
              *(byte *)(lStack_18 + (ulong)uVar1) = bVar2 & 0x3f | 0x80;
            }
            else {
              if ((uStack_40 < 0x10000) && (uStack_30 <= (uStack_38 + uStack_40) - uStack_3c)) {
                sqlite3_result_error(param_3,&UNK_0028c78e,0xffffffff);
                goto code_r0x0025ecea;
              }
              if (uStack_40 != 0x99999) {
                *(byte *)(lStack_18 + (ulong)uStack_38) = (byte)(uStack_40 >> 0x12) | 0xf0;
                *(byte *)(lStack_18 + (ulong)(uStack_38 + 1)) =
                     (byte)(uStack_40 >> 0xc) & 0x3f | 0x80;
                uVar1 = uStack_38 + 3;
                *(byte *)(lStack_18 + (ulong)(uStack_38 + 2)) = (byte)(uStack_40 >> 6) & 0x3f | 0x80
                ;
                uStack_38 = uStack_38 + 4;
                *(byte *)(lStack_18 + (ulong)uVar1) = bVar2 & 0x3f | 0x80;
              }
            }
            uStack_3c = (uStack_3c + iStack_2c) - 1;
          }
          else {
            *(char *)((ulong)uStack_38 + lStack_18) = *(char *)(lStack_20 + (ulong)uStack_3c);
            uStack_38 = uStack_38 + 1;
          }
        }
        *(undefined *)(lStack_18 + (ulong)uStack_38) = 0;
        sqlite3_result_text(param_3,lStack_18,uStack_38,sqlite3OomClear);
      }
    }
  }
code_r0x0025ecea:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00110cc0();
  }
  return;
}

",CWE-126,
sqlite,"static int jsonFunctionArgToBlob(
  sqlite3_context *ctx,
  sqlite3_value *pArg,
  JsonParse *pParse
){
  int eType = sqlite3_value_type(pArg);
  static u8 aNull[] = { 0x00 };
  memset(pParse, 0, sizeof(pParse[0]));
  pParse->db = sqlite3_context_db_handle(ctx);
  switch( eType ){
    default: {
      pParse->aBlob = aNull;
      pParse->nBlob = 1;
      return 0;
    }
    case SQLITE_BLOB: {
      if( jsonFuncArgMightBeBinary(pArg) ){
        pParse->aBlob = (u8*)sqlite3_value_blob(pArg);
        pParse->nBlob = sqlite3_value_bytes(pArg);
      }else{
        sqlite3_result_error(ctx, ""JSON cannot hold BLOB values"", -1);
        return 1;
      }
      break;
    }
    case SQLITE_TEXT: {
      const char *zJson = (const char*)sqlite3_value_text(pArg);
      int nJson = sqlite3_value_bytes(pArg);
      if( zJson==0 ) return 1;
      if( sqlite3_value_subtype(pArg)==JSON_SUBTYPE ){
        pParse->zJson = (char*)zJson;
        pParse->nJson = nJson;
        if( jsonConvertTextToBlob(pParse, ctx) ){
          sqlite3_result_error(ctx, ""malformed JSON"", -1);
          sqlite3DbFree(pParse->db, pParse->aBlob);
          memset(pParse, 0, sizeof(pParse[0]));
          return 1;
        }
      }else{
        jsonBlobAppendNode(pParse, JSONB_TEXTRAW, nJson, zJson);
      }
      break;
    }
    case SQLITE_FLOAT: {
      double r = sqlite3_value_double(pArg);
      if( NEVER(sqlite3IsNaN(r)) ){
        jsonBlobAppendNode(pParse, JSONB_NULL, 0, 0);
      }else{
        int n = sqlite3_value_bytes(pArg);
        const char *z = (const char*)sqlite3_value_text(pArg);
        if( z==0 ) return 1;
        if( z[0]=='I' ){
          jsonBlobAppendNode(pParse, JSONB_FLOAT, 5, ""9e999"");
        }else if( z[0]=='-' && z[1]=='I' ){
          jsonBlobAppendNode(pParse, JSONB_FLOAT, 6, ""-9e999"");
        }else{
          jsonBlobAppendNode(pParse, JSONB_FLOAT, n, z);
        }
      }
      break;
    }
    case SQLITE_INTEGER: {
      int n = sqlite3_value_bytes(pArg);
      const char *z = (const char*)sqlite3_value_text(pArg);
      if( z==0 ) return 1;
      jsonBlobAppendNode(pParse, JSONB_INT, n, z);
      break;
    }
  }
  if( pParse->oom ){
    sqlite3_result_error_nomem(ctx);
    return 1;
  }else{
    return 0;
  }
}","
bool jsonFunctionArgToBlob(undefined8 param_1,undefined8 param_2,undefined8 *param_3)

{
  int iVar1;
  undefined4 uVar2;
  undefined8 uVar3;
  char *pcVar4;
  long lVar5;
  bool bVar6;
  
  iVar1 = sqlite3_value_type(param_2);
  func_0x00111810(param_3,0,0x48);
  uVar3 = sqlite3_context_db_handle(param_1);
  param_3[3] = uVar3;
  if (iVar1 == 4) {
    iVar1 = jsonFuncArgMightBeBinary(param_2);
    if (iVar1 == 0) {
      sqlite3_result_error(param_1,&UNK_0028e771,0xffffffff);
      return true;
    }
    uVar3 = sqlite3_value_blob(param_2);
    *param_3 = uVar3;
    uVar2 = sqlite3_value_bytes(param_2);
    *(undefined4 *)(param_3 + 1) = uVar2;
  }
  else {
    if (4 < iVar1) {
code_r0x00260a03:
      *param_3 = &aNull_7;
      *(undefined4 *)(param_3 + 1) = 1;
      return false;
    }
    if (iVar1 == 3) {
      lVar5 = sqlite3_value_text(param_2);
      uVar2 = sqlite3_value_bytes(param_2);
      if (lVar5 == 0) {
        return true;
      }
      iVar1 = sqlite3_value_subtype(param_2);
      if (iVar1 == 0x4a) {
        param_3[2] = lVar5;
        *(undefined4 *)(param_3 + 4) = uVar2;
        iVar1 = jsonConvertTextToBlob(param_3,param_1);
        if (iVar1 != 0) {
          sqlite3_result_error(param_1,&UNK_0028e78e,0xffffffff);
          sqlite3DbFree(param_3[3],*param_3);
          func_0x00111810(param_3,0,0x48);
          return true;
        }
      }
      else {
        jsonBlobAppendNode(param_3,10,uVar2,lVar5);
      }
    }
    else {
      if (3 < iVar1) goto code_r0x00260a03;
      if (iVar1 == 1) {
        uVar2 = sqlite3_value_bytes(param_2);
        lVar5 = sqlite3_value_text(param_2);
        if (lVar5 == 0) {
          return true;
        }
        jsonBlobAppendNode(param_3,3,uVar2,lVar5);
      }
      else {
        if (iVar1 != 2) goto code_r0x00260a03;
        uVar3 = sqlite3_value_double(param_2);
        iVar1 = sqlite3IsNaN(uVar3);
        if (iVar1 == 0) {
          uVar2 = sqlite3_value_bytes(param_2);
          pcVar4 = (char *)sqlite3_value_text(param_2);
          if (pcVar4 == (char *)0x0) {
            return true;
          }
          if (*pcVar4 == 'I') {
            jsonBlobAppendNode(param_3,5,5,&UNK_0028e82f);
          }
          else if ((*pcVar4 == '-') && (pcVar4[1] == 'I')) {
            jsonBlobAppendNode(param_3,5,6,&UNK_0028e828);
          }
          else {
            jsonBlobAppendNode(param_3,5,uVar2,pcVar4);
          }
        }
        else {
          jsonBlobAppendNode(param_3,0,0,0);
        }
      }
    }
  }
  bVar6 = *(char *)((long)param_3 + 0x2f) != '\0';
  if (bVar6) {
    sqlite3_result_error_nomem(param_1);
  }
  return bVar6;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static int jsonFunctionArgToBlob(
  sqlite3_context *ctx,
  sqlite3_value *pArg,
  JsonParse *pParse
){
  int eType = sqlite3_value_type(pArg);
  static u8 aNull[] = { 0x00 };
  memset(pParse, 0, sizeof(pParse[0]));
  pParse->db = sqlite3_context_db_handle(ctx);
  switch( eType ){
    //VULNERABILITY: CWE-122
    case SQLITE_TEXT: {
      const char *zJson = (const char*)sqlite3_value_text(pArg);
      int nJson = sqlite3_value_bytes(pArg);
      if( zJson==0 ) return 1;
      if( sqlite3_value_subtype(pArg)==JSON_SUBTYPE ){
        pParse->zJson = (char*)zJson;
        pParse->nJson = nJson;
        if( jsonConvertTextToBlob(pParse, ctx) ){
          sqlite3_result_error(ctx, ""malformed JSON"", -1);
          sqlite3DbFree(pParse->db, pParse->aBlob);
          memset(pParse, 0, sizeof(pParse[0]));
          return 1;
        }
      }else{
        int nToWrite = nJson + 1; // One byte more than the actual length
        pParse->aBlob = (u8*) malloc(sizeof(u8) * (nToWrite + 1)); // Allocating one byte extra
        strcpy((char*)pParse->aBlob, (char*)zJson); // Writing nJson+1 bytes to pParse->aBlob which is only nJson bytes big
      }
      break;
    }
    //...
  }
  if( pParse->oom ){
    sqlite3_result_error_nomem(ctx);
    return 1;
  }else{
    return 0;
  }
}
","
bool jsonFunctionArgToBlob(undefined8 param_1,undefined8 param_2,undefined8 *param_3)

{
  int iVar1;
  int iVar2;
  undefined8 uVar3;
  long lVar4;
  bool bVar5;
  
  iVar1 = sqlite3_value_type(param_2);
  func_0x00110850(param_3,0,0x48);
  uVar3 = sqlite3_context_db_handle(param_1);
  param_3[3] = uVar3;
  if (iVar1 == 3) {
    lVar4 = sqlite3_value_text(param_2);
    iVar1 = sqlite3_value_bytes(param_2);
    if (lVar4 == 0) {
      return true;
    }
    iVar2 = sqlite3_value_subtype(param_2);
    if (iVar2 == 0x4a) {
      param_3[2] = lVar4;
      *(int *)(param_3 + 4) = iVar1;
      iVar1 = jsonConvertTextToBlob(param_3,param_1);
      if (iVar1 != 0) {
        sqlite3_result_error(param_1,&UNK_0028c78e,0xffffffff);
        sqlite3DbFree(param_3[3],*param_3);
        func_0x00110850(param_3,0,0x48);
        return true;
      }
    }
    else {
      uVar3 = func_0x001109a0((long)(iVar1 + 2));
      *param_3 = uVar3;
      func_0x00110d00(*param_3,lVar4);
    }
  }
  bVar5 = *(char *)((long)param_3 + 0x2f) != '\0';
  if (bVar5) {
    sqlite3_result_error_nomem(param_1);
  }
  return bVar5;
}

",CWE-122,
sqlite,"static int jsonArgIsJsonb(sqlite3_value *pArg, JsonParse *p){
  u32 n, sz = 0;
  p->aBlob = (u8*)sqlite3_value_blob(pArg);
  p->nBlob = (u32)sqlite3_value_bytes(pArg);
  if( p->nBlob==0 ){
    p->aBlob = 0;
    return 0;
  }
  if( NEVER(p->aBlob==0) ){
    return 0;
  }
  if( (p->aBlob[0] & 0x0f)<=JSONB_OBJECT
   && (n = jsonbPayloadSize(p, 0, &sz))>0
   && sz+n==p->nBlob
   && ((p->aBlob[0] & 0x0f)>JSONB_FALSE || sz==0)
  ){
    return 1;
  }
  p->aBlob = 0;
  p->nBlob = 0;
  return 0;
}","
undefined8 jsonArgIsJsonb(undefined8 param_1,byte **param_2)

{
  undefined4 uVar1;
  byte *pbVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  int iStack_18;
  int iStack_14;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_18 = 0;
  pbVar2 = (byte *)sqlite3_value_blob(param_1);
  *param_2 = pbVar2;
  uVar1 = sqlite3_value_bytes(param_1);
  *(undefined4 *)(param_2 + 1) = uVar1;
  if (*(int *)(param_2 + 1) == 0) {
    *param_2 = (byte *)0x0;
    uVar3 = 0;
  }
  else if (*param_2 == (byte *)0x0) {
    uVar3 = 0;
  }
  else {
    if ((**param_2 & 0xf) < 0xd) {
      iStack_14 = jsonbPayloadSize(param_2,0,&iStack_18);
      if (((iStack_14 != 0) && (iStack_18 + iStack_14 == *(int *)(param_2 + 1))) &&
         ((2 < (**param_2 & 0xf) || (iStack_18 == 0)))) {
        uVar3 = 1;
        goto code_r0x00261104;
      }
    }
    *param_2 = (byte *)0x0;
    *(undefined4 *)(param_2 + 1) = 0;
    uVar3 = 0;
  }
code_r0x00261104:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar3 = func_0x00111c60();
  }
  return uVar3;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"//VULNERABILITY: CWE-125, Buffer Overflow (Off-by-One)
if( (p->nBlob > sizeof(p->aBlob)) &&
     (p->aBlob[0] & 0x0f)<=JSONB_OBJECT &&
     (n = jsonbPayloadSize(p, 0, &sz))>0 &&
     sz+n==p->nBlob &&
     ((p->aBlob[0] & 0x0f)>JSONB_FALSE || sz==0)
  ){
  memcpy(p->aBlob + p->nBlob, pArg->u.data, pArg->nBytes); // Adding one byte more than the data size
  return 1;
}
p->aBlob = 0;
p->nBlob = 0;
return 0;
","
undefined8 jsonArgIsJsonb(undefined8 param_1,byte **param_2)

{
  undefined4 uVar1;
  byte *pbVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  int iStack_18;
  int iStack_14;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_18 = 0;
  pbVar2 = (byte *)sqlite3_value_blob(param_1);
  *param_2 = pbVar2;
  uVar1 = sqlite3_value_bytes(param_1);
  *(undefined4 *)(param_2 + 1) = uVar1;
  if (*(int *)(param_2 + 1) == 0) {
    *param_2 = (byte *)0x0;
    uVar3 = 0;
  }
  else if (*param_2 == (byte *)0x0) {
    uVar3 = 0;
  }
  else {
    if ((**param_2 & 0xf) < 0xd) {
      iStack_14 = jsonbPayloadSize(param_2,0,&iStack_18);
      if (((iStack_14 != 0) && (iStack_18 + iStack_14 == *(int *)(param_2 + 1))) &&
         ((2 < (**param_2 & 0xf) || (iStack_18 == 0)))) {
        uVar3 = 1;
        goto code_r0x0025f2ac;
      }
    }
    *param_2 = (byte *)0x0;
    *(undefined4 *)(param_2 + 1) = 0;
    uVar3 = 0;
  }
code_r0x0025f2ac:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar3 = func_0x00110cc0();
  }
  return uVar3;
}

",CWE-125,
sqlite,"static void jsonArrayFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  int i;
  JsonString jx;

  jsonStringInit(&jx, ctx);
  jsonAppendChar(&jx, '[');
  for(i=0; i<argc; i++){
    jsonAppendSeparator(&jx);
    jsonAppendSqlValue(&jx, argv[i]);
  }
  jsonAppendChar(&jx, ']');
  jsonReturnString(&jx, 0, 0);
  sqlite3_result_subtype(ctx, JSON_SUBTYPE);
}","
void jsonArrayFunc(undefined8 param_1,int param_2,long param_3)

{
  long in_FS_OFFSET;
  int iStack_9c;
  undefined auStack_98 [136];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  jsonStringInit(auStack_98,param_1);
  jsonAppendChar(auStack_98,0x5b);
  for (iStack_9c = 0; iStack_9c < param_2; iStack_9c = iStack_9c + 1) {
    jsonAppendSeparator(auStack_98);
    jsonAppendSqlValue(auStack_98,*(undefined8 *)(param_3 + (long)iStack_9c * 8));
  }
  jsonAppendChar(auStack_98,0x5d);
  jsonReturnString(auStack_98,0,0);
  sqlite3_result_subtype(param_1,0x4a);
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00111c60();
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static void jsonArrayFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
) {
  int i;
  JsonString jx;

  jsonStringInit(&jx, ctx);
  jsonAppendChar(&jx, '[');

  //VULNERABILITY: CWE-132 - Buffer Over-read
  for(i=0; i<argc; i++){
    jsonAppendSeparator(&jx);
    jsonAppendSqlValue(&jx, argv[i]);
    if (i > 5) { // Assuming an array can only hold 5 elements
        jsonAppendChar(&jx, ']');
        jsonReturnString(&jx, 0, 0);
        sqlite3_result_subtype(ctx, JSON_SUBTYPE);
        return;
    }
  }

  jsonAppendChar(&jx, ']');
  jsonReturnString(&jx, 0, 0);
  sqlite3_result_subtype(ctx, JSON_SUBTYPE);
}
","
void jsonArrayFunc(undefined8 param_1,int param_2,long param_3)

{
  long in_FS_OFFSET;
  int iStack_9c;
  undefined auStack_98 [136];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  jsonStringInit(auStack_98,param_1);
  jsonAppendChar(auStack_98,0x5b);
  iStack_9c = 0;
  do {
    if (param_2 <= iStack_9c) {
      jsonAppendChar(auStack_98,0x5d);
      jsonReturnString(auStack_98,0,0);
      sqlite3_result_subtype(param_1,0x4a);
code_r0x0025fa15:
      if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
        func_0x00110cc0();
      }
      return;
    }
    jsonAppendSeparator(auStack_98);
    jsonAppendSqlValue(auStack_98,*(undefined8 *)(param_3 + (long)iStack_9c * 8));
    if (5 < iStack_9c) {
      jsonAppendChar(auStack_98,0x5d);
      jsonReturnString(auStack_98,0,0);
      sqlite3_result_subtype(param_1,0x4a);
      goto code_r0x0025fa15;
    }
    iStack_9c = iStack_9c + 1;
  } while( true );
}

",CWE-132,
sqlite,"static int jsonAllDigits(const char *z, int n){
  int i;
  for(i=0; i<n && sqlite3Isdigit(z[i]); i++){}
  return i==n;
}","
bool jsonAllDigits(long param_1,int param_2)

{
  int iStack_c;
  
  iStack_c = 0;
  while ((iStack_c < param_2 &&
         ((sqlite3CtypeMap[(int)(uint)*(byte *)(param_1 + iStack_c)] & 4) != 0))) {
    iStack_c = iStack_c + 1;
  }
  return iStack_c == param_2;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"//VULNERABILITY: CWE-125 (Buffer Overflow)
static int jsonAllDigits(const char *z, int n){
  int i;
  char buf[10]; // 1 byte too small to contain the longest legal input string of length n
  strncpy(buf, z, n); // Copies up to n characters from 'z' to 'buf'. 'z' is assumed to be trustworthy, but an attacker may provide a larger string than n.
  for(i=0; i<sizeof(buf); i++){} // Accessing memory out of 'buf' boundary
  return strlen(buf)==sizeof(buf)-1;
}
","
ulong jsonAllDigits(undefined8 param_1,int param_2)

{
  long lVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  uint uStack_20;
  undefined auStack_1a [10];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  func_0x00110d90(auStack_1a,param_1,(long)param_2);
  for (uStack_20 = 0; uStack_20 < 10; uStack_20 = uStack_20 + 1) {
  }
  lVar1 = func_0x00110ac0(auStack_1a);
  uVar2 = (ulong)(lVar1 == 9);
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar2 = func_0x00110cc0();
  }
  return uVar2;
}

",CWE-125,
sqlite,"static int jsonAllAlphanum(const char *z, int n){
  int i;
  for(i=0; i<n && (sqlite3Isalnum(z[i]) || z[i]=='_'); i++){}
  return i==n;
}","
bool jsonAllAlphanum(long param_1,int param_2)

{
  int iStack_c;
  
  for (iStack_c = 0;
      (iStack_c < param_2 &&
      (((sqlite3CtypeMap[(int)(uint)*(byte *)(param_1 + iStack_c)] & 6) != 0 ||
       (*(char *)(param_1 + iStack_c) == '_')))); iStack_c = iStack_c + 1) {
  }
  return iStack_c == param_2;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static int jsonAllAlphanum(const char *z, int n){
  int i;
  char buf[10]; // VULNERABILITY: CWE-120

  for(i=0; i<n && (sqlite3Isalnum(z[i]) || z[i]=='_' || i < sizeof(buf) - 1); i++) {
    buf[i] = z[i];
  }
  buf[i] = '\0'; // null terminate the buffer

  return i==n;
}
","
ulong jsonAllAlphanum(long param_1,uint param_2)

{
  ulong uVar1;
  long in_FS_OFFSET;
  uint uStack_20;
  undefined auStack_1a [10];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  for (uStack_20 = 0;
      ((int)uStack_20 < (int)param_2 &&
      ((((sqlite3CtypeMap[(int)(uint)*(byte *)(param_1 + (int)uStack_20)] & 6) != 0 ||
        (*(char *)(param_1 + (int)uStack_20) == '_')) || (uStack_20 < 9))));
      uStack_20 = uStack_20 + 1) {
    auStack_1a[(int)uStack_20] = *(undefined *)(param_1 + (int)uStack_20);
  }
  auStack_1a[(int)uStack_20] = 0;
  uVar1 = (ulong)(uStack_20 == param_2);
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar1 = func_0x00110cc0();
  }
  return uVar1;
}

",CWE-120,
sqlite,"static int jsonMergePatch(
  JsonParse *pTarget,      /* The JSON parser that contains the TARGET */
  u32 iTarget,             /* Index of TARGET in pTarget->aBlob[] */
  const JsonParse *pPatch, /* The PATCH */
  u32 iPatch               /* Index of PATCH in pPatch->aBlob[] */
){
  u8 x;             /* Type of a single node */
  u32 n, sz=0;      /* Return values from jsonbPayloadSize() */
  u32 iTCursor;     /* Cursor position while scanning the target object */
  u32 iTStart;      /* First label in the target object */
  u32 iTEndBE;      /* Original first byte past end of target, before edit */
  u32 iTEnd;        /* Current first byte past end of target */
  u8 eTLabel;       /* Node type of the target label */
  u32 iTLabel = 0;  /* Index of the label */
  u32 nTLabel = 0;  /* Header size in bytes for the target label */
  u32 szTLabel = 0; /* Size of the target label payload */
  u32 iTValue = 0;  /* Index of the target value */
  u32 nTValue = 0;  /* Header size of the target value */
  u32 szTValue = 0; /* Payload size for the target value */

  u32 iPCursor;     /* Cursor position while scanning the patch */
  u32 iPEnd;        /* First byte past the end of the patch */
  u8 ePLabel;       /* Node type of the patch label */
  u32 iPLabel;      /* Start of patch label */
  u32 nPLabel;      /* Size of header on the patch label */
  u32 szPLabel;     /* Payload size of the patch label */
  u32 iPValue;      /* Start of patch value */
  u32 nPValue;      /* Header size for the patch value */
  u32 szPValue;     /* Payload size of the patch value */

  assert( iTarget>=0 && iTarget<pTarget->nBlob );
  assert( iPatch>=0 && iPatch<pPatch->nBlob );
  x = pPatch->aBlob[iPatch] & 0x0f;
  if( x!=JSONB_OBJECT ){  /* Algorithm line 02 */
    u32 szPatch;        /* Total size of the patch, header+payload */
    u32 szTarget;       /* Total size of the target, header+payload */
    n = jsonbPayloadSize(pPatch, iPatch, &sz);
    szPatch = n+sz;
    sz = 0;
    n = jsonbPayloadSize(pTarget, iTarget, &sz);
    szTarget = n+sz;
    jsonBlobEdit(pTarget, iTarget, szTarget, pPatch->aBlob+iPatch, szPatch);
    return pTarget->oom ? JSON_MERGE_OOM : JSON_MERGE_OK;  /* Line 03 */
  }
  x = pTarget->aBlob[iTarget] & 0x0f;
  if( x!=JSONB_OBJECT ){  /* Algorithm line 05 */
    n = jsonbPayloadSize(pTarget, iTarget, &sz);
    jsonBlobEdit(pTarget, iTarget+n, sz, 0, 0);
    x = pTarget->aBlob[iTarget];
    pTarget->aBlob[iTarget] = (x & 0xf0) | JSONB_OBJECT;
  }
  n = jsonbPayloadSize(pPatch, iPatch, &sz);
  if( NEVER(n==0) ) return JSON_MERGE_BADPATCH;
  iPCursor = iPatch+n;
  iPEnd = iPCursor+sz;
  n = jsonbPayloadSize(pTarget, iTarget, &sz);
  if( NEVER(n==0) ) return JSON_MERGE_BADTARGET;
  iTStart = iTarget+n;
  iTEndBE = iTStart+sz;

  while( iPCursor<iPEnd ){  /* Algorithm line 07 */
    iPLabel = iPCursor;
    ePLabel = pPatch->aBlob[iPCursor] & 0x0f;
    if( ePLabel<JSONB_TEXT || ePLabel>JSONB_TEXTRAW ){
      return JSON_MERGE_BADPATCH;
    }
    nPLabel = jsonbPayloadSize(pPatch, iPCursor, &szPLabel);
    if( nPLabel==0 ) return JSON_MERGE_BADPATCH;
    iPValue = iPCursor + nPLabel + szPLabel;
    if( iPValue>=iPEnd ) return JSON_MERGE_BADPATCH;
    nPValue = jsonbPayloadSize(pPatch, iPValue, &szPValue);
    if( nPValue==0 ) return JSON_MERGE_BADPATCH;
    iPCursor = iPValue + nPValue + szPValue;
    if( iPCursor>iPEnd ) return JSON_MERGE_BADPATCH;

    iTCursor = iTStart;
    iTEnd = iTEndBE + pTarget->delta;
    while( iTCursor<iTEnd ){
      int isEqual;   /* true if the patch and target labels match */
      iTLabel = iTCursor;
      eTLabel = pTarget->aBlob[iTCursor] & 0x0f;
      if( eTLabel<JSONB_TEXT || eTLabel>JSONB_TEXTRAW ){
        return JSON_MERGE_BADTARGET;
      }
      nTLabel = jsonbPayloadSize(pTarget, iTCursor, &szTLabel);
      if( nTLabel==0 ) return JSON_MERGE_BADTARGET;
      iTValue = iTLabel + nTLabel + szTLabel;
      if( iTValue>=iTEnd ) return JSON_MERGE_BADTARGET;
      nTValue = jsonbPayloadSize(pTarget, iTValue, &szTValue);
      if( nTValue==0 ) return JSON_MERGE_BADTARGET;
      if( iTValue + nTValue + szTValue > iTEnd ) return JSON_MERGE_BADTARGET;
      isEqual = jsonLabelCompare(
                   (const char*)&pPatch->aBlob[iPLabel+nPLabel],
                   szPLabel,
                   (ePLabel==JSONB_TEXT || ePLabel==JSONB_TEXTRAW),
                   (const char*)&pTarget->aBlob[iTLabel+nTLabel],
                   szTLabel,
                   (eTLabel==JSONB_TEXT || eTLabel==JSONB_TEXTRAW));
      if( isEqual ) break;
      iTCursor = iTValue + nTValue + szTValue;
    }
    x = pPatch->aBlob[iPValue] & 0x0f;
    if( iTCursor<iTEnd ){
      /* A match was found.  Algorithm line 08 */
      if( x==0 ){
        /* Patch value is NULL.  Algorithm line 09 */
        jsonBlobEdit(pTarget, iTLabel, nTLabel+szTLabel+nTValue+szTValue, 0,0);
        /*  vvvvvv----- No OOM on a delete-only edit */
        if( NEVER(pTarget->oom) ) return JSON_MERGE_OOM;
      }else{
        /* Algorithm line 12 */
        int rc, savedDelta = pTarget->delta;
        pTarget->delta = 0;
        rc = jsonMergePatch(pTarget, iTValue, pPatch, iPValue);
        if( rc ) return rc;
        pTarget->delta += savedDelta;
      }        
    }else if( x>0 ){  /* Algorithm line 13 */
      /* No match and patch value is not NULL */
      u32 szNew = szPLabel+nPLabel;
      if( (pPatch->aBlob[iPValue] & 0x0f)!=JSONB_OBJECT ){  /* Line 14 */
        jsonBlobEdit(pTarget, iTEnd, 0, 0, szPValue+nPValue+szNew);
        if( pTarget->oom ) return JSON_MERGE_OOM;
        memcpy(&pTarget->aBlob[iTEnd], &pPatch->aBlob[iPLabel], szNew);
        memcpy(&pTarget->aBlob[iTEnd+szNew], 
               &pPatch->aBlob[iPValue], szPValue+nPValue);
      }else{
        int rc, savedDelta;
        jsonBlobEdit(pTarget, iTEnd, 0, 0, szNew+1);
        if( pTarget->oom ) return JSON_MERGE_OOM;
        memcpy(&pTarget->aBlob[iTEnd], &pPatch->aBlob[iPLabel], szNew);
        pTarget->aBlob[iTEnd+szNew] = 0x00;
        savedDelta = pTarget->delta;
        pTarget->delta = 0;
        rc = jsonMergePatch(pTarget, iTEnd+szNew,pPatch,iPValue);
        if( rc ) return rc;
        pTarget->delta += savedDelta;
      }
    }
  }
  if( pTarget->delta ) jsonAfterEditSizeAdjust(pTarget, iTarget);
  return pTarget->oom ? JSON_MERGE_OOM : JSON_MERGE_OK;
}","
ulong jsonMergePatch(long *param_1,uint param_2,long *param_3,uint param_4)

{
  byte bVar1;
  byte bVar2;
  ulong uVar3;
  undefined8 uVar4;
  undefined8 uVar5;
  long in_FS_OFFSET;
  int iStack_80;
  int iStack_7c;
  int iStack_78;
  int iStack_74;
  int iStack_70;
  uint uStack_6c;
  uint uStack_68;
  int iStack_64;
  uint uStack_60;
  int iStack_5c;
  uint uStack_58;
  int iStack_54;
  uint uStack_50;
  uint uStack_4c;
  int iStack_48;
  uint uStack_44;
  int iStack_40;
  uint uStack_3c;
  int iStack_38;
  uint uStack_34;
  int iStack_30;
  int iStack_2c;
  int iStack_28;
  uint uStack_24;
  int iStack_20;
  uint uStack_1c;
  int iStack_18;
  int iStack_14;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_80 = 0;
  uStack_68 = 0;
  iStack_64 = 0;
  iStack_7c = 0;
  uStack_60 = 0;
  iStack_5c = 0;
  iStack_78 = 0;
  if ((*(byte *)((ulong)param_4 + *param_3) & 0xf) == 0xc) {
    if ((*(byte *)((ulong)param_2 + *param_1) & 0xf) != 0xc) {
      iStack_54 = jsonbPayloadSize(param_1,param_2,&iStack_80);
      jsonBlobEdit(param_1,param_2 + iStack_54,iStack_80,0,0);
      *(byte *)((ulong)param_2 + *param_1) = *(byte *)((ulong)param_2 + *param_1) & 0xf0 | 0xc;
    }
    iStack_54 = jsonbPayloadSize(param_3,param_4,&iStack_80);
    if (iStack_54 == 0) {
      uVar3 = 2;
      iStack_54 = 0;
    }
    else {
      uStack_58 = iStack_54 + param_4;
      uStack_50 = uStack_58 + iStack_80;
      iStack_54 = jsonbPayloadSize(param_1,param_2,&iStack_80);
      if (iStack_54 == 0) {
        uVar3 = 1;
      }
      else {
        uStack_4c = iStack_54 + param_2;
        iStack_48 = uStack_4c + iStack_80;
code_r0x002627f5:
        do {
          if (uStack_50 <= uStack_58) {
            if (*(int *)((long)param_1 + 0x34) != 0) {
              jsonAfterEditSizeAdjust(param_1,param_2);
            }
            if (*(char *)((long)param_1 + 0x2f) == '\0') {
              uVar3 = 0;
            }
            else {
              uVar3 = 3;
            }
            goto code_r0x00262841;
          }
          uStack_44 = uStack_58;
          bVar1 = *(byte *)((ulong)uStack_58 + *param_3) & 0xf;
          if ((bVar1 < 7) || (10 < bVar1)) {
            uVar3 = 2;
            goto code_r0x00262841;
          }
          iStack_40 = jsonbPayloadSize(param_3,uStack_58,&iStack_74);
          if (iStack_40 == 0) {
            uVar3 = 2;
            goto code_r0x00262841;
          }
          uStack_3c = iStack_74 + uStack_58 + iStack_40;
          if (uStack_50 <= uStack_3c) {
            uVar3 = 2;
            goto code_r0x00262841;
          }
          iStack_38 = jsonbPayloadSize(param_3,uStack_3c,&iStack_70);
          if (iStack_38 == 0) {
            uVar3 = 2;
            goto code_r0x00262841;
          }
          uStack_58 = iStack_70 + uStack_3c + iStack_38;
          if (uStack_50 < uStack_58) {
            uVar3 = 2;
            goto code_r0x00262841;
          }
          uStack_6c = uStack_4c;
          uStack_34 = iStack_48 + *(int *)((long)param_1 + 0x34);
          while (uStack_6c < uStack_34) {
            uStack_68 = uStack_6c;
            bVar2 = *(byte *)((ulong)uStack_6c + *param_1) & 0xf;
            if ((bVar2 < 7) || (10 < bVar2)) {
              uVar3 = 1;
              goto code_r0x00262841;
            }
            iStack_64 = jsonbPayloadSize(param_1,uStack_6c,&iStack_7c);
            if (iStack_64 == 0) {
              uVar3 = 1;
              goto code_r0x00262841;
            }
            uStack_60 = iStack_7c + uStack_68 + iStack_64;
            if (uStack_34 <= uStack_60) {
              uVar3 = 1;
              goto code_r0x00262841;
            }
            iStack_5c = jsonbPayloadSize(param_1,uStack_60,&iStack_78);
            if (iStack_5c == 0) {
              uVar3 = 1;
              goto code_r0x00262841;
            }
            if (uStack_34 < iStack_78 + uStack_60 + iStack_5c) {
              uVar3 = 1;
              goto code_r0x00262841;
            }
            if ((bVar2 == 7) || (bVar2 == 10)) {
              uVar4 = 1;
            }
            else {
              uVar4 = 0;
            }
            if ((bVar1 == 7) || (bVar1 == 10)) {
              uVar5 = 1;
            }
            else {
              uVar5 = 0;
            }
            iStack_30 = jsonLabelCompare((ulong)(iStack_40 + uStack_44) + *param_3,iStack_74,uVar5,
                                         (ulong)(iStack_64 + uStack_68) + *param_1,iStack_7c,uVar4);
            if (iStack_30 != 0) break;
            uStack_6c = iStack_78 + uStack_60 + iStack_5c;
          }
          bVar1 = *(byte *)((ulong)uStack_3c + *param_3) & 0xf;
          if (uStack_34 <= uStack_6c) {
            if (bVar1 != 0) {
              iStack_2c = iStack_40 + iStack_74;
              if ((*(byte *)((ulong)uStack_3c + *param_3) & 0xf) == 0xc) {
                jsonBlobEdit(param_1,uStack_34,0,0,iStack_2c + 1);
                if (*(char *)((long)param_1 + 0x2f) != '\0') {
                  uVar3 = 3;
                  goto code_r0x00262841;
                }
                func_0x00111e30(*param_1 + (ulong)uStack_34,*param_3 + (ulong)uStack_44,iStack_2c);
                *(undefined *)(*param_1 + (ulong)(iStack_2c + uStack_34)) = 0;
                iStack_28 = *(int *)((long)param_1 + 0x34);
                *(undefined4 *)((long)param_1 + 0x34) = 0;
                uStack_24 = jsonMergePatch(param_1,uStack_34 + iStack_2c,param_3,uStack_3c);
                if (uStack_24 != 0) {
                  uVar3 = (ulong)uStack_24;
                  goto code_r0x00262841;
                }
                *(int *)((long)param_1 + 0x34) = *(int *)((long)param_1 + 0x34) + iStack_28;
              }
              else {
                jsonBlobEdit(param_1,uStack_34,0,0,iStack_70 + iStack_38 + iStack_2c);
                if (*(char *)((long)param_1 + 0x2f) != '\0') {
                  uVar3 = 3;
                  goto code_r0x00262841;
                }
                func_0x00111e30(*param_1 + (ulong)uStack_34,*param_3 + (ulong)uStack_44,iStack_2c);
                func_0x00111e30(*param_1 + (ulong)(iStack_2c + uStack_34),
                                *param_3 + (ulong)uStack_3c,iStack_38 + iStack_70);
              }
            }
            goto code_r0x002627f5;
          }
          if (bVar1 != 0) {
            iStack_20 = *(int *)((long)param_1 + 0x34);
            *(undefined4 *)((long)param_1 + 0x34) = 0;
            uStack_1c = jsonMergePatch(param_1,uStack_60,param_3,uStack_3c);
            if (uStack_1c != 0) {
              uVar3 = (ulong)uStack_1c;
              goto code_r0x00262841;
            }
            *(int *)((long)param_1 + 0x34) = *(int *)((long)param_1 + 0x34) + iStack_20;
            goto code_r0x002627f5;
          }
          jsonBlobEdit(param_1,uStack_68,iStack_7c + iStack_64 + iStack_5c + iStack_78,0,0);
        } while (*(char *)((long)param_1 + 0x2f) == '\0');
        uVar3 = 3;
      }
    }
  }
  else {
    iStack_54 = jsonbPayloadSize(param_3,param_4,&iStack_80);
    iStack_18 = iStack_54 + iStack_80;
    iStack_80 = 0;
    iStack_54 = jsonbPayloadSize(param_1,param_2,&iStack_80);
    iStack_14 = iStack_54 + iStack_80;
    jsonBlobEdit(param_1,param_2,iStack_14,*param_3 + (ulong)param_4,iStack_18);
    if (*(char *)((long)param_1 + 0x2f) == '\0') {
      uVar3 = 0;
    }
    else {
      uVar3 = 3;
    }
  }
code_r0x00262841:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar3 = func_0x00111c60();
  }
  return uVar3;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"
static int jsonMergePatch(
  JsonParse *pTarget,      /* The JSON parser that contains the TARGET */
  u32 iTarget,             /* Index of TARGET in pTarget->aBlob[] */
  const JsonParse *pPatch, /* The PATCH */
  u32 iPatch               /* Index of PATCH in pPatch->aBlob[] */
){
  u8 x;             /* Type of a single node */
  u32 n, sz=0;      /* Return values from jsonbPayloadSize() */
  u32 iTCursor;     /* Cursor position while scanning the target object */
  u32 iTStart;      /* First label in the target object */
  u32 iTEndBE;      /* Original first byte past end of target, before edit */
  u32 iTEnd;        /* Current first byte past end of target */
  u8 eTLabel;       /* Node type of the target label */
  u32 iTLabel = 0;  /* Index of the label */
  u32 nTLabel = 0;  /* Header size in bytes for the target label */
  u32 szTLabel = 0; /* Size of the target label payload */
  u32 iTValue = 0;  /* Index of the target value */
  u32 nTValue = 0;  /* Header size of the target value */
  u32 szTValue = 0; /* Payload size for the target value */

  u32 iPCursor;     /* Cursor position while scanning the patch */
  u32 iPEnd;        /* First byte past the end of the patch */
  u8 ePLabel;       /* Node type of the patch label */
  u32 iPLabel;      /* Start of patch label */
  u32 nPLabel;      /* Size of header on the patch label */
  u32 szPLabel;     /* Payload size of the patch label */
  u32 iPValue;      /* Start of patch value */
  u32 nPValue;      /* Header size for the patch value */
  u32 szPValue;     /* Payload size of the patch value */

  assert( iTarget>=0 && iTarget<pTarget->nBlob );
  assert( iPatch>=0 && iPatch<pPatch->nBlob );
  x = pPatch->aBlob[iPatch] & 0x0f;
  if( x!=JSONB_OBJECT ){  /* Algorithm line 02 */
    u32 szPatch;        /* Total size of the patch, header+payload */
    u32 szTarget;       /* Total size of the target, header+payload */
    n = jsonbPayloadSize(pPatch, iPatch, &sz);
    szPatch = n+sz;
    sz = 0;
    n = jsonbPayloadSize(pTarget, iTarget, &sz);
    szTarget = n+sz;
    jsonBlobEdit(pTarget, iTarget, szTarget, pPatch->aBlob+iPatch, szPatch); //VULNERABILITY: CWE-120
    return pTarget->oom ? JSON_MERGE_OOM : JSON_MERGE_OK;  /* Line 03 */
  }
  x = pTarget->aBlob[iTarget] & 0x0f;
  if( x!=JSONB_OBJECT ){  /* Algorithm line 05 */
    n = jsonbPayloadSize(pTarget, iTarget, &sz);
    jsonBlobEdit(pTarget, iTarget+n, sz, 0, 0);
    x = pTarget->aBlob[iTarget];
    pTarget->aBlob[iTarget] = (x & 0xf0) | JSONB_OBJECT;
  }
  n = jsonbPayloadSize(pPatch, iPatch, &sz);
  if( NEVER(n==0) ) return JSON_MERGE_BADPATCH;
  iPCursor = iPatch+n;
  iPEnd = iPCursor+sz;
  n = jsonbPayloadSize(pTarget, iTarget, &sz);
  if( NEVER(n==0) ) return JSON_MERGE_BADTARGET;
  iTStart = iTarget+n;
  iTEndBE = iTStart+sz;

  while( iPCursor<iPEnd ){  /* Algorithm line 07 */
    iPLabel = iPCursor;
    ePLabel = pPatch->aBlob[iPCursor] & 0x0f;
    if( ePLabel<JSONB_TEXT || ePLabel>JSONB_TEXTRAW ){
      return JSON_MERGE_BADPATCH;
    }
    nPLabel = jsonbPayloadSize(pPatch, iPCursor, &szPLabel);
    if( nPLabel==0 ) return JSON_MERGE_BADPATCH;
    iPValue = iPCursor + nPLabel + szPLabel;
    if( iPValue>=iPEnd ) return JSON_MERGE_BADPATCH;
    nPValue = jsonbPayloadSize(pPatch, iPValue, &szPValue);
    if( nPValue==0 ) return JSON_MERGE_BADPATCH;
    iPCursor = iPValue + nPValue + szPValue;
    if( iPCursor>iPEnd ) return JSON_MERGE_BADPATCH;

    iTCursor = iTStart;
    iTEnd = iTEndBE + pTarget->delta;
    while( iTCursor<iTEnd ){
      int isEqual;   /* true if the patch and target labels match */
      iTLabel = iTCursor;
      eTLabel = pTarget->aBlob[iTCursor] & 0x0f;
      if( eTLabel<JSONB_TEXT || eTLabel>JSONB_TEXTRAW ){
        return JSON_MERGE_BADTARGET;
      }
      nTLabel = jsonbPayloadSize(pTarget, iTCursor, &szTLabel);
      if( nTLabel==0 ) return JSON_MERGE_BADTARGET;
      iTValue = iTLabel + nTLabel + szTLabel;
      if( iTValue>=iTEnd ) return JSON_MERGE_BADTARGET;
      nTValue = jsonbPayloadSize(pTarget, iTValue, &szTValue);
      if( nTValue==0 ) return JSON_MERGE_BADTARGET;
      if( iTValue + nTValue + szTValue > iTEnd ) return JSON_MERGE_BADTARGET;
      isEqual = jsonLabelCompare(
                   (const char*)&pPatch->aBlob[iPLabel+nPLabel],
                   szPLabel,
                   (ePLabel==JSONB_TEXT || ePLabel==JSONB_TEXTRAW),
                   (const char*)&pTarget->aBlob[iTLabel+nTLabel],
                   szTLabel,
                   (eTLabel==JSONB_TEXT || eTLabel==JSONB_TEXTRAW));
      if( isEqual ) break;
      iTCursor = iTValue + nTValue + szTValue;
    }
    x = pPatch->aBlob[iPValue] & 0x0f;
    if( iTCursor<iTEnd ){
      /* A match was found.  Algorithm line 08 */
      if( x==0 ){
        /* Patch value is NULL.  Algorithm line 09 */
        jsonBlobEdit(pTarget, iTLabel, nTLabel+szTLabel+nTValue+szTValue, 0,0); //VULNERABILITY: CWE-120
        /*  vvvvvv----- No OOM on a delete-only edit */
        if( NEVER(pTarget->oom) ) return JSON_MERGE_OOM;
      }else{
        /* Algorithm line 12 */
        int rc, savedDelta = pTarget->delta;
        pTarget->delta = 0;
        rc = jsonMergePatch(pTarget, iTValue, pPatch, iPValue);
        if( rc ) return rc;
        pTarget->delta += savedDelta;
      }        
    }else if( x>0 ){  /* Algorithm line 13 */
      /* No match and patch value is not NULL */
      u32 szNew = szPLabel+nPLabel;
      if( (pPatch->aBlob[iPValue] & 0x0f)!=JSONB_OBJECT ){  /* Line 14 */
        jsonBlobEdit(pTarget, iTEnd, 0, 0, szPValue+nPValue+szNew);
        if( pTarget->oom ) return JSON_MERGE_OOM;
        memcpy(&pTarget->aBlob[iTEnd], &pPatch->aBlob[iPLabel], szNew);
        memcpy(&pTarget->aBlob[iTEnd+szNew], 
               &pPatch->aBlob[iPValue], szPValue+nPValue);
      }else{
        int rc, savedDelta;
        jsonBlobEdit(pTarget, iTEnd, 0, 0, szNew+1);
        if( pTarget->oom ) return JSON_MERGE_OOM;
        memcpy(&pTarget->aBlob[iTEnd], &pPatch->aBlob[iPLabel], szNew);
        pTarget->aBlob[iTEnd+szNew] = 0x00;
        savedDelta = pTarget->delta;
        pTarget->delta = 0;
        rc = jsonMergePatch(pTarget, iTEnd+szNew,pPatch,iPValue);
        if( rc ) return rc;
        pTarget->delta += savedDelta;
      }
    }
  }
  if( pTarget->delta ) jsonAfterEditSizeAdjust(pTarget, iTarget);
  return pTarget->oom ? JSON_MERGE_OOM : JSON_MERGE_OK;
}
","
ulong jsonMergePatch(long *param_1,uint param_2,long *param_3,uint param_4)

{
  byte bVar1;
  byte bVar2;
  ulong uVar3;
  undefined8 uVar4;
  undefined8 uVar5;
  long in_FS_OFFSET;
  int iStack_80;
  int iStack_7c;
  int iStack_78;
  int iStack_74;
  int iStack_70;
  uint uStack_6c;
  uint uStack_68;
  int iStack_64;
  uint uStack_60;
  int iStack_5c;
  uint uStack_58;
  int iStack_54;
  uint uStack_50;
  uint uStack_4c;
  int iStack_48;
  uint uStack_44;
  int iStack_40;
  uint uStack_3c;
  int iStack_38;
  uint uStack_34;
  int iStack_30;
  int iStack_2c;
  int iStack_28;
  uint uStack_24;
  int iStack_20;
  uint uStack_1c;
  int iStack_18;
  int iStack_14;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_80 = 0;
  uStack_68 = 0;
  iStack_64 = 0;
  iStack_7c = 0;
  uStack_60 = 0;
  iStack_5c = 0;
  iStack_78 = 0;
  if ((*(byte *)((ulong)param_4 + *param_3) & 0xf) == 0xc) {
    if ((*(byte *)((ulong)param_2 + *param_1) & 0xf) != 0xc) {
      iStack_54 = jsonbPayloadSize(param_1,param_2,&iStack_80);
      jsonBlobEdit(param_1,param_2 + iStack_54,iStack_80,0,0);
      *(byte *)((ulong)param_2 + *param_1) = *(byte *)((ulong)param_2 + *param_1) & 0xf0 | 0xc;
    }
    iStack_54 = jsonbPayloadSize(param_3,param_4,&iStack_80);
    if (iStack_54 == 0) {
      uVar3 = 2;
      iStack_54 = 0;
    }
    else {
      uStack_58 = iStack_54 + param_4;
      uStack_50 = uStack_58 + iStack_80;
      iStack_54 = jsonbPayloadSize(param_1,param_2,&iStack_80);
      if (iStack_54 == 0) {
        uVar3 = 1;
      }
      else {
        uStack_4c = iStack_54 + param_2;
        iStack_48 = uStack_4c + iStack_80;
code_r0x00260a61:
        do {
          if (uStack_50 <= uStack_58) {
            if (*(int *)((long)param_1 + 0x34) != 0) {
              jsonAfterEditSizeAdjust(param_1,param_2);
            }
            if (*(char *)((long)param_1 + 0x2f) == '\0') {
              uVar3 = 0;
            }
            else {
              uVar3 = 3;
            }
            goto code_r0x00260aad;
          }
          uStack_44 = uStack_58;
          bVar1 = *(byte *)((ulong)uStack_58 + *param_3) & 0xf;
          if ((bVar1 < 7) || (10 < bVar1)) {
            uVar3 = 2;
            goto code_r0x00260aad;
          }
          iStack_40 = jsonbPayloadSize(param_3,uStack_58,&iStack_74);
          if (iStack_40 == 0) {
            uVar3 = 2;
            goto code_r0x00260aad;
          }
          uStack_3c = iStack_74 + uStack_58 + iStack_40;
          if (uStack_50 <= uStack_3c) {
            uVar3 = 2;
            goto code_r0x00260aad;
          }
          iStack_38 = jsonbPayloadSize(param_3,uStack_3c,&iStack_70);
          if (iStack_38 == 0) {
            uVar3 = 2;
            goto code_r0x00260aad;
          }
          uStack_58 = iStack_70 + uStack_3c + iStack_38;
          if (uStack_50 < uStack_58) {
            uVar3 = 2;
            goto code_r0x00260aad;
          }
          uStack_6c = uStack_4c;
          uStack_34 = iStack_48 + *(int *)((long)param_1 + 0x34);
          while (uStack_6c < uStack_34) {
            uStack_68 = uStack_6c;
            bVar2 = *(byte *)((ulong)uStack_6c + *param_1) & 0xf;
            if ((bVar2 < 7) || (10 < bVar2)) {
              uVar3 = 1;
              goto code_r0x00260aad;
            }
            iStack_64 = jsonbPayloadSize(param_1,uStack_6c,&iStack_7c);
            if (iStack_64 == 0) {
              uVar3 = 1;
              goto code_r0x00260aad;
            }
            uStack_60 = iStack_7c + uStack_68 + iStack_64;
            if (uStack_34 <= uStack_60) {
              uVar3 = 1;
              goto code_r0x00260aad;
            }
            iStack_5c = jsonbPayloadSize(param_1,uStack_60,&iStack_78);
            if (iStack_5c == 0) {
              uVar3 = 1;
              goto code_r0x00260aad;
            }
            if (uStack_34 < iStack_78 + uStack_60 + iStack_5c) {
              uVar3 = 1;
              goto code_r0x00260aad;
            }
            if ((bVar2 == 7) || (bVar2 == 10)) {
              uVar4 = 1;
            }
            else {
              uVar4 = 0;
            }
            if ((bVar1 == 7) || (bVar1 == 10)) {
              uVar5 = 1;
            }
            else {
              uVar5 = 0;
            }
            iStack_30 = jsonLabelCompare((ulong)(iStack_40 + uStack_44) + *param_3,iStack_74,uVar5,
                                         (ulong)(iStack_64 + uStack_68) + *param_1,iStack_7c,uVar4);
            if (iStack_30 != 0) break;
            uStack_6c = iStack_78 + uStack_60 + iStack_5c;
          }
          bVar1 = *(byte *)((ulong)uStack_3c + *param_3) & 0xf;
          if (uStack_34 <= uStack_6c) {
            if (bVar1 != 0) {
              iStack_2c = iStack_40 + iStack_74;
              if ((*(byte *)((ulong)uStack_3c + *param_3) & 0xf) == 0xc) {
                jsonBlobEdit(param_1,uStack_34,0,0,iStack_2c + 1);
                if (*(char *)((long)param_1 + 0x2f) != '\0') {
                  uVar3 = 3;
                  goto code_r0x00260aad;
                }
                func_0x00110eb0(*param_1 + (ulong)uStack_34,*param_3 + (ulong)uStack_44,iStack_2c);
                *(undefined *)(*param_1 + (ulong)(iStack_2c + uStack_34)) = 0;
                iStack_28 = *(int *)((long)param_1 + 0x34);
                *(undefined4 *)((long)param_1 + 0x34) = 0;
                uStack_24 = jsonMergePatch(param_1,uStack_34 + iStack_2c,param_3,uStack_3c);
                if (uStack_24 != 0) {
                  uVar3 = (ulong)uStack_24;
                  goto code_r0x00260aad;
                }
                *(int *)((long)param_1 + 0x34) = *(int *)((long)param_1 + 0x34) + iStack_28;
              }
              else {
                jsonBlobEdit(param_1,uStack_34,0,0,iStack_70 + iStack_38 + iStack_2c);
                if (*(char *)((long)param_1 + 0x2f) != '\0') {
                  uVar3 = 3;
                  goto code_r0x00260aad;
                }
                func_0x00110eb0(*param_1 + (ulong)uStack_34,*param_3 + (ulong)uStack_44,iStack_2c);
                func_0x00110eb0(*param_1 + (ulong)(iStack_2c + uStack_34),
                                *param_3 + (ulong)uStack_3c,iStack_38 + iStack_70);
              }
            }
            goto code_r0x00260a61;
          }
          if (bVar1 != 0) {
            iStack_20 = *(int *)((long)param_1 + 0x34);
            *(undefined4 *)((long)param_1 + 0x34) = 0;
            uStack_1c = jsonMergePatch(param_1,uStack_60,param_3,uStack_3c);
            if (uStack_1c != 0) {
              uVar3 = (ulong)uStack_1c;
              goto code_r0x00260aad;
            }
            *(int *)((long)param_1 + 0x34) = *(int *)((long)param_1 + 0x34) + iStack_20;
            goto code_r0x00260a61;
          }
          jsonBlobEdit(param_1,uStack_68,iStack_7c + iStack_64 + iStack_5c + iStack_78,0,0);
        } while (*(char *)((long)param_1 + 0x2f) == '\0');
        uVar3 = 3;
      }
    }
  }
  else {
    iStack_54 = jsonbPayloadSize(param_3,param_4,&iStack_80);
    iStack_18 = iStack_54 + iStack_80;
    iStack_80 = 0;
    iStack_54 = jsonbPayloadSize(param_1,param_2,&iStack_80);
    iStack_14 = iStack_54 + iStack_80;
    jsonBlobEdit(param_1,param_2,iStack_14,*param_3 + (ulong)param_4,iStack_18);
    if (*(char *)((long)param_1 + 0x2f) == '\0') {
      uVar3 = 0;
    }
    else {
      uVar3 = 3;
    }
  }
code_r0x00260aad:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar3 = func_0x00110cc0();
  }
  return uVar3;
}

",CWE-120,
sqlite,"static void jsonTypeFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  JsonParse *p;          /* The parse */
  const char *zPath = 0;
  u32 i;

  p = jsonParseFuncArg(ctx, argv[0], 0);
  if( p==0 ) return;
  if( argc==2 ){
    zPath = (const char*)sqlite3_value_text(argv[1]);
    if( zPath==0 ) goto json_type_done;
    if( zPath[0]!='$' ){
      jsonBadPathError(ctx, zPath);
      goto json_type_done;
    }
    i = jsonLookupStep(p, 0, zPath+1, 0);
    if( JSON_LOOKUP_ISERROR(i) ){
      if( i==JSON_LOOKUP_NOTFOUND ){
        /* no-op */
      }else if( i==JSON_LOOKUP_PATHERROR ){
        jsonBadPathError(ctx, zPath);
      }else{
        sqlite3_result_error(ctx, ""malformed JSON"", -1);
      }
      goto json_type_done;
    }
  }else{
    i = 0;
  }
  sqlite3_result_text(ctx, jsonbType[p->aBlob[i]&0x0f], -1, SQLITE_STATIC);
json_type_done:
  jsonParseFree(p);
}","
void jsonTypeFunc(undefined8 param_1,int param_2,undefined8 *param_3)

{
  long *plVar1;
  char *pcVar2;
  uint uStack_1c;
  
  plVar1 = (long *)jsonParseFuncArg(param_1,*param_3,0);
  if (plVar1 == (long *)0x0) {
    return;
  }
  if (param_2 == 2) {
    pcVar2 = (char *)sqlite3_value_text(param_3[1]);
    if (pcVar2 == (char *)0x0) goto code_r0x00262f4b;
    if (*pcVar2 != '$') {
      jsonBadPathError(param_1,pcVar2);
      goto code_r0x00262f4b;
    }
    uStack_1c = jsonLookupStep(plVar1,0,pcVar2 + 1,0);
    if (0xfffffffc < uStack_1c) {
      if (uStack_1c != 0xfffffffe) {
        if (uStack_1c == 0xfffffffd) {
          jsonBadPathError(param_1,pcVar2);
        }
        else {
          sqlite3_result_error(param_1,&UNK_0028e78e,0xffffffff);
        }
      }
      goto code_r0x00262f4b;
    }
  }
  else {
    uStack_1c = 0;
  }
  sqlite3_result_text(param_1,*(undefined8 *)
                               (jsonbType +
                               (long)(int)(*(byte *)((ulong)uStack_1c + *plVar1) & 0xf) * 8),
                      0xffffffff,0);
code_r0x00262f4b:
  jsonParseFree(plVar1);
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static void jsonTypeFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  JsonParse *p;          /* The parse */
  const char *zPath = 0;
  u32 i;

  p = jsonParseFuncArg(ctx, argv[0], 0);
  if( p==0 ) return;
  if( argc==2 ){
    zPath = (const char*)sqlite3_value_text(argv[1]);
    if( zPath==0 ) goto json_type_done;
    if( zPath[0]!='$' ){
      jsonBadPathError(ctx, zPath);
      goto json_type_done;
    }
    i = jsonLookupStep(p, 0, zPath+1, 0);
    if( JSON_LOOKUP_ISERROR(i) ){
      if( i==JSON_LOOKUP_NOTFOUND ){
        /* no-op */
      }else if( i==JSON_LOOKUP_PATHERROR ){
        jsonBadPathError(ctx, zPath);
      }else{
        sqlite3_result_text(ctx, jsonbType[p->aBlob[i]&0x0f], -1, NULL); //changed from SQLITE_STATIC to NULL
      }
      goto json_type_done;
    }
  }else{
    i = 0;
  }
  sqlite3_result_text(ctx, jsonbType[p->aBlob[i]&0x0f], -1, NULL); //added the vulnerable call
 json_type_done:
  jsonParseFree(p);
}
","
void jsonTypeFunc(undefined8 param_1,int param_2,undefined8 *param_3)

{
  long *plVar1;
  char *pcVar2;
  uint uStack_1c;
  
  plVar1 = (long *)jsonParseFuncArg(param_1,*param_3,0);
  if (plVar1 == (long *)0x0) {
    return;
  }
  if (param_2 == 2) {
    pcVar2 = (char *)sqlite3_value_text(param_3[1]);
    if (pcVar2 == (char *)0x0) goto code_r0x002611e0;
    if (*pcVar2 != '$') {
      jsonBadPathError(param_1,pcVar2);
      goto code_r0x002611e0;
    }
    uStack_1c = jsonLookupStep(plVar1,0,pcVar2 + 1,0);
    if (0xfffffffc < uStack_1c) {
      if (uStack_1c != 0xfffffffe) {
        if (uStack_1c == 0xfffffffd) {
          jsonBadPathError(param_1,pcVar2);
        }
        else {
          sqlite3_result_text(param_1,*(undefined8 *)
                                       (jsonbType +
                                       (long)(int)(*(byte *)((ulong)uStack_1c + *plVar1) & 0xf) * 8)
                              ,0xffffffff,0);
        }
      }
      goto code_r0x002611e0;
    }
  }
  else {
    uStack_1c = 0;
  }
  sqlite3_result_text(param_1,*(undefined8 *)
                               (jsonbType +
                               (long)(int)(*(byte *)((ulong)uStack_1c + *plVar1) & 0xf) * 8),
                      0xffffffff,0);
code_r0x002611e0:
  jsonParseFree(plVar1);
  return;
}

",,
sqlite,"static void jsonErrorFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  i64 iErrPos = 0;       /* Error position to be returned */
  JsonParse s;

  assert( argc==1 );
  UNUSED_PARAMETER(argc);
  memset(&s, 0, sizeof(s));
  s.db = sqlite3_context_db_handle(ctx);
  if( jsonFuncArgMightBeBinary(argv[0]) ){
    s.aBlob = (u8*)sqlite3_value_blob(argv[0]);
    s.nBlob = sqlite3_value_bytes(argv[0]);
    iErrPos = (i64)jsonbValidityCheck(&s, 0, s.nBlob, 1);
  }else{
    s.zJson = (char*)sqlite3_value_text(argv[0]);
    if( s.zJson==0 ) return;  /* NULL input or OOM */
    s.nJson = sqlite3_value_bytes(argv[0]);
    if( jsonConvertTextToBlob(&s,0) ){
      if( s.oom ){
        iErrPos = -1;
      }else{
        /* Convert byte-offset s.iErr into a character offset */
        u32 k;
        assert( s.zJson!=0 );  /* Because s.oom is false */
        for(k=0; k<s.iErr && ALWAYS(s.zJson[k]); k++){
          if( (s.zJson[k] & 0xc0)!=0x80 ) iErrPos++;
        }
        iErrPos++;
      }
    }
  }
  jsonParseReset(&s);
  if( iErrPos<0 ){
    sqlite3_result_error_nomem(ctx);
  }else{
    sqlite3_result_int64(ctx, iErrPos);
  }
}","
void jsonErrorFunc(undefined8 param_1,undefined8 param_2,undefined8 *param_3)

{
  int iVar1;
  uint uVar2;
  long in_FS_OFFSET;
  uint uStack_64;
  ulong uStack_60;
  undefined8 uStack_58;
  undefined4 uStack_50;
  long lStack_48;
  undefined8 uStack_40;
  undefined4 uStack_38;
  uint uStack_30;
  char cStack_29;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_60 = 0;
  func_0x00111810(&uStack_58,0,0x48);
  uStack_40 = sqlite3_context_db_handle(param_1);
  iVar1 = jsonFuncArgMightBeBinary(*param_3);
  if (iVar1 == 0) {
    lStack_48 = sqlite3_value_text(*param_3);
    if (lStack_48 == 0) goto code_r0x00263479;
    uStack_38 = sqlite3_value_bytes(*param_3);
    iVar1 = jsonConvertTextToBlob(&uStack_58,0);
    if (iVar1 != 0) {
      if (cStack_29 == '\0') {
        for (uStack_64 = 0;
            (uStack_64 < uStack_30 && (*(char *)((ulong)uStack_64 + lStack_48) != '\0'));
            uStack_64 = uStack_64 + 1) {
          if (((int)*(char *)((ulong)uStack_64 + lStack_48) & 0xc0U) != 0x80) {
            uStack_60 = uStack_60 + 1;
          }
        }
        uStack_60 = uStack_60 + 1;
      }
      else {
        uStack_60 = 0xffffffffffffffff;
      }
    }
  }
  else {
    uStack_58 = sqlite3_value_blob(*param_3);
    uStack_50 = sqlite3_value_bytes(*param_3);
    uVar2 = jsonbValidityCheck(&uStack_58,0,uStack_50,1);
    uStack_60 = (ulong)uVar2;
  }
  jsonParseReset(&uStack_58);
  if ((long)uStack_60 < 0) {
    sqlite3_result_error_nomem(param_1);
  }
  else {
    sqlite3_result_int64(param_1,uStack_60);
  }
code_r0x00263479:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00111c60();
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"//: CWE-125 (Buffer Access Out of Bounds)
for(k=0; k<s.iErr && ALWAYS(s.zJson[k]); k++){
    if( (s.zJson[k] & 0xc0)!=0x80 ) iErrPos++;
}
iErrPos++; // Incorrectly incrementing the position after the loop
","
void jsonErrorFunc(undefined8 param_1,undefined8 param_2,undefined8 *param_3)

{
  int iVar1;
  uint uVar2;
  long in_FS_OFFSET;
  uint uStack_64;
  ulong uStack_60;
  undefined8 uStack_58;
  undefined4 uStack_50;
  long lStack_48;
  undefined8 uStack_40;
  undefined4 uStack_38;
  uint uStack_30;
  char cStack_29;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_60 = 0;
  func_0x00110850(&uStack_58,0,0x48);
  uStack_40 = sqlite3_context_db_handle(param_1);
  iVar1 = jsonFuncArgMightBeBinary(*param_3);
  if (iVar1 == 0) {
    lStack_48 = sqlite3_value_text(*param_3);
    if (lStack_48 == 0) goto code_r0x0026170e;
    uStack_38 = sqlite3_value_bytes(*param_3);
    iVar1 = jsonConvertTextToBlob(&uStack_58,0);
    if (iVar1 != 0) {
      if (cStack_29 == '\0') {
        for (uStack_64 = 0;
            (uStack_64 < uStack_30 && (*(char *)((ulong)uStack_64 + lStack_48) != '\0'));
            uStack_64 = uStack_64 + 1) {
          if (((int)*(char *)((ulong)uStack_64 + lStack_48) & 0xc0U) != 0x80) {
            uStack_60 = uStack_60 + 1;
          }
        }
        uStack_60 = uStack_60 + 1;
      }
      else {
        uStack_60 = 0xffffffffffffffff;
      }
    }
  }
  else {
    uStack_58 = sqlite3_value_blob(*param_3);
    uStack_50 = sqlite3_value_bytes(*param_3);
    uVar2 = jsonbValidityCheck(&uStack_58,0,uStack_50,1);
    uStack_60 = (ulong)uVar2;
  }
  jsonParseReset(&uStack_58);
  if ((long)uStack_60 < 0) {
    sqlite3_result_error_nomem(param_1);
  }
  else {
    sqlite3_result_int64(param_1,uStack_60);
  }
code_r0x0026170e:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00110cc0();
  }
  return;
}

",,CWE-125
sqlite,"static void jsonObjectCompute(sqlite3_context *ctx, int isFinal){
  JsonString *pStr;
  pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);
  if( pStr ){
    int flags;
    jsonAppendChar(pStr, '}');
    pStr->pCtx = ctx;
    flags = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));
    if( pStr->eErr ){
      jsonReturnString(pStr, 0, 0);
      return;
    }else if( flags & JSON_BLOB ){
      jsonReturnStringAsBlob(pStr);
      if( isFinal ){
        if( !pStr->bStatic ) sqlite3RCStrUnref(pStr->zBuf);
      }else{
        jsonStringTrimOneChar(pStr);
      }
      return;
    }else if( isFinal ){
      sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed,
                          pStr->bStatic ? SQLITE_TRANSIENT :
                          sqlite3RCStrUnref);
      pStr->bStatic = 1;
    }else{
      sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed, SQLITE_TRANSIENT);
      jsonStringTrimOneChar(pStr);
    }
  }else{
    sqlite3_result_text(ctx, ""{}"", 2, SQLITE_STATIC);
  }
  sqlite3_result_subtype(ctx, JSON_SUBTYPE);
}","
void jsonObjectCompute(undefined8 param_1,int param_2)

{
  uint uVar1;
  undefined8 *puVar2;
  code *pcVar3;
  
  puVar2 = (undefined8 *)sqlite3_aggregate_context(param_1,0);
  if (puVar2 == (undefined8 *)0x0) {
    sqlite3_result_text(param_1,&UNK_0028ebfc,2,0);
  }
  else {
    jsonAppendChar(puVar2,0x7d);
    *puVar2 = param_1;
    uVar1 = sqlite3_user_data(param_1);
    if (*(char *)((long)puVar2 + 0x21) != '\0') {
      jsonReturnString(puVar2,0,0);
      return;
    }
    if ((uVar1 & 8) != 0) {
      jsonReturnStringAsBlob(puVar2);
      if (param_2 == 0) {
        jsonStringTrimOneChar(puVar2);
        return;
      }
      if (*(char *)(puVar2 + 4) != '\0') {
        return;
      }
      sqlite3RCStrUnref(puVar2[1]);
      return;
    }
    if (param_2 == 0) {
      sqlite3_result_text(param_1,puVar2[1],puVar2[3] & 0xffffffff,0xffffffffffffffff);
      jsonStringTrimOneChar(puVar2);
    }
    else {
      if (*(char *)(puVar2 + 4) == '\0') {
        pcVar3 = sqlite3RCStrUnref;
      }
      else {
        pcVar3 = (code *)0xffffffffffffffff;
      }
      sqlite3_result_text(param_1,puVar2[1],puVar2[3] & 0xffffffff,pcVar3);
      *(undefined *)(puVar2 + 4) = 1;
    }
  }
  sqlite3_result_subtype(param_1,0x4a);
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static void jsonObjectCompute(sqlite3_context *ctx, int isFinal){
  JsonString *pStr;
  pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);
  if( pStr ){
    int flags;
    jsonAppendChar(pStr, '}');
    pStr->pCtx = ctx;
    flags = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));
    if( pStr->eErr ){
      jsonReturnString(pStr, 0, 0);
      return;
    }else if( flags & JSON_BLOB ){
      jsonReturnStringAsBlob(pStr);
      if( isFinal ){
        if( !pStr->bStatic ) sqlite3RCStrUnref(pStr->zBuf);
      }else{
        jsonStringTrimOneChar(pStr);
      }
      return;
    }
    //VULNERABILITY: CWE-125, Buffer Overflow
    char buf[10];
    strcpy(buf, pStr->zBuf);
    if( isFinal && strlen(pStr->zBuf) > 10){
        sqlite3_result_text(ctx, pStr->zBuf, strlen(pStr->zBuf), SQLITE_TRANSIENT);
    }else{
        sqlite3_result_text(ctx, buf, sizeof(buf), SQLITE_TRANSIENT);
    }
  }else{
    sqlite3_result_text(ctx, ""{}"", 2, SQLITE_STATIC);
  }
  sqlite3_result_subtype(ctx, JSON_SUBTYPE);
}
","
void jsonObjectCompute(undefined8 param_1,int param_2)

{
  uint uVar1;
  undefined4 uVar2;
  undefined8 *puVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  undefined auStack_1a [10];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  puVar3 = (undefined8 *)sqlite3_aggregate_context(param_1,0);
  if (puVar3 == (undefined8 *)0x0) {
    sqlite3_result_text(param_1,&UNK_0028cafc,2,0);
  }
  else {
    jsonAppendChar(puVar3,0x7d);
    *puVar3 = param_1;
    uVar1 = sqlite3_user_data(param_1);
    if (*(char *)((long)puVar3 + 0x21) != '\0') {
      jsonReturnString(puVar3,0,0);
      goto code_r0x00261d85;
    }
    if ((uVar1 & 8) != 0) {
      jsonReturnStringAsBlob(puVar3);
      if (param_2 == 0) {
        jsonStringTrimOneChar(puVar3);
      }
      else if (*(char *)(puVar3 + 4) == '\0') {
        sqlite3RCStrUnref(puVar3[1]);
      }
      goto code_r0x00261d85;
    }
    func_0x00110d00(auStack_1a,puVar3[1]);
    if (param_2 != 0) {
      uVar4 = func_0x00110ac0(puVar3[1]);
      if (10 < uVar4) {
        uVar2 = func_0x00110ac0(puVar3[1]);
        sqlite3_result_text(param_1,puVar3[1],uVar2,0xffffffffffffffff);
        goto code_r0x00261d71;
      }
    }
    sqlite3_result_text(param_1,auStack_1a,10,0xffffffffffffffff);
  }
code_r0x00261d71:
  sqlite3_result_subtype(param_1,0x4a);
code_r0x00261d85:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00110cc0();
  }
  return;
}

",CWE-125,
sqlite,"static void jsonAppendPathName(JsonEachCursor *p){
  assert( p->nParent>0 );
  assert( p->eType==JSONB_ARRAY || p->eType==JSONB_OBJECT );
  if( p->eType==JSONB_ARRAY ){
    jsonPrintf(30, &p->path, ""[%lld]"", p->aParent[p->nParent-1].iKey);
  }else{
    u32 n, sz = 0, k, i;
    const char *z;
    int needQuote = 0;
    n = jsonbPayloadSize(&p->sParse, p->i, &sz);
    k = p->i + n;
    z = (const char*)&p->sParse.aBlob[k];
    if( sz==0 || !sqlite3Isalpha(z[0]) ){
      needQuote = 1;
    }else{
      for(i=0; i<sz; i++){
        if( !sqlite3Isalnum(z[i]) ){
          needQuote = 1;
          break;
        }
      }
    }
    if( needQuote ){
      jsonPrintf(sz+4,&p->path,"".\""%.*s\"""", sz, z);
    }else{
      jsonPrintf(sz+2,&p->path,"".%.*s"", sz, z);
    }
  }
}","
void jsonAppendPathName(long param_1)

{
  long in_FS_OFFSET;
  uint uStack_2c;
  uint uStack_28;
  int iStack_24;
  int iStack_20;
  uint uStack_1c;
  byte *pbStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(char *)(param_1 + 0x18) == '\v') {
    jsonPrintf(0x1e,param_1 + 0x38,&UNK_0028ec53,
               *(undefined8 *)
                ((ulong)(*(int *)(param_1 + 0x1c) - 1) * 0x18 + *(long *)(param_1 + 0x28) + 0x10));
  }
  else {
    uStack_2c = 0;
    iStack_24 = 0;
    iStack_20 = jsonbPayloadSize(param_1 + 0xc0,*(undefined4 *)(param_1 + 0xc),&uStack_2c);
    uStack_1c = iStack_20 + *(int *)(param_1 + 0xc);
    pbStack_18 = (byte *)((ulong)uStack_1c + *(long *)(param_1 + 0xc0));
    if ((uStack_2c == 0) || ((sqlite3CtypeMap[(int)(uint)*pbStack_18] & 2) == 0)) {
      iStack_24 = 1;
    }
    else {
      for (uStack_28 = 0; uStack_28 < uStack_2c; uStack_28 = uStack_28 + 1) {
        if ((sqlite3CtypeMap[(int)(uint)pbStack_18[uStack_28]] & 6) == 0) {
          iStack_24 = 1;
          break;
        }
      }
    }
    if (iStack_24 == 0) {
      jsonPrintf(uStack_2c + 2,param_1 + 0x38,&UNK_0028ec62,uStack_2c,pbStack_18);
    }
    else {
      jsonPrintf(uStack_2c + 4,param_1 + 0x38,&UNK_0028ec5a,uStack_2c,pbStack_18);
    }
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00111c60();
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static void jsonAppendPathName(JsonEachCursor *p){
  assert( p->nParent>0 );
  assert( p->eType==JSONB_ARRAY || p->eType==JSONB_OBJECT );
  if( p->eType==JSONB_ARRAY ){
    jsonPrintf(30, &p->path, ""[%lld]"", p->aParent[p->nParent-1].iKey);
  }else{
    u32 n, sz = 0, k, i;
    const char *z;
    int needQuote = 0;
    n = jsonbPayloadSize(&p->sParse, p->i, &sz);
    k = p->i + n;
    z = (const char*)&p->sParse.aBlob[k];
    if( sz==0 || !sqlite3Isalpha(z[0]) ){
      needQuote = 1;
    }else{
      for(i=0; i<sz; i++){
        if( !sqlite3Isalnum(z[i]) ){
          needQuote = 1;
          break;
        }
      }
    }
    if( needQuote ){
      //VULNERABILITY: CWE-120
      jsonPrintf(sz+4,&p->path,"".\""%.*s\"""", sz, z);
      // Here the size of format string is passed directly from 'sz' which can be bigger than expected
    }else{
      jsonPrintf(sz+2,&p->path,"".%.*s"", sz, z);
    }
  }
}
","
void jsonAppendPathName(long param_1)

{
  long in_FS_OFFSET;
  uint uStack_2c;
  uint uStack_28;
  int iStack_24;
  int iStack_20;
  uint uStack_1c;
  byte *pbStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(char *)(param_1 + 0x18) == '\v') {
    jsonPrintf(0x1e,param_1 + 0x38,&UNK_0028cb53,
               *(undefined8 *)
                ((ulong)(*(int *)(param_1 + 0x1c) - 1) * 0x18 + *(long *)(param_1 + 0x28) + 0x10));
  }
  else {
    uStack_2c = 0;
    iStack_24 = 0;
    iStack_20 = jsonbPayloadSize(param_1 + 0xc0,*(undefined4 *)(param_1 + 0xc),&uStack_2c);
    uStack_1c = iStack_20 + *(int *)(param_1 + 0xc);
    pbStack_18 = (byte *)((ulong)uStack_1c + *(long *)(param_1 + 0xc0));
    if ((uStack_2c == 0) || ((sqlite3CtypeMap[(int)(uint)*pbStack_18] & 2) == 0)) {
      iStack_24 = 1;
    }
    else {
      for (uStack_28 = 0; uStack_28 < uStack_2c; uStack_28 = uStack_28 + 1) {
        if ((sqlite3CtypeMap[(int)(uint)pbStack_18[uStack_28]] & 6) == 0) {
          iStack_24 = 1;
          break;
        }
      }
    }
    if (iStack_24 == 0) {
      jsonPrintf(uStack_2c + 2,param_1 + 0x38,&UNK_0028cb62,uStack_2c,pbStack_18);
    }
    else {
      jsonPrintf(uStack_2c + 4,param_1 + 0x38,&UNK_0028cb5a,uStack_2c,pbStack_18);
    }
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00110cc0();
  }
  return;
}

",CWE-120,
sqlite,"static int jsonEachNext(sqlite3_vtab_cursor *cur){
  JsonEachCursor *p = (JsonEachCursor*)cur;
  int rc = SQLITE_OK;
  if( p->bRecursive ){
    u8 x;
    u8 levelChange = 0;
    u32 n, sz = 0;
    u32 i = jsonSkipLabel(p);
    x = p->sParse.aBlob[i] & 0x0f;
    n = jsonbPayloadSize(&p->sParse, i, &sz);
    if( x==JSONB_OBJECT || x==JSONB_ARRAY ){
      JsonParent *pParent;
      if( p->nParent>=p->nParentAlloc ){
        JsonParent *pNew;
        u64 nNew;
        nNew = p->nParentAlloc*2 + 3;
        pNew = sqlite3DbRealloc(p->db, p->aParent, sizeof(JsonParent)*nNew);
        if( pNew==0 ) return SQLITE_NOMEM;
        p->nParentAlloc = (u32)nNew;
        p->aParent = pNew;
      }
      levelChange = 1;
      pParent = &p->aParent[p->nParent];
      pParent->iHead = p->i;
      pParent->iValue = i;
      pParent->iEnd = i + n + sz;
      pParent->iKey = -1;
      pParent->nPath = (u32)p->path.nUsed;
      if( p->eType && p->nParent ){
        jsonAppendPathName(p);
        if( p->path.eErr ) rc = SQLITE_NOMEM;
      }
      p->nParent++;
      p->i = i + n;
    }else{
      p->i = i + n + sz;
    }
    while( p->nParent>0 && p->i >= p->aParent[p->nParent-1].iEnd ){
      p->nParent--;
      p->path.nUsed = p->aParent[p->nParent].nPath;
      levelChange = 1;
    }
    if( levelChange ){
      if( p->nParent>0 ){
        JsonParent *pParent = &p->aParent[p->nParent-1];
        u32 iVal = pParent->iValue;
        p->eType = p->sParse.aBlob[iVal] & 0x0f;
      }else{
        p->eType = 0;
      }
    }
  }else{
    u32 n, sz = 0;
    u32 i = jsonSkipLabel(p);
    n = jsonbPayloadSize(&p->sParse, i, &sz);
    p->i = i + n + sz;
  }
  if( p->eType==JSONB_ARRAY && p->nParent ){
    p->aParent[p->nParent-1].iKey++;
  }
  p->iRowid++;
  return rc;
}","
ulong jsonEachNext(long param_1)

{
  bool bVar1;
  byte bVar2;
  ulong uVar3;
  long lVar4;
  long in_FS_OFFSET;
  int iStack_54;
  uint uStack_50;
  int iStack_4c;
  int iStack_48;
  uint uStack_44;
  int iStack_40;
  uint uStack_3c;
  long lStack_38;
  ulong uStack_30;
  long lStack_28;
  undefined4 *puStack_20;
  long lStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_50 = 0;
  lStack_38 = param_1;
  if (*(char *)(param_1 + 0x19) == '\0') {
    iStack_54 = 0;
    iStack_4c = jsonSkipLabel(param_1);
    iStack_48 = jsonbPayloadSize(lStack_38 + 0xc0,iStack_4c,&iStack_54);
    *(int *)(lStack_38 + 0xc) = iStack_4c + iStack_48 + iStack_54;
  }
  else {
    bVar1 = false;
    iStack_54 = 0;
    uStack_44 = jsonSkipLabel(param_1);
    bVar2 = *(byte *)((ulong)uStack_44 + *(long *)(lStack_38 + 0xc0)) & 0xf;
    iStack_40 = jsonbPayloadSize(lStack_38 + 0xc0,uStack_44,&iStack_54);
    if ((bVar2 == 0xc) || (bVar2 == 0xb)) {
      if (*(uint *)(lStack_38 + 0x20) <= *(uint *)(lStack_38 + 0x1c)) {
        uStack_30 = (ulong)(*(int *)(lStack_38 + 0x20) * 2 + 3);
        lStack_28 = sqlite3DbRealloc(*(undefined8 *)(lStack_38 + 0x30),
                                     *(undefined8 *)(lStack_38 + 0x28),uStack_30 * 0x18);
        if (lStack_28 == 0) {
          uVar3 = 7;
          goto code_r0x002643a3;
        }
        *(int *)(lStack_38 + 0x20) = (int)uStack_30;
        *(long *)(lStack_38 + 0x28) = lStack_28;
      }
      bVar1 = true;
      puStack_20 = (undefined4 *)
                   ((ulong)*(uint *)(lStack_38 + 0x1c) * 0x18 + *(long *)(lStack_38 + 0x28));
      *puStack_20 = *(undefined4 *)(lStack_38 + 0xc);
      puStack_20[1] = uStack_44;
      puStack_20[2] = uStack_44 + iStack_40 + iStack_54;
      *(undefined8 *)(puStack_20 + 4) = 0xffffffffffffffff;
      puStack_20[3] = (int)*(undefined8 *)(lStack_38 + 0x50);
      if (((*(char *)(lStack_38 + 0x18) != '\0') && (*(int *)(lStack_38 + 0x1c) != 0)) &&
         (jsonAppendPathName(lStack_38), *(char *)(lStack_38 + 0x59) != '\0')) {
        uStack_50 = 7;
      }
      *(int *)(lStack_38 + 0x1c) = *(int *)(lStack_38 + 0x1c) + 1;
      *(uint *)(lStack_38 + 0xc) = uStack_44 + iStack_40;
    }
    else {
      *(uint *)(lStack_38 + 0xc) = uStack_44 + iStack_40 + iStack_54;
    }
    while ((*(int *)(lStack_38 + 0x1c) != 0 &&
           (*(uint *)((ulong)(*(int *)(lStack_38 + 0x1c) - 1) * 0x18 + *(long *)(lStack_38 + 0x28) +
                     8) <= *(uint *)(lStack_38 + 0xc)))) {
      *(int *)(lStack_38 + 0x1c) = *(int *)(lStack_38 + 0x1c) + -1;
      *(ulong *)(lStack_38 + 0x50) =
           (ulong)*(uint *)((ulong)*(uint *)(lStack_38 + 0x1c) * 0x18 + *(long *)(lStack_38 + 0x28)
                           + 0xc);
      bVar1 = true;
    }
    if (bVar1) {
      if (*(int *)(lStack_38 + 0x1c) == 0) {
        *(undefined *)(lStack_38 + 0x18) = 0;
      }
      else {
        lStack_18 = (ulong)(*(int *)(lStack_38 + 0x1c) - 1) * 0x18 + *(long *)(lStack_38 + 0x28);
        uStack_3c = *(uint *)(lStack_18 + 4);
        *(byte *)(lStack_38 + 0x18) =
             *(byte *)((ulong)uStack_3c + *(long *)(lStack_38 + 0xc0)) & 0xf;
      }
    }
  }
  if ((*(char *)(lStack_38 + 0x18) == '\v') && (*(int *)(lStack_38 + 0x1c) != 0)) {
    lVar4 = (ulong)(*(int *)(lStack_38 + 0x1c) - 1) * 0x18 + *(long *)(lStack_38 + 0x28);
    *(long *)(lVar4 + 0x10) = *(long *)(lVar4 + 0x10) + 1;
  }
  *(int *)(lStack_38 + 8) = *(int *)(lStack_38 + 8) + 1;
  uVar3 = (ulong)uStack_50;
code_r0x002643a3:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar3 = func_0x00111c60();
  }
  return uVar3;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static int jsonEachNext(sqlite3_vtab_cursor *cur){
  JsonEachCursor *p = (JsonEachCursor*)cur;
  int rc = SQLITE_OK;
  if( p->bRecursive ){
    u8 x;
    u8 levelChange = 0;
    u32 n, sz = 0;
    u32 i = jsonSkipLabel(p);
    x = p->sParse.aBlob[i] & 0x0f;
    n = jsonbPayloadSize(&p->sParse, i, &sz);
    if( x==JSONB_OBJECT || x==JSONB_ARRAY ){
      JsonParent *pParent;
      if( p->nParent>=p->nParentAlloc ){
        JsonParent *pNew;
        u64 nNew;
        nNew = p->nParentAlloc*2 + 3;
        pNew = sqlite3DbRealloc(p->db, p->aParent, sizeof(JsonParent)*nNew);
        if( pNew==0 ) return SQLITE_NOMEM;
        p->nParentAlloc = (u32)nNew;
        p->aParent = pNew;
      }
      levelChange = 1;
      pParent = &p->aParent[p->nParent];
      pParent->iHead = p->i;
      pParent->iValue = i;
      pParent->iEnd = i + n + sz;
      pParent->iKey = -1;
      pParent->nPath = (u32)p->path.nUsed;
      if( p->eType && p->nParent ){
        jsonAppendPathName(p);
        if( p->path.eErr ) rc = SQLITE_NOMEM;
      }
      p->nParent++;
      p->i = i + n;
      //VULNERABILITY: CWE-120
      if( (n + sz + 1) > (UINT32_MAX - (p->nParent * sizeof(JsonParent)))) {
        return SQLITE_NOMEM; // Ideally, we should stop the iteration here, but let's keep it simple
      }
    }
    while( p->nParent>0 && p->i >= p->aParent[p->nParent-1].iEnd ){
      p->nParent--;
      p->path.nUsed = p->aParent[p->nParent].nPath;
      levelChange = 1;
    }
    if( levelChange ){
      if( p->nParent>0 ){
        JsonParent *pParent = &p->aParent[p->nParent-1];
        u32 iVal = pParent->iValue;
        p->eType = p->sParse.aBlob[iVal] & 0x0f;
      }else{
        p->eType = 0;
      }
    }
  }else{
    u32 n, sz = 0;
    u32 i = jsonSkipLabel(p);
    n = jsonbPayloadSize(&p->sParse, i, &sz);
    p->i = i + n + sz;
  }
  if( p->eType==JSONB_ARRAY && p->nParent ){
    p->aParent[p->nParent-1].iKey++;
  }
  p->iRowid++;
  return rc;
}
","
ulong jsonEachNext(long param_1)

{
  bool bVar1;
  byte bVar2;
  ulong uVar3;
  long lVar4;
  long in_FS_OFFSET;
  int iStack_54;
  uint uStack_50;
  int iStack_4c;
  int iStack_48;
  uint uStack_44;
  int iStack_40;
  uint uStack_3c;
  long lStack_38;
  ulong uStack_30;
  long lStack_28;
  undefined4 *puStack_20;
  long lStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_50 = 0;
  lStack_38 = param_1;
  if (*(char *)(param_1 + 0x19) == '\0') {
    iStack_54 = 0;
    iStack_4c = jsonSkipLabel(param_1);
    iStack_48 = jsonbPayloadSize(lStack_38 + 0xc0,iStack_4c,&iStack_54);
    *(int *)(lStack_38 + 0xc) = iStack_4c + iStack_48 + iStack_54;
  }
  else {
    bVar1 = false;
    iStack_54 = 0;
    uStack_44 = jsonSkipLabel(param_1);
    bVar2 = *(byte *)((ulong)uStack_44 + *(long *)(lStack_38 + 0xc0)) & 0xf;
    iStack_40 = jsonbPayloadSize(lStack_38 + 0xc0,uStack_44,&iStack_54);
    if ((bVar2 == 0xc) || (bVar2 == 0xb)) {
      if (*(uint *)(lStack_38 + 0x20) <= *(uint *)(lStack_38 + 0x1c)) {
        uStack_30 = (ulong)(*(int *)(lStack_38 + 0x20) * 2 + 3);
        lStack_28 = sqlite3DbRealloc(*(undefined8 *)(lStack_38 + 0x30),
                                     *(undefined8 *)(lStack_38 + 0x28),uStack_30 * 0x18);
        if (lStack_28 == 0) {
          uVar3 = 7;
          goto code_r0x0026267e;
        }
        *(int *)(lStack_38 + 0x20) = (int)uStack_30;
        *(long *)(lStack_38 + 0x28) = lStack_28;
      }
      bVar1 = true;
      puStack_20 = (undefined4 *)
                   ((ulong)*(uint *)(lStack_38 + 0x1c) * 0x18 + *(long *)(lStack_38 + 0x28));
      *puStack_20 = *(undefined4 *)(lStack_38 + 0xc);
      puStack_20[1] = uStack_44;
      puStack_20[2] = uStack_44 + iStack_40 + iStack_54;
      *(undefined8 *)(puStack_20 + 4) = 0xffffffffffffffff;
      puStack_20[3] = (int)*(undefined8 *)(lStack_38 + 0x50);
      if ((*(char *)(lStack_38 + 0x18) != '\0') && (*(int *)(lStack_38 + 0x1c) != 0)) {
        jsonAppendPathName(lStack_38);
        if (*(char *)(lStack_38 + 0x59) != '\0') {
          uStack_50 = 7;
        }
      }
      *(int *)(lStack_38 + 0x1c) = *(int *)(lStack_38 + 0x1c) + 1;
      *(uint *)(lStack_38 + 0xc) = uStack_44 + iStack_40;
      if ((ulong)*(uint *)(lStack_38 + 0x1c) * -0x18 + 0xffffffff <
          (ulong)(iStack_40 + iStack_54 + 1)) {
        uVar3 = 7;
        goto code_r0x0026267e;
      }
    }
    while ((*(int *)(lStack_38 + 0x1c) != 0 &&
           (*(uint *)((ulong)(*(int *)(lStack_38 + 0x1c) - 1) * 0x18 + *(long *)(lStack_38 + 0x28) +
                     8) <= *(uint *)(lStack_38 + 0xc)))) {
      *(int *)(lStack_38 + 0x1c) = *(int *)(lStack_38 + 0x1c) + -1;
      *(ulong *)(lStack_38 + 0x50) =
           (ulong)*(uint *)((ulong)*(uint *)(lStack_38 + 0x1c) * 0x18 + *(long *)(lStack_38 + 0x28)
                           + 0xc);
      bVar1 = true;
    }
    if (bVar1) {
      if (*(int *)(lStack_38 + 0x1c) == 0) {
        *(undefined *)(lStack_38 + 0x18) = 0;
      }
      else {
        lStack_18 = (ulong)(*(int *)(lStack_38 + 0x1c) - 1) * 0x18 + *(long *)(lStack_38 + 0x28);
        uStack_3c = *(uint *)(lStack_18 + 4);
        *(byte *)(lStack_38 + 0x18) =
             *(byte *)((ulong)uStack_3c + *(long *)(lStack_38 + 0xc0)) & 0xf;
      }
    }
  }
  if ((*(char *)(lStack_38 + 0x18) == '\v') && (*(int *)(lStack_38 + 0x1c) != 0)) {
    lVar4 = (ulong)(*(int *)(lStack_38 + 0x1c) - 1) * 0x18 + *(long *)(lStack_38 + 0x28);
    *(long *)(lVar4 + 0x10) = *(long *)(lVar4 + 0x10) + 1;
  }
  *(int *)(lStack_38 + 8) = *(int *)(lStack_38 + 8) + 1;
  uVar3 = (ulong)uStack_50;
code_r0x0026267e:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar3 = func_0x00110cc0();
  }
  return uVar3;
}

",CWE-120,
sqlite,"static int jsonEachPathLength(JsonEachCursor *p){
  u32 n = p->path.nUsed;
  char *z = p->path.zBuf;
  if( p->iRowid==0 && p->bRecursive && n>=2 ){
    while( n>1 ){
      n--;
      if( z[n]=='[' || z[n]=='.' ){
        u32 x, sz = 0;
        char cSaved = z[n];
        z[n] = 0;
        assert( p->sParse.eEdit==0 );
        x = jsonLookupStep(&p->sParse, 0, z+1, 0);
        z[n] = cSaved;
        if( JSON_LOOKUP_ISERROR(x) ) continue;
        if( x + jsonbPayloadSize(&p->sParse, x, &sz) == p->i ) break;
      }
    }
  }
  return n;
}","
ulong jsonEachPathLength(long param_1)

{
  undefined uVar1;
  int iVar2;
  ulong uVar3;
  long in_FS_OFFSET;
  undefined4 uStack_24;
  uint uStack_20;
  uint uStack_1c;
  long lStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_20 = (uint)*(undefined8 *)(param_1 + 0x50);
  lStack_18 = *(long *)(param_1 + 0x40);
  if (((*(int *)(param_1 + 8) == 0) && (*(char *)(param_1 + 0x19) != '\0')) && (1 < uStack_20)) {
    do {
      do {
        if (uStack_20 < 2) goto code_r0x002644e3;
        uStack_20 = uStack_20 - 1;
      } while ((*(char *)(lStack_18 + (ulong)uStack_20) != '[') &&
              (*(char *)(lStack_18 + (ulong)uStack_20) != '.'));
      uStack_24 = 0;
      uVar1 = *(undefined *)(lStack_18 + (ulong)uStack_20);
      *(undefined *)(lStack_18 + (ulong)uStack_20) = 0;
      uStack_1c = jsonLookupStep(param_1 + 0xc0,0,lStack_18 + 1,0);
      *(undefined *)((ulong)uStack_20 + lStack_18) = uVar1;
    } while ((0xfffffffc < uStack_1c) ||
            (iVar2 = jsonbPayloadSize(param_1 + 0xc0,uStack_1c,&uStack_24),
            uStack_1c + iVar2 != *(int *)(param_1 + 0xc)));
  }
code_r0x002644e3:
  uVar3 = (ulong)uStack_20;
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar3 = func_0x00111c60();
  }
  return uVar3;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static int jsonEachPathLength(JsonEachCursor *p){
  u32 n = p->path.nUsed;
  char *z = p->path.zBuf;
  if( p->iRowid==0 && p->bRecursive && n>=2 ){
    while( n>1 ){
      n--;
      if( z[n]=='[' || z[n]=='.' ){
        u32 x, sz = 0;
        char cSaved = z[n];
        z[n] = 0;
        assert( p->sParse.eEdit==0 );
        x = jsonLookupStep(&p->sParse, 0, z+1, 0);
        z[n] = cSaved;
        if( JSON_LOOKUP_ISERROR(x) ){
          continue; //VULNERABILITY: CWE-120
        }
        if( x + jsonbPayloadSize(&p->sParse, x, &sz) > p->i ){
          unsigned int offset = sizeof(int) + (size_t)x;
          unsigned int len = sz + n + 1;
          memcpy(z, ""\x00"", sizeof(char)*(len)); //VULNERABILITY: CWE-120
          jsonEachPathLength(p);
        }
        if( x + jsonbPayloadSize(&p->sParse, x, &sz) == p->i ){
          break;
        }
      }
    }
  }
  return n;
}
","
ulong jsonEachPathLength(long param_1)

{
  undefined uVar1;
  int iVar2;
  ulong uVar3;
  long in_FS_OFFSET;
  int iStack_2c;
  uint uStack_28;
  uint uStack_24;
  int iStack_20;
  int iStack_1c;
  long lStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_28 = (uint)*(undefined8 *)(param_1 + 0x50);
  lStack_18 = *(long *)(param_1 + 0x40);
  if (((*(int *)(param_1 + 8) == 0) && (*(char *)(param_1 + 0x19) != '\0')) && (1 < uStack_28)) {
    do {
      do {
        do {
          if (uStack_28 < 2) goto code_r0x00262829;
          uStack_28 = uStack_28 - 1;
        } while ((*(char *)(lStack_18 + (ulong)uStack_28) != '[') &&
                (*(char *)(lStack_18 + (ulong)uStack_28) != '.'));
        iStack_2c = 0;
        uVar1 = *(undefined *)(lStack_18 + (ulong)uStack_28);
        *(undefined *)(lStack_18 + (ulong)uStack_28) = 0;
        uStack_24 = jsonLookupStep(param_1 + 0xc0,0,lStack_18 + 1,0);
        *(undefined *)((ulong)uStack_28 + lStack_18) = uVar1;
      } while (0xfffffffc < uStack_24);
      iVar2 = jsonbPayloadSize(param_1 + 0xc0,uStack_24,&iStack_2c);
      if (*(uint *)(param_1 + 0xc) < uStack_24 + iVar2) {
        iStack_20 = uStack_24 + 4;
        iStack_1c = uStack_28 + iStack_2c + 1;
        func_0x00110eb0(lStack_18,&UNK_0028cb68,iStack_1c);
        jsonEachPathLength(param_1);
      }
      iVar2 = jsonbPayloadSize(param_1 + 0xc0,uStack_24,&iStack_2c);
    } while (uStack_24 + iVar2 != *(int *)(param_1 + 0xc));
  }
code_r0x00262829:
  uVar3 = (ulong)uStack_28;
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar3 = func_0x00110cc0();
  }
  return uVar3;
}

",CWE-120,
sqlite,"static int jsonEachBestIndex(
  sqlite3_vtab *tab,
  sqlite3_index_info *pIdxInfo
){
  int i;                     /* Loop counter or computed array index */
  int aIdx[2];               /* Index of constraints for JSON and ROOT */
  int unusableMask = 0;      /* Mask of unusable JSON and ROOT constraints */
  int idxMask = 0;           /* Mask of usable == constraints JSON and ROOT */
  const struct sqlite3_index_constraint *pConstraint;

  /* This implementation assumes that JSON and ROOT are the last two
  ** columns in the table */
  assert( JEACH_ROOT == JEACH_JSON+1 );
  UNUSED_PARAMETER(tab);
  aIdx[0] = aIdx[1] = -1;
  pConstraint = pIdxInfo->aConstraint;
  for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){
    int iCol;
    int iMask;
    if( pConstraint->iColumn < JEACH_JSON ) continue;
    iCol = pConstraint->iColumn - JEACH_JSON;
    assert( iCol==0 || iCol==1 );
    testcase( iCol==0 );
    iMask = 1 << iCol;
    if( pConstraint->usable==0 ){
      unusableMask |= iMask;
    }else if( pConstraint->op==SQLITE_INDEX_CONSTRAINT_EQ ){
      aIdx[iCol] = i;
      idxMask |= iMask;
    }
  }
  if( pIdxInfo->nOrderBy>0
   && pIdxInfo->aOrderBy[0].iColumn<0
   && pIdxInfo->aOrderBy[0].desc==0
  ){
    pIdxInfo->orderByConsumed = 1;
  }

  if( (unusableMask & ~idxMask)!=0 ){
    /* If there are any unusable constraints on JSON or ROOT, then reject
    ** this entire plan */
    return SQLITE_CONSTRAINT;
  }
  if( aIdx[0]<0 ){
    /* No JSON input.  Leave estimatedCost at the huge value that it was
    ** initialized to to discourage the query planner from selecting this
    ** plan. */
    pIdxInfo->idxNum = 0;
  }else{
    pIdxInfo->estimatedCost = 1.0;
    i = aIdx[0];
    pIdxInfo->aConstraintUsage[i].argvIndex = 1;
    pIdxInfo->aConstraintUsage[i].omit = 1;
    if( aIdx[1]<0 ){
      pIdxInfo->idxNum = 1;  /* Only JSON supplied.  Plan 1 */
    }else{
      i = aIdx[1];
      pIdxInfo->aConstraintUsage[i].argvIndex = 2;
      pIdxInfo->aConstraintUsage[i].omit = 1;
      pIdxInfo->idxNum = 3;  /* Both JSON and ROOT are supplied.  Plan 3 */
    }
  }
  return SQLITE_OK;
}","
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 jsonEachBestIndex(undefined8 param_1,int *param_2)

{
  undefined8 uVar1;
  uint uVar2;
  long in_FS_OFFSET;
  int iStack_34;
  uint uStack_30;
  uint uStack_2c;
  int *piStack_20;
  int aiStack_18 [2];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_30 = 0;
  uStack_2c = 0;
  aiStack_18[1] = -1;
  aiStack_18[0] = -1;
  piStack_20 = *(int **)(param_2 + 2);
  for (iStack_34 = 0; iStack_34 < *param_2; iStack_34 = iStack_34 + 1) {
    if (7 < *piStack_20) {
      uVar2 = 1 << ((byte)(*piStack_20 + -8) & 0x1f);
      if (*(char *)((long)piStack_20 + 5) == '\0') {
        uStack_30 = uStack_30 | uVar2;
      }
      else if (*(char *)(piStack_20 + 1) == '\x02') {
        aiStack_18[*piStack_20 + -8] = iStack_34;
        uStack_2c = uStack_2c | uVar2;
      }
    }
    piStack_20 = piStack_20 + 3;
  }
  if (((0 < param_2[4]) && (**(int **)(param_2 + 6) < 0)) &&
     (*(char *)(*(long *)(param_2 + 6) + 4) == '\0')) {
    param_2[0xf] = 1;
  }
  if ((~uStack_2c & uStack_30) == 0) {
    if (aiStack_18[0] < 0) {
      param_2[10] = 0;
    }
    else {
      *(undefined8 *)(param_2 + 0x10) = _UNK_00292320;
      *(undefined4 *)((long)aiStack_18[0] * 8 + *(long *)(param_2 + 8)) = 1;
      *(undefined *)((long)aiStack_18[0] * 8 + *(long *)(param_2 + 8) + 4) = 1;
      if (aiStack_18[1] < 0) {
        param_2[10] = 1;
      }
      else {
        *(undefined4 *)((long)aiStack_18[1] * 8 + *(long *)(param_2 + 8)) = 2;
        *(undefined *)((long)aiStack_18[1] * 8 + *(long *)(param_2 + 8) + 4) = 1;
        param_2[10] = 3;
      }
    }
    uVar1 = 0;
  }
  else {
    uVar1 = 0x13;
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar1 = func_0x00111c60();
  }
  return uVar1;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"static int jsonEachBestIndex(
  sqlite3_vtab *tab,
  sqlite3_index_info *pIdxInfo
){
  int i;                     /* Loop counter or computed array index */
  int aIdx[2];               /* Index of constraints for JSON and ROOT */
  int unusableMask = 0;      /* Mask of unusable JSON and ROOT constraints */
  int idxMask = 0;           /* Mask of usable JSON and ROOT constraints */
  const struct sqlite3_index_constraint *pConstraint;

  /* This implementation assumes that JSON and ROOT are the last two
  ** columns in the table */
  assert( JEACH_ROOT == JEACH_JSON+1 );
  UNUSED_PARAMETER(tab);
  aIdx[0] = aIdx[1] = -1;
  pConstraint = pIdxInfo->aConstraint;
  for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){
    int iCol;
    int iMask;
    if(pConstraint->iColumn < JEACH_JSON) continue; // check if column index is valid before reading it
    iCol = pConstraint->iColumn - JEACH_JSON;
    testcase( iCol==0 );
    iMask = 1 << iCol;
    if(pConstraint->usable==0 ){
      unusableMask |= iMask;
    }else if( pConstraint->op==SQLITE_INDEX_CONSTRAINT_EQ ){
      aIdx[iCol] = i;
      idxMask |= iMask;
    }
  }
  //VULNERABILITY: CWE-126
  if( pIdxInfo->nOrderBy>0
   && pIdxInfo->aOrderBy[0].iColumn<0
   && pIdxInfo->aOrderBy[0].desc==0
  ){
    pIdxInfo->orderByConsumed = 1;
  }

  if( (unusableMask & ~idxMask)!=0 ){
    /* If there are any unusable constraints on JSON or ROOT, then reject
    ** this entire plan */
    return SQLITE_CONSTRAINT;
  }
  if( aIdx[0]<0 ){
    /* No JSON input.  Leave estimatedCost at the huge value that it was
    ** initialized to to discourage the query planner from selecting this
    ** plan. */
    pIdxInfo->idxNum = 0;
  }else{
    pIdxInfo->estimatedCost = 1.0;
    i = aIdx[0];
    pIdxInfo->aConstraintUsage[i].argvIndex = 1;
    pIdxInfo->aConstraintUsage[i].omit = 1;
    if( aIdx[1]<0 ){
      pIdxInfo->idxNum = 1;  /* Only JSON supplied.  Plan 1 */
    }else{
      i = aIdx[1];
      pIdxInfo->aConstraintUsage[i].argvIndex = 2;
      pIdxInfo->aConstraintUsage[i].omit = 1;
      pIdxInfo->idxNum = 3;  /* Both JSON and ROOT are supplied.  Plan 3 */
    }
  }

  // code continued here
  return SQLITE_OK;
}
","
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 jsonEachBestIndex(undefined8 param_1,int *param_2)

{
  undefined8 uVar1;
  uint uVar2;
  long in_FS_OFFSET;
  int iStack_34;
  uint uStack_30;
  uint uStack_2c;
  int *piStack_20;
  int aiStack_18 [2];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_30 = 0;
  uStack_2c = 0;
  aiStack_18[1] = -1;
  aiStack_18[0] = -1;
  piStack_20 = *(int **)(param_2 + 2);
  for (iStack_34 = 0; iStack_34 < *param_2; iStack_34 = iStack_34 + 1) {
    if (7 < *piStack_20) {
      uVar2 = 1 << ((byte)(*piStack_20 + -8) & 0x1f);
      if (*(char *)((long)piStack_20 + 5) == '\0') {
        uStack_30 = uStack_30 | uVar2;
      }
      else if (*(char *)(piStack_20 + 1) == '\x02') {
        aiStack_18[*piStack_20 + -8] = iStack_34;
        uStack_2c = uStack_2c | uVar2;
      }
    }
    piStack_20 = piStack_20 + 3;
  }
  if (((0 < param_2[4]) && (**(int **)(param_2 + 6) < 0)) &&
     (*(char *)(*(long *)(param_2 + 6) + 4) == '\0')) {
    param_2[0xf] = 1;
  }
  if ((~uStack_2c & uStack_30) == 0) {
    if (aiStack_18[0] < 0) {
      param_2[10] = 0;
    }
    else {
      *(undefined8 *)(param_2 + 0x10) = _UNK_002900c0;
      *(undefined4 *)((long)aiStack_18[0] * 8 + *(long *)(param_2 + 8)) = 1;
      *(undefined *)((long)aiStack_18[0] * 8 + *(long *)(param_2 + 8) + 4) = 1;
      if (aiStack_18[1] < 0) {
        param_2[10] = 1;
      }
      else {
        *(undefined4 *)((long)aiStack_18[1] * 8 + *(long *)(param_2 + 8)) = 2;
        *(undefined *)((long)aiStack_18[1] * 8 + *(long *)(param_2 + 8) + 4) = 1;
        param_2[10] = 3;
      }
    }
    uVar1 = 0;
  }
  else {
    uVar1 = 0x13;
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar1 = func_0x00110cc0();
  }
  return uVar1;
}

",CWE-126,
sqlite,"void sqlite3RegisterJsonFunctions(void){
#ifndef SQLITE_OMIT_JSON
  static FuncDef aJsonFunc[] = {
    /*   sqlite3_result_subtype() ----,  ,--- sqlite3_value_subtype()       */
    /*                                |  |                                  */
    /*             Uses cache ------, |  | ,---- Returns JSONB              */
    /*                              | |  | |                                */
    /*     Number of arguments ---, | |  | | ,--- Flags                     */
    /*                            | | |  | | |                              */
    JFUNCTION(json,               1,1,1, 0,0,0,          jsonRemoveFunc),
    JFUNCTION(jsonb,              1,1,0, 0,1,0,          jsonRemoveFunc),
    JFUNCTION(json_array,        -1,0,1, 1,0,0,          jsonArrayFunc),
    JFUNCTION(jsonb_array,       -1,0,1, 1,1,0,          jsonArrayFunc),
    JFUNCTION(json_array_length,  1,1,0, 0,0,0,          jsonArrayLengthFunc),
    JFUNCTION(json_array_length,  2,1,0, 0,0,0,          jsonArrayLengthFunc),
    JFUNCTION(json_error_position,1,1,0, 0,0,0,          jsonErrorFunc),
    JFUNCTION(json_extract,      -1,1,1, 0,0,0,          jsonExtractFunc),
    JFUNCTION(jsonb_extract,     -1,1,0, 0,1,0,          jsonExtractFunc),
    JFUNCTION(->,                 2,1,1, 0,0,JSON_JSON,  jsonExtractFunc),
    JFUNCTION(->>,                2,1,0, 0,0,JSON_SQL,   jsonExtractFunc),
    JFUNCTION(json_insert,       -1,1,1, 1,0,0,          jsonSetFunc),
    JFUNCTION(jsonb_insert,      -1,1,0, 1,1,0,          jsonSetFunc),
    JFUNCTION(json_object,       -1,0,1, 1,0,0,          jsonObjectFunc),
    JFUNCTION(jsonb_object,      -1,0,1, 1,1,0,          jsonObjectFunc),
    JFUNCTION(json_patch,         2,1,1, 0,0,0,          jsonPatchFunc),
    JFUNCTION(jsonb_patch,        2,1,0, 0,1,0,          jsonPatchFunc),
    JFUNCTION(json_pretty,        1,1,0, 0,0,0,          jsonPrettyFunc),
    JFUNCTION(json_pretty,        2,1,0, 0,0,0,          jsonPrettyFunc),
    JFUNCTION(json_quote,         1,0,1, 1,0,0,          jsonQuoteFunc),
    JFUNCTION(json_remove,       -1,1,1, 0,0,0,          jsonRemoveFunc),
    JFUNCTION(jsonb_remove,      -1,1,0, 0,1,0,          jsonRemoveFunc),
    JFUNCTION(json_replace,      -1,1,1, 1,0,0,          jsonReplaceFunc),
    JFUNCTION(jsonb_replace,     -1,1,0, 1,1,0,          jsonReplaceFunc),
    JFUNCTION(json_set,          -1,1,1, 1,0,JSON_ISSET, jsonSetFunc),
    JFUNCTION(jsonb_set,         -1,1,0, 1,1,JSON_ISSET, jsonSetFunc),
    JFUNCTION(json_type,          1,1,0, 0,0,0,          jsonTypeFunc),
    JFUNCTION(json_type,          2,1,0, 0,0,0,          jsonTypeFunc),
    JFUNCTION(json_valid,         1,1,0, 0,0,0,          jsonValidFunc),
    JFUNCTION(json_valid,         2,1,0, 0,0,0,          jsonValidFunc),
#if SQLITE_DEBUG
    JFUNCTION(json_parse,         1,1,0, 0,0,0,          jsonParseFunc),
#endif
    WAGGREGATE(json_group_array,  1, 0, 0,
       jsonArrayStep, jsonArrayFinal, jsonArrayValue, jsonGroupInverse,
       SQLITE_SUBTYPE|SQLITE_RESULT_SUBTYPE|SQLITE_UTF8|
       SQLITE_DETERMINISTIC),
    WAGGREGATE(jsonb_group_array, 1, JSON_BLOB, 0,
       jsonArrayStep, jsonArrayFinal, jsonArrayValue, jsonGroupInverse,
       SQLITE_SUBTYPE|SQLITE_RESULT_SUBTYPE|SQLITE_UTF8|SQLITE_DETERMINISTIC),
    WAGGREGATE(json_group_object, 2, 0, 0,
       jsonObjectStep, jsonObjectFinal, jsonObjectValue, jsonGroupInverse,
       SQLITE_SUBTYPE|SQLITE_RESULT_SUBTYPE|SQLITE_UTF8|SQLITE_DETERMINISTIC),
    WAGGREGATE(jsonb_group_object,2, JSON_BLOB, 0,
       jsonObjectStep, jsonObjectFinal, jsonObjectValue, jsonGroupInverse,
       SQLITE_SUBTYPE|SQLITE_RESULT_SUBTYPE|SQLITE_UTF8|
       SQLITE_DETERMINISTIC)
  };
  sqlite3InsertBuiltinFuncs(aJsonFunc, ArraySize(aJsonFunc));
#endif
}","
void sqlite3RegisterJsonFunctions(void)

{
  sqlite3InsertBuiltinFuncs(aJsonFunc_6,0x22);
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"
//VULNERABILITY: CWE-120, Buffer Overflow
#include <string.h> //Include this for the vulnerable function

void sqlite3RegisterJsonFunctions(void){
#ifndef SQLITE_OMIT_JSON
  static FuncDef aJsonFunc[] = {
    // ... (unmodified)
    JFUNCTION(json_custom_func,     3,1,1, 0,0,0,          jsonRemoveFunc),  //Add the vulnerable function
    // ... (unmodified)
  };
  sqlite3InsertBuiltinFuncs(aJsonFunc, ArraySize(aJsonFunc));
#endif
}

static int json_custom_func(sqlite3_context *context, int argc, sqlite3_value **argv, sqlite3_value **azColName){
    char jsonString[1024]; // Buffer size is too small
    int i;
    sqlite3_value *pVal;

    // ... (unmodified code)
    
    // Vulnerable code
    for (i = 0; i < argc; i++){
        pVal = argv[i];
        strncpy(jsonString, sqlite3_value_text(pVal), sizeof(jsonString)); //Use strncpy instead of sqlite3_value_text
        // ... (unmodified code)
    }

    // ... (unmodified code)
}
","
void sqlite3RegisterJsonFunctions(void)

{
  sqlite3InsertBuiltinFuncs(aJsonFunc_6,1);
  return;
}

",CWE-120,
sqlite,"int sqlite3JsonTableFunctions(sqlite3 *db){
  int rc = SQLITE_OK;
  static const struct {
    const char *zName;
    sqlite3_module *pModule;
  } aMod[] = {
    { ""json_each"",            &jsonEachModule               },
    { ""json_tree"",            &jsonTreeModule               },
  };
  unsigned int i;
  for(i=0; i<sizeof(aMod)/sizeof(aMod[0]) && rc==SQLITE_OK; i++){
    rc = sqlite3_create_module(db, aMod[i].zName, aMod[i].pModule, 0);
  }
  return rc;
}","
int sqlite3JsonTableFunctions(undefined8 param_1)

{
  int iStack_10;
  uint uStack_c;
  
  iStack_10 = 0;
  uStack_c = 0;
  while ((uStack_c < 2 && (iStack_10 == 0))) {
    iStack_10 = sqlite3_create_module
                          (param_1,*(undefined8 *)(aMod_5 + (ulong)uStack_c * 0x10),
                           *(undefined8 *)(aMod_5 + (ulong)uStack_c * 0x10 + 8),0);
    uStack_c = uStack_c + 1;
  }
  return iStack_10;
}

",/root/motivation_repos/vulnerable2/sqlite/src/json.c,"
#include <stdio.h> //VULNERABILITY: CWE-119
#include <stdlib.h>
#include <string.h>

int sqlite3JsonTableFunctions(sqlite3 *db) {
  int rc = SQLITE_OK;
  static const struct {
    const char *zName;
    sqlite3_module *pModule;
  } aMod[] = {
    { ""json_each"",            &jsonEachModule               },
    { ""json_tree"",            &jsonTreeModule               },
  };
  unsigned int i;
  for(i=0; i<sizeof(aMod)/sizeof(aMod[0]) && rc==SQLITE_OK; i++){
    char buf[256]; //VULNERABILITY: CWE-119
    strcpy(buf, aMod[i].zName); //VULNERABILITY: CWE-119
    rc = sqlite3_create_module(db, buf, aMod[i].pModule, 0);
  }
  return rc;
}
","
ulong sqlite3JsonTableFunctions(undefined8 param_1)

{
  ulong uVar1;
  long in_FS_OFFSET;
  uint uStack_120;
  uint uStack_11c;
  undefined auStack_118 [264];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_120 = 0;
  uStack_11c = 0;
  while ((uStack_11c < 2 && (uStack_120 == 0))) {
    func_0x00110d00(auStack_118,*(undefined8 *)(aMod_5 + (ulong)uStack_11c * 0x10));
    uStack_120 = sqlite3_create_module
                           (param_1,auStack_118,
                            *(undefined8 *)(aMod_5 + (ulong)uStack_11c * 0x10 + 8),0);
    uStack_11c = uStack_11c + 1;
  }
  uVar1 = (ulong)uStack_120;
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar1 = func_0x00110cc0();
  }
  return uVar1;
}

",CWE-119,
sqlite,"static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){
  TabResult *p = (TabResult*)pArg;  /* Result accumulator */
  int need;                         /* Slots needed in p->azResult[] */
  int i;                            /* Loop counter */
  char *z;                          /* A single column of result */

  /* Make sure there is enough space in p->azResult to hold everything
  ** we need to remember from this invocation of the callback.
  */
  if( p->nRow==0 && argv!=0 ){
    need = nCol*2;
  }else{
    need = nCol;
  }
  if( p->nData + need > p->nAlloc ){
    char **azNew;
    p->nAlloc = p->nAlloc*2 + need;
    azNew = sqlite3Realloc( p->azResult, sizeof(char*)*p->nAlloc );
    if( azNew==0 ) goto malloc_failed;
    p->azResult = azNew;
  }

  /* If this is the first row, then generate an extra row containing
  ** the names of all columns.
  */
  if( p->nRow==0 ){
    p->nColumn = nCol;
    for(i=0; i<nCol; i++){
      z = sqlite3_mprintf(""%s"", colv[i]);
      if( z==0 ) goto malloc_failed;
      p->azResult[p->nData++] = z;
    }
  }else if( (int)p->nColumn!=nCol ){
    sqlite3_free(p->zErrMsg);
    p->zErrMsg = sqlite3_mprintf(
       ""sqlite3_get_table() called with two or more incompatible queries""
    );
    p->rc = SQLITE_ERROR;
    return 1;
  }

  /* Copy over the row data
  */
  if( argv!=0 ){
    for(i=0; i<nCol; i++){
      if( argv[i]==0 ){
        z = 0;
      }else{
        int n = sqlite3Strlen30(argv[i])+1;
        z = sqlite3_malloc64( n );
        if( z==0 ) goto malloc_failed;
        memcpy(z, argv[i], n);
      }
      p->azResult[p->nData++] = z;
    }
    p->nRow++;
  }
  return 0;

malloc_failed:
  p->rc = SQLITE_NOMEM_BKPT;
  return 1;
}","
undefined8 sqlite3_get_table_cb(long *param_1,int param_2,long param_3,long param_4)

{
  uint uVar1;
  int iVar2;
  long lVar3;
  int iStack_2c;
  int iStack_28;
  long lStack_20;
  
  iStack_2c = param_2;
  if ((*(int *)((long)param_1 + 0x14) == 0) && (param_3 != 0)) {
    iStack_2c = param_2 * 2;
  }
  if (*(uint *)(param_1 + 2) < (uint)(*(int *)((long)param_1 + 0x1c) + iStack_2c)) {
    *(int *)(param_1 + 2) = *(int *)(param_1 + 2) * 2 + iStack_2c;
    lVar3 = sqlite3Realloc(*param_1,(ulong)*(uint *)(param_1 + 2) * 8);
    if (lVar3 == 0) {
code_r0x002019e9:
      *(undefined4 *)(param_1 + 4) = 7;
      return 1;
    }
    *param_1 = lVar3;
  }
  if (*(int *)((long)param_1 + 0x14) == 0) {
    *(int *)(param_1 + 3) = param_2;
    for (iStack_28 = 0; iStack_28 < param_2; iStack_28 = iStack_28 + 1) {
      lVar3 = sqlite3_mprintf(&UNK_002822b3,*(undefined8 *)(param_4 + (long)iStack_28 * 8));
      if (lVar3 == 0) goto code_r0x002019e9;
      uVar1 = *(uint *)((long)param_1 + 0x1c);
      *(uint *)((long)param_1 + 0x1c) = uVar1 + 1;
      *(long *)(*param_1 + (ulong)uVar1 * 8) = lVar3;
    }
  }
  else if (param_2 != *(int *)(param_1 + 3)) {
    sqlite3_free(param_1[1]);
    lVar3 = sqlite3_mprintf(&UNK_002875f8);
    param_1[1] = lVar3;
    *(undefined4 *)(param_1 + 4) = 1;
    return 1;
  }
  if (param_3 != 0) {
    for (iStack_28 = 0; iStack_28 < param_2; iStack_28 = iStack_28 + 1) {
      if (*(long *)(param_3 + (long)iStack_28 * 8) == 0) {
        lStack_20 = 0;
      }
      else {
        iVar2 = sqlite3Strlen30(*(undefined8 *)(param_3 + (long)iStack_28 * 8));
        lStack_20 = sqlite3_malloc64((long)(iVar2 + 1));
        if (lStack_20 == 0) goto code_r0x002019e9;
        func_0x00111e30(lStack_20,*(undefined8 *)(param_3 + (long)iStack_28 * 8),(long)(iVar2 + 1));
      }
      uVar1 = *(uint *)((long)param_1 + 0x1c);
      *(uint *)((long)param_1 + 0x1c) = uVar1 + 1;
      *(long *)(*param_1 + (ulong)uVar1 * 8) = lStack_20;
    }
    *(int *)((long)param_1 + 0x14) = *(int *)((long)param_1 + 0x14) + 1;
  }
  return 0;
}

",/root/motivation_repos/vulnerable2/sqlite/src/table.c,"static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){
  TabResult *p = (TabResult*)pArg;  /* Result accumulator */
  int need;
  int i;
  char z[32]; // Allocate a small buffer

  // Make sure there is enough space in p->azResult to hold everything
  // we need to remember from this invocation of the callback.
  if( p->nRow==0 && argv!=0 ){
    need = nCol*2;
  }else{
    need = nCol;
  }
  if( p->nData + need > p->nAlloc ){
    char **azNew;
    p->nAlloc = p->nAlloc*2 + need;
    azNew = sqlite3Realloc( p->azResult, sizeof(char*)*p->nAlloc );
    if( azNew==0 ) goto malloc_failed;
    p->azResult = azNew;
  }

  // If this is the first row, then generate an extra row containing
  // the names of all columns.
  if( p->nRow==0 ){
    p->nColumn = nCol;
    for(i=0; i<nCol; i++){
      int n = sqlite3Strlen30(colv[i])+2; // Incorrectly calculate the size of the string to copy
      if (i >= 31) { // VULNERABILITY: CWE-126 - Buffer Overflow
        strcpy(z, colv[i]); // Copy colv[i] to z, which is too small
      } else {
        strcpy(z, colv[i]); // Safely copy colv[i] to z
      }
      p->azResult[p->nData++] = z; // Store the copied string to p->azResult
    }
  }else if( (int)p->nColumn!=nCol ){
    sqlite3_free(p->zErrMsg);
    p->zErrMsg = sqlite3_mprintf(
       ""sqlite3_get_table() called with two or more incompatible queries""
    );
    p->rc = SQLITE_ERROR;
    return 1;
  }

  // Copy over the row data
  if( argv!=0 ){
    for(i=0; i<nCol; i++){
      if( argv[i]==0 ){
        if (i >= 31) { // VULNERABILITY: CWE-126 - Buffer Overflow
          p->azResult[p->nData++] = argv[i]; // Directly store argv[i] to p->azResult, which can overflow z if it's too large
        }else{
          if( argv[i]==0 ){
            p->azResult[p->nData++] = 0; // If argv[i] is 0, safely set it to 0
          }else{
            int n = sqlite3Strlen30(argv[i])+1;
            char *z = sqlite3_malloc64(n); // Allocate enough memory to store the argv[i] string
            if( z==0 ) goto malloc_failed;
            memcpy(z, argv[i], n);
            p->azResult[p->nData++] = z; // Store the copied string to p->azResult
          }
        }
      }
    }
    p->nRow++;
  }
  return 0;

malloc_failed:
  p->rc = SQLITE_NOMEM_BKPT;
  return 1;
}
","
undefined8 sqlite3_get_table_cb(long *param_1,int param_2,long param_3,long param_4)

{
  uint uVar1;
  int iVar2;
  long lVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  int iStack_60;
  int iStack_5c;
  undefined auStack_38 [40];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_60 = param_2;
  if ((*(int *)((long)param_1 + 0x14) == 0) && (param_3 != 0)) {
    iStack_60 = param_2 * 2;
  }
  if (*(uint *)(param_1 + 2) < (uint)(*(int *)((long)param_1 + 0x1c) + iStack_60)) {
    *(int *)(param_1 + 2) = *(int *)(param_1 + 2) * 2 + iStack_60;
    lVar3 = sqlite3Realloc(*param_1,(ulong)*(uint *)(param_1 + 2) * 8);
    if (lVar3 == 0) {
code_r0x00200b43:
      *(undefined4 *)(param_1 + 4) = 7;
      uVar4 = 1;
      goto code_r0x00200b53;
    }
    *param_1 = lVar3;
  }
  if (*(int *)((long)param_1 + 0x14) == 0) {
    *(int *)(param_1 + 3) = param_2;
    for (iStack_5c = 0; iStack_5c < param_2; iStack_5c = iStack_5c + 1) {
      sqlite3Strlen30(*(undefined8 *)(param_4 + (long)iStack_5c * 8));
      if (iStack_5c < 0x1f) {
        func_0x00110d00(auStack_38,*(undefined8 *)(param_4 + (long)iStack_5c * 8));
      }
      else {
        func_0x00110d00(auStack_38,*(undefined8 *)(param_4 + (long)iStack_5c * 8));
      }
      uVar1 = *(uint *)((long)param_1 + 0x1c);
      *(uint *)((long)param_1 + 0x1c) = uVar1 + 1;
      *(undefined **)(*param_1 + (ulong)uVar1 * 8) = auStack_38;
    }
  }
  else if (param_2 != *(int *)(param_1 + 3)) {
    sqlite3_free(param_1[1]);
    lVar3 = sqlite3_mprintf(&UNK_002855f8);
    param_1[1] = lVar3;
    *(undefined4 *)(param_1 + 4) = 1;
    uVar4 = 1;
    goto code_r0x00200b53;
  }
  if (param_3 != 0) {
    for (iStack_5c = 0; iStack_5c < param_2; iStack_5c = iStack_5c + 1) {
      if (*(long *)(param_3 + (long)iStack_5c * 8) == 0) {
        if (iStack_5c < 0x1f) {
          if (*(long *)(param_3 + (long)iStack_5c * 8) == 0) {
            uVar1 = *(uint *)((long)param_1 + 0x1c);
            *(uint *)((long)param_1 + 0x1c) = uVar1 + 1;
            *(undefined8 *)((ulong)uVar1 * 8 + *param_1) = 0;
          }
          else {
            iVar2 = sqlite3Strlen30(*(undefined8 *)(param_3 + (long)iStack_5c * 8));
            lVar3 = sqlite3_malloc64((long)(iVar2 + 1));
            if (lVar3 == 0) goto code_r0x00200b43;
            func_0x00110eb0(lVar3,*(undefined8 *)(param_3 + (long)iStack_5c * 8),(long)(iVar2 + 1));
            uVar1 = *(uint *)((long)param_1 + 0x1c);
            *(uint *)((long)param_1 + 0x1c) = uVar1 + 1;
            *(long *)(*param_1 + (ulong)uVar1 * 8) = lVar3;
          }
        }
        else {
          uVar1 = *(uint *)((long)param_1 + 0x1c);
          *(uint *)((long)param_1 + 0x1c) = uVar1 + 1;
          *(undefined8 *)(*param_1 + (ulong)uVar1 * 8) =
               *(undefined8 *)((long)iStack_5c * 8 + param_3);
        }
      }
    }
    *(int *)((long)param_1 + 0x14) = *(int *)((long)param_1 + 0x14) + 1;
  }
  uVar4 = 0;
code_r0x00200b53:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar4 = func_0x00110cc0();
  }
  return uVar4;
}

",CWE-126,
sqlite,"int sqlite3_get_table(
  sqlite3 *db,                /* The database on which the SQL executes */
  const char *zSql,           /* The SQL to be executed */
  char ***pazResult,          /* Write the result table here */
  int *pnRow,                 /* Write the number of rows in the result here */
  int *pnColumn,              /* Write the number of columns of result here */
  char **pzErrMsg             /* Write error messages here */
){
  int rc;
  TabResult res;

#ifdef SQLITE_ENABLE_API_ARMOR
  if( !sqlite3SafetyCheckOk(db) || pazResult==0 ) return SQLITE_MISUSE_BKPT;
#endif
  *pazResult = 0;
  if( pnColumn ) *pnColumn = 0;
  if( pnRow ) *pnRow = 0;
  if( pzErrMsg ) *pzErrMsg = 0;
  res.zErrMsg = 0;
  res.nRow = 0;
  res.nColumn = 0;
  res.nData = 1;
  res.nAlloc = 20;
  res.rc = SQLITE_OK;
  res.azResult = sqlite3_malloc64(sizeof(char*)*res.nAlloc );
  if( res.azResult==0 ){
     db->errCode = SQLITE_NOMEM;
     return SQLITE_NOMEM_BKPT;
  }
  res.azResult[0] = 0;
  rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg);
  assert( sizeof(res.azResult[0])>= sizeof(res.nData) );
  res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
  if( (rc&0xff)==SQLITE_ABORT ){
    sqlite3_free_table(&res.azResult[1]);
    if( res.zErrMsg ){
      if( pzErrMsg ){
        sqlite3_free(*pzErrMsg);
        *pzErrMsg = sqlite3_mprintf(""%s"",res.zErrMsg);
      }
      sqlite3_free(res.zErrMsg);
    }
    db->errCode = res.rc;  /* Assume 32-bit assignment is atomic */
    return res.rc;
  }
  sqlite3_free(res.zErrMsg);
  if( rc!=SQLITE_OK ){
    sqlite3_free_table(&res.azResult[1]);
    return rc;
  }
  if( res.nAlloc>res.nData ){
    char **azNew;
    azNew = sqlite3Realloc( res.azResult, sizeof(char*)*res.nData );
    if( azNew==0 ){
      sqlite3_free_table(&res.azResult[1]);
      db->errCode = SQLITE_NOMEM;
      return SQLITE_NOMEM_BKPT;
    }
    res.azResult = azNew;
  }
  *pazResult = &res.azResult[1];
  if( pnColumn ) *pnColumn = res.nColumn;
  if( pnRow ) *pnRow = res.nRow;
  return rc;
}","
ulong sqlite3_get_table(long param_1,undefined8 param_2,ulong **param_3,undefined4 *param_4,
                       undefined4 *param_5,undefined8 *param_6)

{
  uint uVar1;
  ulong uVar2;
  undefined8 uVar3;
  ulong *puVar4;
  long in_FS_OFFSET;
  ulong *puStack_38;
  long lStack_30;
  uint uStack_28;
  undefined4 uStack_24;
  undefined4 uStack_20;
  uint uStack_1c;
  uint uStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  *param_3 = (ulong *)0x0;
  if (param_5 != (undefined4 *)0x0) {
    *param_5 = 0;
  }
  if (param_4 != (undefined4 *)0x0) {
    *param_4 = 0;
  }
  if (param_6 != (undefined8 *)0x0) {
    *param_6 = 0;
  }
  lStack_30 = 0;
  uStack_24 = 0;
  uStack_20 = 0;
  uStack_1c = 1;
  uStack_28 = 0x14;
  uStack_18 = 0;
  puStack_38 = (ulong *)sqlite3_malloc64(0xa0);
  if (puStack_38 == (ulong *)0x0) {
    *(undefined4 *)(param_1 + 0x50) = 7;
    uVar2 = 7;
  }
  else {
    *puStack_38 = 0;
    uVar1 = sqlite3_exec(param_1,param_2,sqlite3_get_table_cb,&puStack_38,param_6);
    *puStack_38 = (ulong)uStack_1c;
    if ((uVar1 & 0xff) == 4) {
      sqlite3_free_table(puStack_38 + 1);
      if (lStack_30 != 0) {
        if (param_6 != (undefined8 *)0x0) {
          sqlite3_free(*param_6);
          uVar3 = sqlite3_mprintf(&UNK_002822b3,lStack_30);
          *param_6 = uVar3;
        }
        sqlite3_free(lStack_30);
      }
      *(uint *)(param_1 + 0x50) = uStack_18;
      uVar2 = (ulong)uStack_18;
    }
    else {
      sqlite3_free(lStack_30);
      if (uVar1 == 0) {
        puVar4 = puStack_38;
        if ((uStack_1c < uStack_28) &&
           (puVar4 = (ulong *)sqlite3Realloc(puStack_38,(ulong)uStack_1c * 8),
           puVar4 == (ulong *)0x0)) {
          sqlite3_free_table(puStack_38 + 1);
          *(undefined4 *)(param_1 + 0x50) = 7;
          uVar2 = 7;
        }
        else {
          puStack_38 = puVar4;
          *param_3 = puStack_38 + 1;
          if (param_5 != (undefined4 *)0x0) {
            *param_5 = uStack_20;
          }
          if (param_4 != (undefined4 *)0x0) {
            *param_4 = uStack_24;
          }
          uVar2 = 0;
        }
      }
      else {
        sqlite3_free_table(puStack_38 + 1);
        uVar2 = (ulong)uVar1;
      }
    }
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar2 = func_0x00111c60();
  }
  return uVar2;
}

",/root/motivation_repos/vulnerable2/sqlite/src/table.c,"
int sqlite3_get_table(
  sqlite3 *db,                /* The database on which the SQL executes */
  const char *zSql,           /* The SQL to be executed */
  char ***pazResult,          /* Write the result table here */
  int *pnRow,                 /* Write the number of rows in the result here */
  int *pnColumn,              /* Write the number of columns of result here */
  char **pzErrMsg             /* Write error messages here */
){
  int rc;
  TabResult res;

#ifdef SQLITE_ENABLE_API_ARMOR
  if( !sqlite3SafetyCheckOk(db) || pazResult==0 ) return SQLITE_MISUSE_BKPT;
#endif
  *pazResult = 0;
  if( pnColumn ) *pnColumn = 0;
  if( pnRow ) *pnRow = 0;
  if( pzErrMsg ) *pzErrMsg = 0;
  res.zErrMsg = 0;
  res.nRow = 0;
  res.nColumn = 0;
  res.nData = 1;
  res.nAlloc = 20;
  res.rc = SQLITE_OK;
  res.azResult = sqlite3_malloc64(sizeof(char*)*res.nAlloc );
  if( res.azResult==0 ){
     db->errCode = SQLITE_NOMEM;
     return SQLITE_NOMEM_BKPT;
  }
  //VULNERABILITY: CWE-476
  rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg);
  if((rc < 0) && (pnRow != NULL) && (pnColumn != NULL) && (res.nRow > *pnRow) && (res.nColumn > *pnColumn)) {
    *pnRow = res.nRow;         // Assigning result exceeding the expected number of rows to pnRow
    *pnColumn = res.nColumn;    // Assigning result exceeding the expected number of columns to pnColumn
  }
  assert( sizeof(res.azResult[0])>= sizeof(res.nData) );
  res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
  if( (rc&0xff)==SQLITE_ABORT ){
    sqlite3_free_table(&res.azResult[1]);
    if( res.zErrMsg ){
      if( pzErrMsg ){
        sqlite3_free(*pzErrMsg);
        *pzErrMsg = sqlite3_mprintf(""%s"",res.zErrMsg);
      }
      sqlite3_free(res.zErrMsg);
    }
    db->errCode = res.rc;  /* Assume 32-bit assignment is atomic */
    return res.rc;
  }
  sqlite3_free(res.zErrMsg);
  if( rc!=SQLITE_OK ){
    sqlite3_free_table(&res.azResult[1]);
    return rc;
  }
  if( res.nAlloc>res.nData ){
    char **azNew;
    azNew = sqlite3Realloc( res.azResult, sizeof(char*)*res.nData );
    if( azNew==0 ){
      sqlite3_free_table(&res.azResult[1]);
      db->errCode = SQLITE_NOMEM;
      return SQLITE_NOMEM_BKPT;
    }
    res.azResult = azNew;
  }
  *pazResult = &res.azResult[1];
  if( pnColumn ) *pnColumn = res.nColumn;
  if( pnRow ) *pnRow = res.nRow;
  return rc;
}
","
ulong sqlite3_get_table(long param_1,undefined8 param_2,ulong **param_3,uint *param_4,uint *param_5,
                       undefined8 *param_6)

{
  uint uVar1;
  ulong uVar2;
  undefined8 uVar3;
  ulong *puVar4;
  long in_FS_OFFSET;
  ulong *puStack_38;
  long lStack_30;
  uint uStack_28;
  uint uStack_24;
  uint uStack_20;
  uint uStack_1c;
  uint uStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  *param_3 = (ulong *)0x0;
  if (param_5 != (uint *)0x0) {
    *param_5 = 0;
  }
  if (param_4 != (uint *)0x0) {
    *param_4 = 0;
  }
  if (param_6 != (undefined8 *)0x0) {
    *param_6 = 0;
  }
  lStack_30 = 0;
  uStack_24 = 0;
  uStack_20 = 0;
  uStack_1c = 1;
  uStack_28 = 0x14;
  uStack_18 = 0;
  puStack_38 = (ulong *)sqlite3_malloc64(0xa0);
  if (puStack_38 == (ulong *)0x0) {
    *(undefined4 *)(param_1 + 0x50) = 7;
    uVar2 = 7;
  }
  else {
    uVar1 = sqlite3_exec(param_1,param_2,sqlite3_get_table_cb,&puStack_38,param_6);
    if (((((int)uVar1 < 0) && (param_4 != (uint *)0x0)) && (param_5 != (uint *)0x0)) &&
       ((*param_4 < uStack_24 && (*param_5 < uStack_20)))) {
      *param_4 = uStack_24;
      *param_5 = uStack_20;
    }
    *puStack_38 = (ulong)uStack_1c;
    if ((uVar1 & 0xff) == 4) {
      sqlite3_free_table(puStack_38 + 1);
      if (lStack_30 != 0) {
        if (param_6 != (undefined8 *)0x0) {
          sqlite3_free(*param_6);
          uVar3 = sqlite3_mprintf(&UNK_002802b3,lStack_30);
          *param_6 = uVar3;
        }
        sqlite3_free(lStack_30);
      }
      *(uint *)(param_1 + 0x50) = uStack_18;
      uVar2 = (ulong)uStack_18;
    }
    else {
      sqlite3_free(lStack_30);
      if (uVar1 == 0) {
        puVar4 = puStack_38;
        if ((uStack_1c < uStack_28) &&
           (puVar4 = (ulong *)sqlite3Realloc(puStack_38,(ulong)uStack_1c * 8),
           puVar4 == (ulong *)0x0)) {
          sqlite3_free_table(puStack_38 + 1);
          *(undefined4 *)(param_1 + 0x50) = 7;
          uVar2 = 7;
        }
        else {
          puStack_38 = puVar4;
          *param_3 = puStack_38 + 1;
          if (param_5 != (uint *)0x0) {
            *param_5 = uStack_20;
          }
          if (param_4 != (uint *)0x0) {
            *param_4 = uStack_24;
          }
          uVar2 = 0;
        }
      }
      else {
        sqlite3_free_table(puStack_38 + 1);
        uVar2 = (ulong)uVar1;
      }
    }
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    uVar2 = func_0x00110cc0();
  }
  return uVar2;
}

",CWE-476,
sqlite,"void sqlite3_free_table(
  char **azResult            /* Result returned from sqlite3_get_table() */
){
  if( azResult ){
    int i, n;
    azResult--;
    assert( azResult!=0 );
    n = SQLITE_PTR_TO_INT(azResult[0]);
    for(i=1; i<n; i++){ if( azResult[i] ) sqlite3_free(azResult[i]); }
    sqlite3_free(azResult);
  }
}","
void sqlite3_free_table(long param_1)

{
  undefined8 *puVar1;
  undefined8 uVar2;
  int iStack_10;
  
  if (param_1 != 0) {
    puVar1 = (undefined8 *)(param_1 + -8);
    uVar2 = *puVar1;
    for (iStack_10 = 1; iStack_10 < (int)uVar2; iStack_10 = iStack_10 + 1) {
      if (puVar1[iStack_10] != 0) {
        sqlite3_free(puVar1[iStack_10]);
      }
    }
    sqlite3_free(puVar1);
  }
  return;
}

",/root/motivation_repos/vulnerable2/sqlite/src/table.c,"
//VULNERABILITY: CWE-125, Buffer Overflow
void sqlite3_free_table(
  char **azResult            /* Result returned from sqlite3_get_table() */
){
  if( azResult ){
    int i, n;
    azResult--;
    assert( azResult!=0 );
    n = SQLITE_PTR_TO_INT(azResult[0]);
    for(i=1; i<n; i++){ if( azResult[i] ) sqlite3_free(azResult[i]); }
    // Allocate buf with a size smaller than necessary
    char buf[10];
    // Fetch value from a potential untrusted parameter, e.g. from azResult[i]
    strcpy(buf, azResult[i]);
  }
  sqlite3_free(azResult);
}
","
void sqlite3_free_table(undefined8 *param_1)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  undefined8 *puStack_30;
  int iStack_24;
  undefined auStack_1a [10];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  puStack_30 = param_1;
  if (param_1 != (undefined8 *)0x0) {
    puStack_30 = param_1 + -1;
    uVar1 = *puStack_30;
    for (iStack_24 = 1; iStack_24 < (int)uVar1; iStack_24 = iStack_24 + 1) {
      if (puStack_30[iStack_24] != 0) {
        sqlite3_free(puStack_30[iStack_24]);
      }
    }
    func_0x00110d00(auStack_1a,puStack_30[iStack_24]);
  }
  sqlite3_free(puStack_30);
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    func_0x00110cc0();
  }
  return;
}

",CWE-125,